<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shawn is Learning</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="prelude.html">Shawn is learning</a></li><li class="chapter-item expanded "><a href="cloud-aws/INTRO.html"><strong aria-hidden="true">1.</strong> AWS Cloud</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cloud-aws/IAM.html"><strong aria-hidden="true">1.1.</strong> IAM</a></li><li class="chapter-item expanded "><a href="cloud-aws/VPC.html"><strong aria-hidden="true">1.2.</strong> VPC</a></li><li class="chapter-item expanded "><a href="cloud-aws/EC2.html"><strong aria-hidden="true">1.3.</strong> EC2</a></li><li class="chapter-item expanded "><a href="cloud-aws/ELB.html"><strong aria-hidden="true">1.4.</strong> ELB</a></li><li class="chapter-item expanded "><a href="cloud-aws/DynamoDB.html"><strong aria-hidden="true">1.5.</strong> DynamoDB</a></li><li class="chapter-item expanded "><a href="cloud-aws/cert-developer-asso.html"><strong aria-hidden="true">1.6.</strong> 자격증 공부</a></li></ol></li><li class="chapter-item expanded "><a href="books/spring/overview.html"><strong aria-hidden="true">2.</strong> Spring Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="books/spring/core-01-ioc-container.html"><strong aria-hidden="true">2.1.</strong> Core - 1. IoC Container</a></li></ol></li><li class="chapter-item expanded "><a href="os/index.html"><strong aria-hidden="true">3.</strong> 운영 체제</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="os/kernel.html"><strong aria-hidden="true">3.1.</strong> 커널</a></li><li class="chapter-item expanded "><a href="os/posix.html"><strong aria-hidden="true">3.2.</strong> POSIX</a></li><li class="chapter-item expanded "><a href="os/shell.html"><strong aria-hidden="true">3.3.</strong> 셸</a></li><li class="chapter-item expanded "><a href="os/link.html"><strong aria-hidden="true">3.4.</strong> 링크</a></li><li class="chapter-item expanded "><a href="os/shell-commands.html"><strong aria-hidden="true">3.5.</strong> 셸 명령어 목록</a></li><li class="chapter-item expanded "><a href="os/aix-monitoring-commands.html"><strong aria-hidden="true">3.6.</strong> AIX 모니터링 명령어</a></li><li class="chapter-item expanded "><a href="os/win-cmd-set-env-var.html"><strong aria-hidden="true">3.7.</strong> Windows 커맨드라인에서 환경변수 설정</a></li><li class="chapter-item expanded "><a href="os/hostid.html"><strong aria-hidden="true">3.8.</strong> hostid</a></li></ol></li><li class="chapter-item expanded "><a href="devops/docker/get-started-index.html"><strong aria-hidden="true">4.</strong> Docker 시작하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="devops/docker/get-started-part1.html"><strong aria-hidden="true">4.1.</strong> 소개 및 설치</a></li><li class="chapter-item expanded "><a href="devops/docker/get-started-part2.html"><strong aria-hidden="true">4.2.</strong> 컨테이너</a></li><li class="chapter-item expanded "><a href="devops/docker/get-started-part3.html"><strong aria-hidden="true">4.3.</strong> 서비스</a></li><li class="chapter-item expanded "><a href="devops/docker/get-started-part4.html"><strong aria-hidden="true">4.4.</strong> 스웜</a></li><li class="chapter-item expanded "><a href="devops/docker/note-01-bash-and-volume.html"><strong aria-hidden="true">4.5.</strong> hands on - bash &amp; volume 마운트</a></li><li class="chapter-item expanded "><a href="devops/docker/note-02-dev-requirements.html"><strong aria-hidden="true">4.6.</strong> hands on - 개발환경 세팅</a></li></ol></li><li class="chapter-item expanded "><a href="lang/index.html"><strong aria-hidden="true">5.</strong> 프로그래밍 언어</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/java/index.html"><strong aria-hidden="true">5.1.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/java/comparable-vs-comparator.html"><strong aria-hidden="true">5.1.1.</strong> Comparable과 Compartor</a></li><li class="chapter-item expanded "><a href="lang/java/difference-between-Log-vs-Logger.html"><strong aria-hidden="true">5.1.2.</strong> Log와 Logger</a></li><li class="chapter-item expanded "><a href="lang/java/javadump-diagnosis.html"><strong aria-hidden="true">5.1.3.</strong> Dump 분석</a></li><li class="chapter-item expanded "><a href="lang/java/jmeter.html"><strong aria-hidden="true">5.1.4.</strong> J Meter</a></li></ol></li><li class="chapter-item expanded "><a href="lang/js/index.html"><strong aria-hidden="true">5.2.</strong> JavaScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/js/this.html"><strong aria-hidden="true">5.2.1.</strong> JavaScript의 this</a></li><li class="chapter-item expanded "><a href="lang/js/class.html"><strong aria-hidden="true">5.2.2.</strong> Class</a></li><li class="chapter-item expanded "><a href="lang/js/hoisting.html"><strong aria-hidden="true">5.2.3.</strong> Hoisting</a></li><li class="chapter-item expanded "><a href="lang/js/iife.html"><strong aria-hidden="true">5.2.4.</strong> 즉시실행함수(IIFE)</a></li><li class="chapter-item expanded "><a href="lang/js/promise.html"><strong aria-hidden="true">5.2.5.</strong> 프로미스</a></li><li class="chapter-item expanded "><a href="lang/js/strict-mode.html"><strong aria-hidden="true">5.2.6.</strong> Strict mode</a></li><li class="chapter-item expanded "><a href="lang/js/tagged-template-literals.html"><strong aria-hidden="true">5.2.7.</strong> 템플릿 리터럴</a></li></ol></li><li class="chapter-item expanded "><a href="lang/rust/index.html"><strong aria-hidden="true">5.3.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/rust/how-to-install-rust.html"><strong aria-hidden="true">5.3.1.</strong> Rust 개발도구 설치하기</a></li><li class="chapter-item expanded "><a href="log/mdbook-guide.html"><strong aria-hidden="true">5.3.2.</strong> mdbook 가이드</a></li></ol></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/00-introduction.html"><strong aria-hidden="true">5.4.</strong> Kotlin programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/03-basic.html"><strong aria-hidden="true">5.4.1.</strong> 기본 작성방법</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/04-variable-and-function.html"><strong aria-hidden="true">5.4.2.</strong> 변수와 함수</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/05-types.html"><strong aria-hidden="true">5.4.3.</strong> 데이터 타입</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/06-condition.html"><strong aria-hidden="true">5.4.4.</strong> 조건문</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/07-class.html"><strong aria-hidden="true">5.4.5.</strong> 클래스</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/08-property.html"><strong aria-hidden="true">5.4.6.</strong> 프로퍼티</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/09-inheritance.html"><strong aria-hidden="true">5.4.7.</strong> 상속</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/10-abstract-class.html"><strong aria-hidden="true">5.4.8.</strong> 추상클래스</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/11-other-classes.html"><strong aria-hidden="true">5.4.9.</strong> 다른 클래스들</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/12-functional.html"><strong aria-hidden="true">5.4.10.</strong> 함수형 프로그래밍과 람다</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/13-high-order-function.html"><strong aria-hidden="true">5.4.11.</strong> 고차함수</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/14-collections.html"><strong aria-hidden="true">5.4.12.</strong> 컬렉션</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/15-null-safety-and-exception.html"><strong aria-hidden="true">5.4.13.</strong> Null 안정성과 예외</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/16-class-extension.html"><strong aria-hidden="true">5.4.14.</strong> 클래스 확장</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/17-generic.html"><strong aria-hidden="true">5.4.15.</strong> 제네릭</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/18-reflection.html"><strong aria-hidden="true">5.4.16.</strong> 리플렉션</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/19-technics.html"><strong aria-hidden="true">5.4.17.</strong> 다양한 기법</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/50-calling-kotlin-from-java.html"><strong aria-hidden="true">5.4.18.</strong> Java에서 코틀린 사용하기</a></li><li class="chapter-item expanded "><a href="lang/kotlin/kotlin-programming/40-calling-java-from-kotlin.html"><strong aria-hidden="true">5.4.19.</strong> 코틀린에서 자바 사용하기</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="design-pattern/index.html"><strong aria-hidden="true">6.</strong> 디자인 패턴</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design-pattern/inversion-of-control.html"><strong aria-hidden="true">6.1.</strong> 제어 역전 (IoC)</a></li><li class="chapter-item expanded "><a href="design-pattern/mvc-spring.html"><strong aria-hidden="true">6.2.</strong> MVC &amp; Spring MVC</a></li></ol></li><li class="chapter-item expanded "><a href="db/index.html"><strong aria-hidden="true">7.</strong> DB</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/oracle/index.html"><strong aria-hidden="true">7.1.</strong> Oracle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/oracle/oracle-flashback.html"><strong aria-hidden="true">7.1.1.</strong> Flashback을 이용한 데이터 복원</a></li><li class="chapter-item expanded "><a href="db/oracle/block.html"><strong aria-hidden="true">7.1.2.</strong> Block</a></li><li class="chapter-item expanded "><a href="db/oracle/high-water-mark.html"><strong aria-hidden="true">7.1.3.</strong> HWM</a></li></ol></li><li class="chapter-item expanded "><a href="db/redis/tutorial.html"><strong aria-hidden="true">7.2.</strong> REDIS tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="books/concrete-math/index.html"><strong aria-hidden="true">8.</strong> 구체수학</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="books/concrete-math/part1-recursive.html"><strong aria-hidden="true">8.1.</strong> 1장: 재귀적인 문제들</a></li></ol></li><li class="chapter-item expanded "><a href="books/object2019/intro.html"><strong aria-hidden="true">9.</strong> 오브젝트</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="books/object2019/chapter_01.html"><strong aria-hidden="true">9.1.</strong> 01_객체, 설계</a></li><li class="chapter-item expanded "><a href="books/object2019/chapter_02.html"><strong aria-hidden="true">9.2.</strong> 02_객체지향 프로그래밍</a></li><li class="chapter-item expanded "><a href="books/object2019/chapter_03.html"><strong aria-hidden="true">9.3.</strong> 03_역할, 책임, 협력</a></li></ol></li><li class="chapter-item expanded "><a href="log/index.html"><strong aria-hidden="true">10.</strong> 기록</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="log/2019.html"><strong aria-hidden="true">10.1.</strong> 2019년</a></li><li class="chapter-item expanded "><a href="log/2019-W16.html"><strong aria-hidden="true">10.2.</strong> 2019년 16주차</a></li><li class="chapter-item expanded "><a href="log/2019-04-17-aws-summit.html"><strong aria-hidden="true">10.3.</strong> AWS Summit Seoul 2019</a></li><li class="chapter-item expanded "><a href="log/2019-11-18-test-on-ie.html"><strong aria-hidden="true">10.4.</strong> IE 10 이하 테스트</a></li></ol></li><li class="chapter-item expanded "><a href="uncategorized.html"><strong aria-hidden="true">11.</strong> 미분류</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="general/vim-change-encoding-type.html"><strong aria-hidden="true">11.1.</strong> VIM 인코딩 타입 변경하기</a></li><li class="chapter-item expanded "><a href="general/mtu.html"><strong aria-hidden="true">11.2.</strong> MTU</a></li><li class="chapter-item expanded "><a href="general/vim-cheatsheet.html"><strong aria-hidden="true">11.3.</strong> VIM 치트시트</a></li><li class="chapter-item expanded "><a href="lang/nodejs/packaging-with-electron-packager.html"><strong aria-hidden="true">11.4.</strong> 일렉트론 앱 패키징</a></li><li class="chapter-item expanded "><a href="macos/misc.html"><strong aria-hidden="true">11.5.</strong> 일렉트론 앱 패키징</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Shawn is Learning</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="shawn-is-learning"><a class="header" href="#shawn-is-learning">Shawn is Learning</a></h1>
<p>매일의 기록을 남기기 위해서 시작했습니다.<br />
하루하루 알게된 내용을 기록합니다.<br />
대부분의 글이 정리되지 않은 노트입니다.<br />
Rust 언어로 작성된 <a href="http://rust-lang-nursery.github.io/mdBook/">mdbook</a>을 사용했습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aws-cloud-개요"><a class="header" href="#aws-cloud-개요">AWS Cloud 개요</a></h1>
<ul>
<li>
<p>클라우드 컴퓨팅?</p>
<ul>
<li>인프라는 더 이상 하드웨어가 아니다.</li>
<li>인프라를 서비스로 생각하자.</li>
<li>IT 리소스와 애플리케이션을 온디맨드로 제공하는 서비스</li>
<li>종량 과금제</li>
<li>유연성: IT 리소스를 필요한만큼 프로비저닝할 수 있음 =&gt; 하드웨어 낭비를 줄임</li>
</ul>
</li>
<li>
<p>클라우드 컴퓨팅의 종류: 아래 구분은 AWS 이후 타 업체에서 구분한 것임.</p>
<ul>
<li>IaaS: 컴퓨터, 네트워크, 스토리지 등 (EC2, EBS, S3, ...)</li>
<li>PaaS: 인프라 관리할 필요 없이 애플리케이션을 실행 (NoSQL, SQS, ...)</li>
<li>SaaS: 서비스 제공자가 관리하는 제품을 사용 (Workspaces, ...)</li>
</ul>
</li>
<li>
<p>이점</p>
<ul>
<li>자본비용의 가변화: 사용한 만큼만 지불</li>
<li>규모의 경제: 많이 사용할수록 더 저렴해짐</li>
<li>용량 추정 불필요: 필요한 IT 리소스 산정할 필요가 없음</li>
<li>속도 및 민첩성 개선: 필요한 리소스를 몇 분 만에 사용할 수 있음</li>
<li>IDC 투자비용 불필요</li>
<li>전세계 배포</li>
</ul>
</li>
<li>
<p>AWS: 웹 기반 클라우드 서비스</p>
<ul>
<li>관리형 vs 비관리형 서비스
<ul>
<li>비관리형: 사용자가 스케일링, 내결함성, 가용성을 관리
<ul>
<li>ex) EC2, 오토 스케일링을 설정하지 않는 한 트래픽 처리량 동일함</li>
</ul>
</li>
<li>관리형: 서비스에 내장되어 있음
<ul>
<li>ex) S3 정적 웹사이트 호스팅, 서비스가 각 파일의 가용성을 관리</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>클라우드 배포모델</p>
<ul>
<li>올인 클라우드: 애플리케이션의 모든 부분이 클라우드에서 실행
<ul>
<li>애플리케이션이 클라우드에서 생성 or 기존 인프라에서 클라우드로 Mig.</li>
<li>낮은 수준의 인프라 상에 구축하거나, 주요 인프라를 관리 설계/확장할 필요가 없음</li>
</ul>
</li>
<li>하이브리드: 레거시 리소스와 클라우드 리소스간의 연결
<ul>
<li>클라우드 리소스를 내부 시스템(On-premise)에 연결</li>
</ul>
</li>
</ul>
</li>
<li>
<p>마이크로서비스 특징</p>
<ul>
<li>민첩성: 서비스별 소규모 독립 팀으로 구성</li>
<li>유연한 조정: 기능 요구사항에 맞게 인프라 요구에 맞게 조정</li>
<li>손쉬운 배포: CI/CD 가능</li>
<li>기술적 자유: 팀에 맞는 최적의 도구를 자유롭게 선택</li>
<li>재사용 가능한 코드</li>
<li>복원력</li>
</ul>
</li>
<li>
<p>MSA 모범사례</p>
<ul>
<li>구성요소를 오류없이 변경
<ul>
<li>인터페이스는 계약: 한번 만든 외부 공개 API는 변경하면 안됨</li>
<li>기능 변경이 소비자에게 영향을 끼치면 안됨</li>
</ul>
</li>
<li>간단한 API를 사용
<ul>
<li>서비스 사용비용을 절감</li>
<li>복잡성 증가는 변경에 대한 저항 증가</li>
<li>적게 공유할수록 오류도 적음</li>
<li>상세 정보를 숨김</li>
</ul>
</li>
<li>서버를 상태 비저장 모드로 처리
<ul>
<li>상태를 저장하지 않으면 Auto Scaling을 통해 인스턴스를 쉽게 추가하고 제거할 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>
<p>아키텍쳐 진화</p>
<ul>
<li>EC2: H/W 추상화 / VM 단위 / 서버, 스토리지, 네트워킹, OS를 구성</li>
<li>ECS: OS 추상화 / 작업 단위 / 애플리케이션 구성</li>
<li>Lambda: 실행시간 / 함수 단위 / 필요시 코드를 실행</li>
</ul>
</li>
</ul>
<h2 id="aws-인프라-개요"><a class="header" href="#aws-인프라-개요">AWS 인프라 개요</a></h2>
<ul>
<li>AWS 데이터 센터
<ul>
<li>단일 데이터 센터에서 수천 개 서버 운영</li>
<li>모든 데이터 센터를 온라인으로 연결</li>
</ul>
</li>
<li>리전 및 AZ
<ul>
<li>리전: 여러 AZ를 포함하고 있는 지리적 위치</li>
<li>AZ
<ul>
<li>하나 이상의 데이터 센터로 구성</li>
<li>결함 분리 방식으로 설계</li>
<li>고속 프라이빗 링크를 통해 다른 AZ와 상호연결
<ul>
<li>AWS 내부 통신은 외부와 비교해 빠름</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>리전 선택 방법
<ul>
<li>법적 요구사항: 현지 법에 따라 특정 데이터의 물리적 위치를 강제할 때</li>
<li>고객 근접성: 가까울수록 빠르다</li>
<li>가용 서비스: 리전에 따라 사용할 수 있는 서비스의 차이가 있음</li>
<li>비용: 리전별로 다름 / 제일 저렴? CA / 제일 비싸? SP</li>
</ul>
</li>
</ul>
<h2 id="aws-기초-서비스"><a class="header" href="#aws-기초-서비스">AWS 기초 서비스</a></h2>
<h3 id="ec2"><a class="header" href="#ec2">EC2</a></h3>
<ul>
<li>특징
<ul>
<li>종량 과금제: 인스턴스 사용 시간만큼 비용 지불</li>
<li>HW/SW 선택의 자유: 원하는 OS, 원하는 스토리지 선택</li>
<li>Amazon Machine Image: Windows, Ubuntu, RHEL 등 제공하는 이미지 선택 가능</li>
<li>필요할 때만 사용: 서버를 <strong>인스턴스</strong>로 사용</li>
</ul>
</li>
<li>인스턴스 유형
<ul>
<li>범용(T2, M5, M4): 트래픽이 적은 웹 서버 및 소형 DB</li>
<li>컴퓨팅 최적화(C5, C4): 비디오 인코딩</li>
<li>메모리 최적화(X1e, X1, R4): 고성능 DB, 하둡/Spark</li>
<li>스토리지 최적화(H1, I3, D2): DW, 로그/데이터 처리 애플리케이션</li>
<li>가속 컴퓨팅(P3, P2, G3, F1): ML, 3D App 스트리밍</li>
</ul>
</li>
<li>요금
<ul>
<li>단위
<ul>
<li>초 단위 결제: Amazon Linux, Ubuntu</li>
<li>시간 단위: 그 외 OS</li>
</ul>
</li>
<li>인스턴스 종류
<ul>
<li>온디맨드: 일반 인스턴스</li>
<li>예약 인스턴스</li>
<li>스팟 인스턴스
<ul>
<li>사용되지 않는 인스턴스</li>
<li>언제든 사라질 수 있음</li>
<li>온디맨드 대비 최대 90% 비용 절감 가능</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="elb"><a class="header" href="#elb">ELB</a></h3>
<ul>
<li>특징
<ul>
<li>트래픽을 여러 AZ / 여러 EC2 인스턴스로 분산</li>
<li>EC2 상태확인 기능 지원</li>
<li>EC2 인스턴스에 대한 트래픽 라우팅 / LB 지원</li>
<li>상태확인: EC2 가용성 확인을 위해 주기적으로 Ping(상태확인)을 보냄
<ul>
<li>인스턴스 비정상이 확인되면 해당 인스턴스로의 라우팅을 중단</li>
</ul>
</li>
<li>고정세션
<ul>
<li>로드밸런서가 사용자의 세션을 특정 서버에 바인딩</li>
<li>단점
<ul>
<li>애플리케이션으니 확장을 제한</li>
<li>서버 전체에서의 불균등한 로드</li>
<li>단일 사용자의 로드가 서버에 균등하게 분배하지 않기때문에 사용자 응답지연 가능성</li>
</ul>
</li>
</ul>
</li>
<li>고정세션 대신 캐시를 사용하자
<ul>
<li>세션정보를 외부 캐시서버(EleastiCache/DynamoDB)로 빼자</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="auto-scaling"><a class="header" href="#auto-scaling">Auto Scaling</a></h3>
<ul>
<li>특징
<ul>
<li>애플리케이션 처리를 위한 EC2 인스턴스 수를 적절하게 유지</li>
<li>사용자 정의 조건(ex: CPU 사용률 80%)에 따라 인스턴스 수를 조정</li>
<li>조정 타입
<ul>
<li>수동 조정: 최대/최소 및 원하는 용량 설정</li>
<li>예약 조정: 예측가능한 이벤트에 따라 AS 발생 시간을 지정</li>
<li>동적 조정: 성능 측정 임계값을 기반으로 조정</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iam"><a class="header" href="#iam">IAM</a></h1>
<p>IAM 사용하기</p>
<h2 id="cli-cheat-sheet"><a class="header" href="#cli-cheat-sheet">CLI Cheat sheet</a></h2>
<pre><code class="language-bash"># --profile=admin은 아래 명령의 실행권한이 있는 계정이다.
$ aws iam create-user --user-name=shawn # 'shawn'이라는 이름을 가진 계정 생성
$ aws iam get-user --user-name=shawn --profile=admin # shawn 계정 조회 
{
    &quot;User&quot;: {
        &quot;Path&quot;: &quot;/&quot;,
        &quot;UserName&quot;: &quot;shawn&quot;,
        &quot;UserId&quot;: &quot;AIDASK3VMLLUAZOZT2IMG&quot;,
        &quot;Arn&quot;: &quot;arn:aws:iam::160770579176:user/shawn&quot;,
        &quot;CreateDate&quot;: &quot;2019-04-18T04:28:26Z&quot;
    }
}
$ aws iam tag-user --profile=admin --user-name=shawn --tags Key=type,Value=cli Key=name,Value=shshin Key=desc,Value=&quot;cli test&quot; # 태그 3건 추가
$ aws iam get-user --user-name=shawn --profile=admin # 다시 계정정보 조회하면 태깅된 것을 볼 수 있다.
{
    &quot;User&quot;: {
        &quot;Path&quot;: &quot;/&quot;,
        &quot;UserName&quot;: &quot;shawn&quot;,
        &quot;UserId&quot;: &quot;AIDASK3VMLLUAZOZT2IMG&quot;,
        &quot;Arn&quot;: &quot;arn:aws:iam::160770579176:user/shawn&quot;,
        &quot;CreateDate&quot;: &quot;2019-04-18T04:28:26Z&quot;,
        &quot;Tags&quot;: [
            {
                &quot;Key&quot;: &quot;type&quot;,
                &quot;Value&quot;: &quot;cli&quot;
            },
            {
                &quot;Key&quot;: &quot;name&quot;,
                &quot;Value&quot;: &quot;shshin&quot;
            },
            {
                &quot;Key&quot;: &quot;desc&quot;,
                &quot;Value&quot;: &quot;cli test&quot;
            }
        ]
    }
}
$ aws iam add-user-to-group --group-name=beginner \ # 생성한 계정을 특정 그룹에 포함시키는 명령
--user-name=shawn \
--profile=admin
$ aws iam get-group --group-name=beginner --profile=admin
{
    &quot;Users&quot;: [
        {
            &quot;Path&quot;: &quot;/&quot;,
            &quot;UserName&quot;: &quot;shawn&quot;,
            &quot;UserId&quot;: &quot;AIDASK3VMLLUAZOZT2IMG&quot;,
            &quot;Arn&quot;: &quot;arn:aws:iam::160770579176:user/shawn&quot;,
            &quot;CreateDate&quot;: &quot;2019-04-18T04:28:26Z&quot;
        },
        {
            &quot;Path&quot;: &quot;/&quot;,
            &quot;UserName&quot;: &quot;shshin-cli&quot;,
            &quot;UserId&quot;: &quot;AIDASK3VMLLUER4D26ZLI&quot;,
            &quot;Arn&quot;: &quot;arn:aws:iam::160770579176:user/shshin-cli&quot;,
            &quot;CreateDate&quot;: &quot;2019-04-18T04:24:58Z&quot;
        }
    ],
    &quot;Group&quot;: {
        &quot;Path&quot;: &quot;/&quot;,
        &quot;GroupName&quot;: &quot;beginner&quot;,
        &quot;GroupId&quot;: &quot;AGPASK3VMLLUMJYDCHGM6&quot;,
        &quot;Arn&quot;: &quot;arn:aws:iam::160770579176:group/beginner&quot;,
        &quot;CreateDate&quot;: &quot;2019-04-18T04:24:37Z&quot;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vpc"><a class="header" href="#vpc">VPC</a></h1>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<ul>
<li>VPC는 AWS의 가상 네트워크</li>
</ul>
<h2 id="hands-on"><a class="header" href="#hands-on">Hands on</a></h2>
<h3 id="vpc-public-subnet-구성하기"><a class="header" href="#vpc-public-subnet-구성하기">VPC Public subnet 구성하기</a></h3>
<ol>
<li>VPC 생성</li>
<li>Subnet 생성</li>
<li>Internet Gateway 생성 및 서브넷 연결</li>
<li>acl 구성</li>
<li>ssh open</li>
<li>http open</li>
<li>Route table에서 0.0.0.0/0 -&gt; Internet gateway로 연결</li>
</ol>
<p>--&gt; 서버 인스턴스에서 외부로 나가는 connection lost</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec2-1"><a class="header" href="#ec2-1">EC2</a></h1>
<h2 id="faq-1"><a class="header" href="#faq-1">FAQ</a></h2>
<h3 id="개요"><a class="header" href="#개요">개요</a></h3>
<ul>
<li>EC2는 무엇인가?
<ul>
<li>컴퓨팅 규모를 자유자재로 변경할 수 있는 웹 서비스</li>
<li>쉽게 웹 규모의 컴퓨팅 작업(웹 서버?)를 수행할 수 있게 설계됨</li>
</ul>
</li>
<li>EC2로 할 수 있는 작업?
<ul>
<li>웹 서비스 인터페이스를 통해 컴퓨팅을 수행</li>
<li>간편하게 필요한 용량을 얻을 수 있음</li>
<li>서버 인스턴스를 획득하고 부팅하는데 단 몇분 소요</li>
</ul>
</li>
<li>EC2를 구성하는 방법
<ol>
<li>AWS 계정을 설정</li>
<li>AMI를 선택하거나 만들어 선택</li>
<li><code>RunInstances</code> API를 사용하여 원하는 수의 인스턴스를 생성 (인스턴스 개수는 20개로 제한)</li>
<li>20개가 넘는 인스턴스를 구성하려면 요청 양식을 작성해야 함</li>
<li>API 요청 결과가 성공 메시지를 반환하고 인스턴스를 시작함</li>
<li><code>DescribeInstances</code> API를 사용해서 인스턴스의 상태를 확인</li>
<li><code>TerminateInstances</code> API를 사용해서 인스턴스를 종료(인스턴스 소멸)</li>
<li>EBS를 사용하는 경우 <code>StopInstances</code> API로 인스턴스를 중지시킨 경우에도 데이터를 보존할 수 있음</li>
</ol>
</li>
<li>인스턴스 스토어와 EBS의 차이
<ul>
<li>EBS는 인스턴스 수명에 관계없이 데이터 보존</li>
<li>로컬 인스턴스 스토리지는 인스턴스 수명기간 동안만 데이터가 유지됨
<ul>
<li>인스턴스를 중지(stop)하면 데이터가 소멸됨</li>
</ul>
</li>
</ul>
</li>
<li>인스턴스 실행 소요시간
<ul>
<li>약 10분이 걸리지 않지만, 처음 부팅하는 인스턴스는 약간 더 걸릴 수 있음</li>
</ul>
</li>
</ul>
<h2 id="hands-on-1"><a class="header" href="#hands-on-1">Hands on</a></h2>
<h3 id="ec2-인스턴스-생성하기"><a class="header" href="#ec2-인스턴스-생성하기">EC2 인스턴스 생성하기</a></h3>
<p><a href="https://aws.amazon.com/ko/getting-started/tutorials/launch-a-virtual-machine/">Linux 가상 머신 시작</a> 를 보고 따라함.</p>
<ul>
<li>인스턴스 정보
<ul>
<li>인스턴스 이미지: ami-00dc207f8ba6dc919 Amazon Linux AMI 2018.03.0 (HVM)</li>
<li>인스턴스 유형: t2.micro</li>
</ul>
</li>
</ul>
<h4 id="인스턴스-접속-ssh"><a class="header" href="#인스턴스-접속-ssh">인스턴스 접속 (SSH)</a></h4>
<blockquote>
<p>인스턴스 생성할 때 발급받은 Keypair(*.pem)은 파일 권한을 400으로 변경해야 한다.
아래 명령이 필요하다.<br />
<code>chmod 400 MyKeyPair.pem</code></p>
</blockquote>
<p>SSH로 EC2 접속하기</p>
<pre><code class="language-bash">$ ssh -i ~/.ssh/MyMacbookKeypair.pem ec2-user@13.125.207.77
</code></pre>
<h4 id="cli-keypair"><a class="header" href="#cli-keypair">CLI KeyPair</a></h4>
<h5 id="keypair-생성"><a class="header" href="#keypair-생성">KeyPair 생성</a></h5>
<pre><code class="language-bash">$ aws ec2 create-key-pair --key-name MyKeyPair --query 'KeyMaterial' --output text &gt; MyKeyPair.pem
</code></pre>
<h3 id="ec2-인스턴스-cli로-생성"><a class="header" href="#ec2-인스턴스-cli로-생성">EC2 인스턴스 CLI로 생성</a></h3>
<pre><code class="language-bash">$ aws ec2 run-instances --profile admin \
--image-id ami-00dc207f8ba6dc919 --count 1 --instance-type t2.micro \
--key-name OfficeKeyPair --security-group-ids sg-09175e0acb5baeef8 --subnet-id subnet-04064fc6dc0785aef
</code></pre>
<h4 id="cli-cheat-sheet-1"><a class="header" href="#cli-cheat-sheet-1">CLI Cheat Sheet</a></h4>
<pre><code class="language-bash">$ aws ec2 describe-images --image-ids ami-00dc207f8ba6dc919 --profile admin # EC2 인스턴스 이미지 조회
$ aws ec2 describe-instances --instance-ids i-0cb2272fff1199138 --profile admin # 인스턴스 조회
$ aws ec2 describe-instance-status --instance-ids i-0cb2272fff1199138 --profile admin # 인스턴스 상태 조회
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elastic-load-balancing"><a class="header" href="#elastic-load-balancing">Elastic Load Balancing</a></h1>
<h2 id="intro"><a class="header" href="#intro">Intro</a></h2>
<ul>
<li>Elastic Load Balancing, ELB는 네트워크 트래픽을 여러 가용영역에 배포한다.</li>
<li>트래픽 배포 대상은 EC2 인스턴스, 컨테이너, IP 주소 등이 포함된다.</li>
<li>트래픽의 변화에 따라 로드밸런서를 확장/축소할 수 있다.</li>
</ul>
<h2 id="장점"><a class="header" href="#장점">장점</a></h2>
<ul>
<li>가용성
<ul>
<li>여러 가용역역에 있는 컴퓨팅 리소스에 트래픽을 분산시킴</li>
<li>정상 상태의 리소스에만 트래픽을 수신하도록 함
<ul>
<li>리소스가 응답 불가능한 상태인 경우, 네트워크 트래픽 배포 대상에서 제외한다.</li>
</ul>
</li>
<li>리전에 걸친 로드 배ㅔㄹ런싱 가능</li>
<li>99.99% 가용성 보장</li>
</ul>
</li>
<li>보안
<ul>
<li>VPC와 연동</li>
<li>인증서 관리, 사용자 인증, SSL/TLS 복호화 등의 보안기능 제공</li>
<li>컴퓨팅 리소스가 주요 작업에 집중할 수 있도록 암복호화 작업을 로드밸런서로 떠넘길 수 있다.</li>
</ul>
</li>
<li>탄력성
<ul>
<li>네트워크 트래픽 변화에 빠르개 대처 가능ㄴ</li>
<li>Auto Scaling 통합해서 자동으로 애플리케이션 리소스 확보</li>
<li>컴퓨팅 리소스의 추가/제거가 자유롭다. </li>
</ul>
</li>
<li>유연성
<ul>
<li>IP 주소를 사용해서 라우팅 할 수 있음</li>
<li>동일 인스턴스에서 많은 애플리케이션을 호스팅 할 수 있음</li>
</ul>
</li>
<li>모니터링
<ul>
<li>CloudWatch를 통해 애플리케이션 성능을 실시간으로 모니터링 가능</li>
</ul>
</li>
<li>하이브리드 로드 밸런싱
<ul>
<li>AWS와 온 프레미스 리소스에 로드밸런싱 할 수 있음</li>
</ul>
</li>
</ul>
<h2 id="qa"><a class="header" href="#qa">Q&amp;A</a></h2>
<h3 id="elb의-종류와-적용-케이스"><a class="header" href="#elb의-종류와-적용-케이스">ELB의 종류와 적용 케이스</a></h3>
<ul>
<li>Application Load Balancer
<ul>
<li>HTTP/S 트래픽 로드밸런싱에 적합</li>
<li>7 계층(Application layer)에서 작동</li>
</ul>
</li>
<li>Network Load Balancer
<ul>
<li>TCP/TLS 트래픽의 로드 밸런싱에 적합</li>
<li>4 계층(Transport layer)에서 작동</li>
<li>고도의 성능이 요구되거나 지연시간이 낮아야 하는 애플리케이션에서 사용</li>
</ul>
</li>
<li>Classic Load Balancer
<ul>
<li>EC2-Classic 네트워크 내에 구축된 애플리케이션을 대상으로 함 (레거시?)</li>
</ul>
</li>
</ul>
<h3 id="퍼블릭-ip를-사용하지-않고-elb-api-액세스"><a class="header" href="#퍼블릭-ip를-사용하지-않고-elb-api-액세스">퍼블릭 IP를 사용하지 않고 ELB API 액세스</a></h3>
<ul>
<li>VPC 엔드포인트를 생성하여 ELB API에 비공개로 액세스 가능</li>
</ul>
<h3 id="alb"><a class="header" href="#alb">ALB</a></h3>
<ul>
<li>지원 운영체제? -&gt; EC2 서비스가 지원하는 모든 운영체제</li>
<li>지원 프로토콜? -&gt; HTTP/HTTPS</li>
<li>HTTP/2 지원</li>
<li>웹소켓 지원</li>
<li>요청 추적기능 활성화</li>
<li>ALB 트래픽만 허용하도록 EC2 인스턴스 구성 가능</li>
<li>ALB 앞단의 보안그룹 구성 가능</li>
<li>Classic Load Balancer API를 ALB에 사용 불가</li>
<li>로드밸런서 유형은 전환 불가</li>
<li>Classic Load Balancer -&gt; ALB 마이그레이션 가능</li>
<li>4 계층 기능이 필요하다면 NLB를 사용해야 함</li>
<li>단일 ALB로 HTTP(80 포트) 및 HTTPS(443 포트) 에 대한 요청 처리 가능</li>
<li>ALB API 호출 기록을 얻으려면 CloudTrail을 사용하면 됨</li>
<li><code>HTTPS 종료</code>를 이용하려면 SSL 인증서를 로드밸런서에 설치해야 함</li>
<li>SSL 인증서를 받으려면 Certificate Manager를 이용해서 프로비저닝 가능</li>
<li>Certificate Manager와 통합되어, 간단하게 로드밸런서에 인증서를 연결할 수 있음
<ul>
<li>인증서 구매, 업로드 및 갱신 프로세스가 자동화 됨</li>
</ul>
</li>
<li>SNI(서버 이름 표시)는 하나 이상의 인증서를 동일 리스너에 연결하면 자동으로 활성화 됨
<ul>
<li>반대로 하나의 인증서만 연결한 경우 자동으로 비활성화 됨</li>
</ul>
</li>
<li>동일 도메인용 인증서 여러개를 보안 리스너에 연결 가능</li>
<li>ALB는 IPv6을 지원함</li>
<li>ALB 규칙 설정
<ul>
<li>리스너에 대해 규칙을 구성할 수 있음</li>
<li>규칙은 조건과 조건이 충족될 경우 수행할 작업으로 구성됨</li>
<li>조건: 호스트 헤더, 경로, HTTP 헤더, 메서드, 쿼리 파라미터, 소스 IP CIDR</li>
<li>작업: 리다이렉션, 고정 응답, 인증 및 전달</li>
</ul>
</li>
<li>ALB 리소스 제한
<ul>
<li>리전 제한
<ul>
<li>리전당 로드 밸런서: 20</li>
<li>리전당 대상 그룹: 3000</li>
</ul>
</li>
<li>로드 밸런서 제한
<ul>
<li>로드 밸런서당 리스너: 50</li>
<li>로드 밸런서당 대상: 1000</li>
<li>로드 밸런서당 가용 영역당 서브넷: 1</li>
<li>로드 밸런서당 보안 그룹: 5</li>
<li>로드 밸런서당 규칙(기본 규칙은 계산하지 않음): 100</li>
<li>로드 밸런서당 인증서(기본 인증서는 포함되지 않음): 25</li>
<li>로드 밸런서당 대상을 등록할 수 있는 횟수: 100</li>
</ul>
</li>
<li>대상 그룹 제한
<ul>
<li>대상 그룹당 로드 밸런서: 1</li>
<li>대상 그룹당 대상(인스턴스 또는 IP 주소): 1000</li>
<li>대상 그룹당 대상(Lambda 함수): 1</li>
</ul>
</li>
<li>규칙 제한
<ul>
<li>규칙당 일치 평가: 5</li>
<li>규칙당 와일드카드: 5</li>
<li>규칙당 작업: 2(하나는 옵션 인증 작업, 하나는 필수 작업)</li>
</ul>
</li>
</ul>
</li>
<li>WAF와 통합하여 웹 애플리케이션의 공격으로부터 방어할 수 있음
<ul>
<li>IP 주소, HTTP 헤더 및 사용자 정의 URI를 기반으로 규칙을 구성할 수 있음</li>
</ul>
</li>
<li>로드 밸런서의 VPC 내에 있는 대상으로 로드밸런싱 가능</li>
<li>ALB는 교차 영역 로드 밸런싱이 활성화 되어있음</li>
<li>Cognito와 통합하여 로드밸런서의 OpenID 자격증명공급자 기본 지원</li>
<li>ALB의 리디렉션유형
<ul>
<li>HTTP to HTTP: http://foo -&gt; http://bar</li>
<li>HTTP to HTTPS: http://foo -&gt; https://bar, https://foo:80/foz -&gt; https://bar:8080/baz</li>
<li>HTTPS to HTTPS: https://foo -&gt; https://bar</li>
</ul>
</li>
<li>ALB는 모든 컨텐츠 유형을 지원</li>
<li>ALB를 통해 Lambda 호출할 수 있음
<ul>
<li>ALB의 규칙이 일치하는 경우 람다 함수가 호출됨, 요청 컨텐츠 전문은 람다 함수에 JSON 형식으로 전달</li>
<li>람다 함수의 응답은 JSON 형식</li>
<li>로드 밸런서는 Lambda Invoke API를 사용하여 람다 함수를 호출</li>
<li>ELB는 람다 함수 호출 권한이 있어야 함</li>
</ul>
</li>
</ul>
<h3 id="alb-요금"><a class="header" href="#alb-요금">ALB 요금</a></h3>
<ul>
<li>실행 시간, 시간당 사용된 로드밸런서 용량 단위(LCU)에 대해 요금이 부가됨</li>
<li>로드밸런서 용량 단위(LCU)는 트래필을 처리하는 차원(새 연결, 활성 연결, 대역폭) 중 최대로 소비된 리소스를 정의함</li>
<li>CloudWatch를 통해 LCU를 측정하는 네 차원의 사용량을 확인 가능함</li>
<li>부분 LCU도 과금됨</li>
<li>규칙 평가는 처리된 규칙 수와 한 시간 동안의 평균 요청 속도의 곱으로 정의됨</li>
<li>교차영역 로드밸런싱을 위한 리전 AWS 데이터 전송에 요금은 부과되지 않음</li>
<li>ALB 사용자 인증기능 활성화에 별도 요금은 부과되지 않으나 Cognito와 함께 사용하는 경우 Cognito 요금이 적용됨</li>
<li>Lambda를 사용하는 경우, ALB가 실행된 시간과 시간당 사용된 로드밸런서 용량단위에 대해 요금이 부과됨</li>
<li>람다에서 처리된 바이트와 다른 대상(EC2, Container, 온프레미스 서버)에서 처리된 바이트는 클라우드 지표로 확인 가능함
<ul>
<li>Lambda -&gt; LambdaTargetProcessedBytes</li>
<li>Others -&gt; StandardProcessedBytes</li>
</ul>
</li>
</ul>
<h3 id="network-load-balancer"><a class="header" href="#network-load-balancer">Network Load Balancer</a></h3>
<ul>
<li>NLB는 TCP, UDP, TCP+UDP 리스너, TLS 리스너를 지원</li>
<li>NLB는 4계층 로드밸런싱을 제함
<ul>
<li>초당 수백만 개의 요청과 변동성이 높은 트래픽 패턴을 처리하도록 설계됨</li>
<li>클라이언트 소스 IP를 유지함</li>
<li>지연시간이 매우 짧음</li>
<li>웹소켓 유형에 유용한 장기간 연결도 지함</li>
</ul>
</li>
<li>TCP, UDP 프로토콜을 동일한 포트에서 처리하려면 TCP+UDP 리스너를 사용해야 함</li>
<li>NLB는 Elastic IP를 사용할 수 있음
<ul>
<li>NLB 주소는 사용자 또는 ELB가 제어해야 함
<ul>
<li>이렇게 해야 Elastic IP를 사용할 때 클라이언트가 알고있는 주소가 변경되지 않음</li>
</ul>
</li>
<li>각 서브넷에서 NLB는 단일 공용/인터넷 IP 주소만 지원함</li>
<li>NLB가 삭제되는 경우 Elastic IP는 할당된 풀로 반환됨</li>
</ul>
</li>
<li>NLB는 각 서브넷에서 단일 Private IP를 지원함</li>
<li>임의의 주소로 로드밸런싱 하는 방법 (TCP만 지원함)
<ul>
<li>로드밸런서 VPC CIDR의 모든 주소</li>
<li>로드밸런서 외부의 AWS Direct Connect를 통해 액세스 할 수 있는 범위의 IP주소
<ul>
<li>Private Network: RFC 1918 범위 (10.0.0.0/8, 172.16.0.0/12 및 192.168.0.0/16)</li>
<li>Shared Address Space: RFC 6598 범위 (100.64.0.0/10)</li>
</ul>
</li>
</ul>
</li>
<li>VPC와 온프레미스 위치에 배포된 애플리케이션을 로드밸런싱 하려면 각각 별개의 로드밸런서를 사용하고 DNS 가중치를 사용하여 VPC와 온프레미스 대상 간에 가중치 기반 로드밸런싱을 사용할 수 있음</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamodb"><a class="header" href="#dynamodb">DynamoDB</a></h1>
<h2 id="개요-1"><a class="header" href="#개요-1">개요</a></h2>
<p>DynamoDB는?</p>
<ul>
<li>NoSQL 데이터베이스 서비스</li>
<li>AWS에서 서비스</li>
<li><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/EncryptionAtRest.html">유휴시 암호화 제공</a></li>
<li>AWS management console을 통해 사용량 측정 가능
<ul>
<li>프로비저닝 가능</li>
</ul>
</li>
<li><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/BackupRestore.html">온디맨드 백업기능</a> 제공</li>
<li><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/PointInTimeRecovery_Howitworks.html">특정 시점으로 복구</a> 가능: 최근 35일 중 원하는 시점으로 복구</li>
<li>데이터에 TTL(Time To Live) 설정 가능</li>
<li>고가용성 및 내구성
<ul>
<li>테이블의 데이털르 충분한 수의 서버로 자동 분산 -&gt; 일관되게 빠른 성능 보장</li>
<li>모든 데이터가 SSD에 저장되고 여러 리전에 걸쳐 복제 -&gt; 고가용성 및 내구성 보장</li>
<li><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/GlobalTables.html">전역 테이블</a>을 사용하여 여러 리전간에 테이블 동기화 가능</li>
</ul>
</li>
</ul>
<h2 id="특징"><a class="header" href="#특징">특징</a></h2>
<h3 id="읽기-일관성-consistency-read"><a class="header" href="#읽기-일관성-consistency-read">읽기 일관성 (Consistency Read)</a></h3>
<p>다이나모DB는 데이터를 읽을 때 최근에 변경내역이 반영되지 않을 수 있다. 아래 작업이 순차적으로 일어날 경우, 3번 작업에서 이름이 홍길동으로 나올 수도 있다.</p>
<ol>
<li>데이터를 쓴다. <code>{&quot;Key&quot;: 1, &quot;이름&quot;: &quot;홍길동&quot;}</code></li>
<li>데이터를 변경한다. <code>{&quot;Key&quot;: 1, &quot;이름&quot;: &quot;홍두깨&quot;}</code></li>
<li>Key: 1인 항목을 조회한다. -&gt; <code>{&quot;Key&quot;: 1, &quot;이름&quot;: ?}</code></li>
</ol>
<p>이를 최종적 읽기 일관성 (Eventually Consistency Read)라고 한다.</p>
<h4 id="강력한-읽기-일관성-strongly-consistency-read"><a class="header" href="#강력한-읽기-일관성-strongly-consistency-read">강력한 읽기 일관성 (Strongly Consistency Read)</a></h4>
<ul>
<li>이전 쓰기작업의 업데이트를 모두 반영하여 조회하고 싶은 경우, 강력한 읽기 일관성을 사용한다.</li>
<li>DynamoDB 읽기 API는 기본적으로 최종적 읽기 일관성을 사용한다. 강력한 읽기 일관성을 사용하고 싶으면 ConsistencyRead 파라미터를 true로 설정한다. 이 경우 읽기 요청단위가 달라진다. (읽기/쓰기 용량모드 참고)</li>
<li>GSI는 강력한 읽기 일관성을 지원하지 않는다.</li>
</ul>
<h3 id="읽기-쓰기-용량모드"><a class="header" href="#읽기-쓰기-용량모드">읽기 쓰기 용량모드</a></h3>
<ul>
<li>읽기 요청 유닛 1개는 강력한 읽기 일관성으로 4kb 데이터를 읽을 수 있다.
<ul>
<li>최종적 읽기 일관성을 사용할 경우 0.5 유닛을 소비한다.</li>
<li>8kb 데이터를 읽을 경우, 강력한 읽기 일관성 모드에서 유닛 2개, 최종적 읽기 일관성 모드에서 유닛 1개를 소비한다.</li>
</ul>
</li>
<li>쓰기 요청 유닛 1개는 1kb 데이터를 쓸 수 있다.</li>
</ul>
<h3 id="파티션-및-데이터-배포"><a class="header" href="#파티션-및-데이터-배포">파티션 및 데이터 배포</a></h3>
<ul>
<li>DynamoDB는 테이블을 생성할 때 충분한 수의 파티션을 할당한다.
<ul>
<li>파티션의 한도가 초과하여 테이블의 처리량을 늘려야 할때 파티션을 늘린다.</li>
<li>추가적인 스토리지 공간이 필요햔 경우 파티션을 늘린다.</li>
</ul>
</li>
<li>데이터를 쓸 때, 파티션 키값으로 해시값을 구해서 데이터를 저장할 파티션을 결정한다.</li>
<li>정렬키가 있는 경우, 파티션 키 값으로 데이터를 저장한 파티션을 찾은 다음, 정렬 키 값을 이용하여 순차적으로 데이터를 스캔한다.</li>
</ul>
<h2 id="작동방식-핵심-구성요소"><a class="header" href="#작동방식-핵심-구성요소">작동방식: 핵심 구성요소</a></h2>
<ul>
<li><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/Limits.html">다이나모DB 기능 제한</a>에 대해서 알아보기</li>
</ul>
<h3 id="테이블-항목-및-속성"><a class="header" href="#테이블-항목-및-속성">테이블, 항목 및 속성</a></h3>
<ul>
<li>테이블: 데이터의 집합, RDBMS의 테이블과 같다.</li>
<li>항목: 테이블은 0개 이상의 항목이 존재한다. RDBMS의 tuple, record</li>
<li>속성: 각 항목은 1개 이상의 속성을 가진다. RDBMS의 field, column</li>
</ul>
<p><img src="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/images/HowItWorksPeople.png" alt="예제-1" /></p>
<p>위 People 테이블에서</p>
<ul>
<li>테이블은 3건의 항목을 가지고 있다.</li>
<li>첫 번째 항목은 4건의 속성을 가지고 있다.</li>
<li><em>People</em> 테이블은 기본 키 <em>PersonId</em>를 가진다.</li>
<li>속성에 대해서
<ul>
<li>테이블은 스키마가 없다. 속성을 미리 정의할 필요가 없다.</li>
<li>대부분의 항목은 <em>스칼라</em> 형식이다. -&gt; 스칼라 형식은 하나의 값만 가질 수 있음. 문자열, 숫자 등의 형식을 말함.</li>
<li>일부 항목은 내포 속성(<em>Address</em> 속성)를 가진다. 다이나모DB는 32레벨까지 내포 속성을 지원한다. -&gt; Map과 유사함</li>
</ul>
</li>
</ul>
<h3 id="키"><a class="header" href="#키">키</a></h3>
<p>테이블을 생성할 때 기본 키 지정은 필수이다. 기본 키는 각 항목을 나타내는 고유 식별자이다. 복수 건의 항목이 동일한 기본 키를 가질 수 없다.<br />
다이나모DB는 두 가지 기본 키를 지원한다.</p>
<p>기본 키는 <em>스칼라</em> 타입이여야 한다. 즉, 키는 문자열, 숫자 혹은 이진수 데이터만 가질 수 있다.</p>
<h4 id="파티션-키-해시-속성"><a class="header" href="#파티션-키-해시-속성">파티션 키 (해시 속성)</a></h4>
<ul>
<li>하나의 속성으로 구성되는 기본 키</li>
<li>파티션 키를 해시함수의 입력을 사용함 =&gt; 파티션 키에 따라 물리적 스토리지(파티션)이 결정됨</li>
<li>파티션 키로만 구성된 테이블에서 각 항목이 동일한 파티션 키를 가질 수 없음.</li>
<li>파티션 키로 항목 액세스가 가능함</li>
</ul>
<h4 id="정렬-키-범위-속성"><a class="header" href="#정렬-키-범위-속성">정렬 키 (범위 속성)</a></h4>
<ul>
<li>파티션 키와 함께 정렬 키를 사용할 경우, 각 항목은 동일한 파티션 키를 가질 수 있다. 단, 정렬 키는 달라야 한다.</li>
<li>정렬 키는 유연한 쿼리를 지원한다.</li>
<li>정렬 키의 쿼리 방식은 <a href="cloud-aws/DynamoDB.html#%EC%A0%95%EB%A0%AC_%ED%82%A4_%EC%A1%B0%EA%B1%B4_%ED%91%9C%ED%98%84%EC%8B%9D">정렬 키 조건 표현식</a>을 참고한다.</li>
</ul>
<h3 id="보조-인덱스"><a class="header" href="#보조-인덱스">보조 인덱스</a></h3>
<p>테이블은 하나 이상의 보조인덱스를 생성할 수 있다.
보조 인덱스의 대체 키를 사용하여 쿼리를 할 수 있다.
모든 인덱스는 테이블에 속해있다. 이를 <strong>기본 테이블</strong>이라 한다.
다이나모DB는 인덱스를 자동으로 유지한다. 즉, 기본 테이블의 항목이 변경되면 인덱스의 해당 항목도 변경된다.
인덱스를 생성할 때 기본 테이블에서 인덱스로 복사하거나 <em>프로젝션</em>할 속성을 지정한다. 기본 키 속성은 무조건 프로젝션된다.</p>
<h3 id="다이나모-스트림"><a class="header" href="#다이나모-스트림">다이나모 스트림</a></h3>
<ul>
<li>스트림은 다니아모DB 데이터의 변경 이벤트를 캡쳐한다.</li>
<li>캡쳐한 이벤트는 스트림 레코드에서 볼 수 있다.</li>
<li>스트림 레코드는 테이블 이름, 타임스탬프, 메타 데이터 등을 가지고 있다.</li>
<li>스트림 레코드의 수명은 24시간이다.</li>
<li>스트림과 람다를 이용해서 트리거를 생성할 수 있다.</li>
</ul>
<h2 id="cli"><a class="header" href="#cli">CLI</a></h2>
<h3 id="테이블-생성"><a class="header" href="#테이블-생성">테이블 생성</a></h3>
<pre><code class="language-bash">aws dynamodb create-table \
    --table-name Member \
    --attribute-definitions \
        AttributeName=name,AttributeType=S \
        AttributeName=age,AttributeType=N \
    --key-schema \
        AttributeName=name,KeyType=HASH \
        AttributeName=age,KeyType=RANGE \
    --provisioned-throughput \
        ReadCapacityUnits=1,WriteCapacityUnits=1 \
    --endpoint-url http://localhost:8000
</code></pre>
<p>생성 결과</p>
<pre><code class="language-bash">{
    &quot;TableDescription&quot;: {
        &quot;AttributeDefinitions&quot;: [
            {
                &quot;AttributeName&quot;: &quot;name&quot;,
                &quot;AttributeType&quot;: &quot;S&quot;
            },
            {
                &quot;AttributeName&quot;: &quot;age&quot;,
                &quot;AttributeType&quot;: &quot;N&quot;
            }
        ],
        &quot;TableName&quot;: &quot;Member&quot;,
        &quot;KeySchema&quot;: [
            {
                &quot;AttributeName&quot;: &quot;name&quot;,
                &quot;KeyType&quot;: &quot;HASH&quot;
            },
            {
                &quot;AttributeName&quot;: &quot;age&quot;,
                &quot;KeyType&quot;: &quot;RANGE&quot;
            }
        ],
        &quot;TableStatus&quot;: &quot;ACTIVE&quot;,
        &quot;CreationDateTime&quot;: 1561194380.277,
        &quot;ProvisionedThroughput&quot;: {
            &quot;LastIncreaseDateTime&quot;: 0.0,
            &quot;LastDecreaseDateTime&quot;: 0.0,
            &quot;NumberOfDecreasesToday&quot;: 0,
            &quot;ReadCapacityUnits&quot;: 1,
            &quot;WriteCapacityUnits&quot;: 1
        },
        &quot;TableSizeBytes&quot;: 0,
        &quot;ItemCount&quot;: 0,
        &quot;TableArn&quot;: &quot;arn:aws:dynamodb:ddblocal:000000000000:table/Member&quot;,
        &quot;BillingModeSummary&quot;: {
            &quot;BillingMode&quot;: &quot;PROVISIONED&quot;,
            &quot;LastUpdateToPayPerRequestDateTime&quot;: 0.0
        }
    }
}
</code></pre>
<h3 id="데이터-쓰기"><a class="header" href="#데이터-쓰기">데이터 쓰기</a></h3>
<p>테이블의 항목을 추가한다. 테이블 생성할 때 없는 속성도 추가 가능하다.
만약 동일한 키가 존재하는 경우, 데이터를 덮어쓴다.</p>
<pre><code class="language-bash">aws dynamodb put-item --endpoint-url http://localhost:8000 \
--table-name Member  \
--item \
    '{&quot;name&quot;: {&quot;S&quot;: &quot;홍길동&quot;}, &quot;age&quot;: {&quot;N&quot;: &quot;20&quot;}, &quot;email&quot;: {&quot;S&quot;: &quot;hong@gil.dong&quot;}, &quot;phoneNumber&quot;: {&quot;S&quot;: &quot;0102224444&quot;}}'

aws dynamodb put-item --endpoint-url http://localhost:8000 \
--table-name Member  \
--item \
    '{&quot;name&quot;: {&quot;S&quot;: &quot;김갑수&quot;}, &quot;age&quot;: {&quot;N&quot;: &quot;30&quot;}, &quot;email&quot;: {&quot;S&quot;: &quot;kapsu@kim.com&quot;}, &quot;phoneNumber&quot;: {&quot;S&quot;: &quot;01012341234&quot;}}'

aws dynamodb --endpoint-url http://localhost:8000 \
&gt; put-item --table-name Member \
&gt; --item '{
            &quot;name&quot;: {
                &quot;S&quot;: &quot;홍길동&quot;
            },
            &quot;myOrder&quot;: {
                &quot;N&quot;: &quot;1&quot;
            },
            &quot;phoneNumber&quot;: {
                &quot;S&quot;: &quot;01012341234&quot;
            },
            &quot;age&quot;: {
                &quot;N&quot;: &quot;30&quot;
            },
            &quot;email&quot;: {
                &quot;S&quot;: &quot;gildong@daum.com&quot;
            }
        }'
</code></pre>
<h3 id="데이터-읽기"><a class="header" href="#데이터-읽기">데이터 읽기</a></h3>
<p>항목 단 건을 기본 키로 조회한다. 만약 파티션 키와 정렬 키 조합의 테이블이라면 두 키 모두 파라미터에 넣어줘야 한다.</p>
<pre><code class="language-bash">aws dynamodb get-item --endpoint-url http://localhost:8000 \
--table-name Member \
--key '{&quot;name&quot;: {&quot;S&quot;: &quot;홍길동&quot;}, &quot;age&quot;: {&quot;N&quot;: &quot;20&quot;}}'

{
    &quot;Item&quot;: {
        &quot;name&quot;: {
            &quot;S&quot;: &quot;홍길동&quot;
        },
        &quot;phoneNumber&quot;: {
            &quot;S&quot;: &quot;0102224444&quot;
        },
        &quot;age&quot;: {
            &quot;N&quot;: &quot;20&quot;
        },
        &quot;email&quot;: {
            &quot;S&quot;: &quot;hong@gil.dong&quot;
        }
    }
}
</code></pre>
<p>만약 강력한 읽기 일관성(Strongly Consistency Read)을 사용하려면 <code>--consistent-read</code> 옵션을 추가한다.</p>
<h3 id="데이터-수정하기"><a class="header" href="#데이터-수정하기">데이터 수정하기</a></h3>
<pre><code class="language-bash">aws dynamodb update-item --endpoint-url http://localhost:8000 \
    --table-name Member \
    --key '{&quot;name&quot;: {&quot;S&quot;: &quot;홍길동&quot;}, &quot;age&quot;: {&quot;N&quot;: &quot;20&quot;}}' \
    --update-expression &quot;SET age = :newage, email = :newemail ADD myOrder :o&quot; \
    --expression-attribute-values '{&quot;:newage&quot;:{&quot;N&quot;:&quot;21&quot;}, &quot;:newemail&quot;: {&quot;S&quot;: &quot;gildong@hong.com&quot;}, &quot;:o&quot;: {&quot;N&quot;: &quot;1&quot;} }' \
    --return-values ALL_NEW
</code></pre>
<h3 id="데이터-쿼리"><a class="header" href="#데이터-쿼리">데이터 쿼리</a></h3>
<h4 id="키-조건-표현식"><a class="header" href="#키-조건-표현식">키 조건 표현식</a></h4>
<ul>
<li>파티션 키는 등식 조건으로 지정해야 한다.</li>
<li>정렬 키는 아래의 비교연산자를 사용할 수 있다.</li>
</ul>
<table><thead><tr><th align="center">표현식</th><th align="center">의미</th></tr></thead><tbody>
<tr><td align="center">a = b</td><td align="center">속성 a가 값 b와 같을 때 true</td></tr>
<tr><td align="center">a &lt; b</td><td align="center">속성 a가 값 b보다 작을 때 true</td></tr>
<tr><td align="center">a &lt;= b</td><td align="center">속성 a가 값 b보다 작거나 같을 때 true</td></tr>
<tr><td align="center">a &gt; b</td><td align="center">속성 a가 값 b 클 때 true</td></tr>
<tr><td align="center">a &gt;= b</td><td align="center">속성 a가 값 b보다 크거나 같을 때 true</td></tr>
<tr><td align="center">a between b and c</td><td align="center">속성 a가 값 b보다 크거나 같고 c보다 작을 때 true</td></tr>
<tr><td align="center">begins_with(a, substr)</td><td align="center">속성 a가 substr로 시작할 때 true</td></tr>
</tbody></table>
<pre><code class="language-bash">aws dynamodb --endpoint-url http://localhost:8000 \
query --table-name Member \
--key-condition-expression &quot;#nm= :qname and age= :age&quot; \
--expression-attribute-names '{&quot;#nm&quot;:&quot;name&quot;}' \
--expression-attribute-values  '{&quot;:qname&quot;:{&quot;S&quot;:&quot;홍길동&quot;}, &quot;:age&quot;: {&quot;N&quot;: &quot;20&quot;}}'

aws dynamodb --endpoint-url http://localhost:8000 \
query --table-name Member \
--key-condition-expression &quot;#nm= :qname and age&gt;= :age&quot; \
--projection-expression &quot;#nm, phoneNumber&quot;  --expression-attribute-names '{&quot;#nm&quot;:&quot;name&quot;}' \
--expression-attribute-values  '{&quot;:qname&quot;:{&quot;S&quot;:&quot;홍길동&quot;}, &quot;:age&quot;: {&quot;N&quot;: &quot;20&quot;}}'
</code></pre>
<ul>
<li>위 명령에서 <code>name</code>은 DynamoDB 예약어이기 때문에 <code>#nm</code>으로 대체했다.</li>
<li>projection-expression 파라미터로 원하는 속성만 조회할 수 있다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aws-certified-developer-associate"><a class="header" href="#aws-certified-developer-associate">AWS certified developer associate</a></h1>
<h2 id="a-hrefhttpswwwudemycomcourseaws-certified-developer-associate-dva-c01udemy---ultimate-aws-certified-developer-associate-2019---newa"><a class="header" href="#a-hrefhttpswwwudemycomcourseaws-certified-developer-associate-dva-c01udemy---ultimate-aws-certified-developer-associate-2019---newa"><a href="https://www.udemy.com/course/aws-certified-developer-associate-dva-c01/">Udemy - Ultimate AWS Certified Developer Associate 2019 - NEW!</a></a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Course Introduction - AWS Certified Developer Associate, 7개의 강의, 15:38</li>
<li><input disabled="" type="checkbox" checked=""/>
Code &amp; Slides Download, 1개의 강의, 00:17</li>
<li><input disabled="" type="checkbox" checked=""/>
AWS Fundamentals: IAM + EC2, 19개의 강의, 01:33:46</li>
<li><input disabled="" type="checkbox" checked=""/>
AWS Fundamentals: ELB + ASG + EBS, 6개의 강의, 42:47</li>
<li><input disabled="" type="checkbox" checked=""/>
AWS Fundamentals: Route 53 + RDS + ElastiCache + VPC, 9개의 강의, 50:14</li>
<li><input disabled="" type="checkbox" checked=""/>
AWS Fundamentals: Amazon S3, 10개의 강의, 49:44</li>
<li><input disabled="" type="checkbox" checked=""/>
AWS CLI, SDK, IAM Roles &amp; Policies, 14개의 강의, 58:54</li>
<li><input disabled="" type="checkbox" checked=""/>
AWS Elastic Beanstalk, 8개의 강의, 56:16</li>
<li><input disabled="" type="checkbox" checked=""/>
AWS CICD: CodeCommit, CodePipeline, CodeBuild, CodeDeploy, 13개의 강의, 01:40:35</li>
<li><input disabled="" type="checkbox"/>
AWS CloudFormation, 12개의 강의, 59:37</li>
<li><input disabled="" type="checkbox"/>
AWS Monitoring &amp; Audit: CloudWatch, X-Ray and CloudTrail, 12개의 강의, 57:55</li>
<li><input disabled="" type="checkbox"/>
AWS Integration &amp; Messaging: SQS, SNS &amp; Kinesis, 15개의 강의, 01:30:08</li>
<li><input disabled="" type="checkbox"/>
AWS Serverless: Lambda, 14개의 강의, 01:19:34</li>
<li><input disabled="" type="checkbox"/>
AWS Serverless: DynamoDB, 15개의 강의, 01:18:51</li>
<li><input disabled="" type="checkbox"/>
AWS Serverless: API Gateway &amp; Cognito, 12개의 강의, 53:12</li>
<li><input disabled="" type="checkbox"/>
AWS Serverless: SAM - Serverless Application Model, 9개의 강의, 38:46</li>
<li><input disabled="" type="checkbox"/>
ECS, ECR &amp; Fargate - Docker in AWS, 13개의 강의, 01:23:01</li>
<li><input disabled="" type="checkbox"/>
AWS Security &amp; Encryption: KMS, Encryption SDK, SSM Parameter Store, IAM &amp; STS, 11개의 강의, 01:10:01</li>
<li><input disabled="" type="checkbox"/>
AWS Other Services, 7개의 강의, 19:14</li>
<li><input disabled="" type="checkbox"/>
AWS Final Cleanup, 2개의 강의, 03:19</li>
<li><input disabled="" type="checkbox"/>
Preparing for the Exam - AWS Certified Developer Associate, 5개의 강의, 21:52</li>
<li><input disabled="" type="checkbox"/>
Congratulations - AWS Certified Developer Associate, 2개의 강의, 05:12</li>
</ul>
<h2 id="백서-목록"><a class="header" href="#백서-목록">백서 목록</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/whitepapers/">AWS 백서</a>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/blogs/korea/ko-documentation/">AWS 한국어 설명서 목록</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://d1.awsstatic.com/International/ko_KR/whitepapers/aws-overview.pdf">Amazon Web Services 개요</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf">Architecting for the Cloud</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://d1.awsstatic.com/whitepapers/Security/AWS_Security_Best_Practices.pdf">AWS 보안 모범 사례</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://d1.awsstatic.com/whitepapers/Storage/AWS%20Storage%20Services%20Whitepaper-v9.pdf">AWS 스토리지 서비스 개요</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://d1.awsstatic.com/International/ko_KR/whitepapers/Well-Architected%20Framework%20Whitepaper.pdf">AWS Well-Architected Framework</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://d1.awsstatic.com/whitepapers/serverless-architectures-with-aws-lambda.pdf">AWS Lambda를 사용한 서버리스 아키텍처</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://d1.awsstatic.com/whitepapers/microservices-on-aws.pdf">Microservices on AWS</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://d0.awsstatic.com/whitepapers/Security/AWS_Security_Best_Practices.pdf">보안 모범 사례</a>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://d0.awsstatic.com/International/ko_KR/whitepapers/AWS_Security_Best_Practices_11052013.pdf">보안 모범사례(한글,2013년 11월)</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://d0.awsstatic.com/whitepapers/architecture/AWS_Well-Architected_Framework.pdf">Well-Architected Framework</a></li>
</ul>
<h2 id="학습목록"><a class="header" href="#학습목록">학습목록</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html">EC2</a> : AWS의 핵심서비스인 만큼 EC2에 대한 내용은 무척 비중있게 다루어집니다.
<ul>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ec2-instances-and-amis.html">인스턴스 및 AMI</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/instance-types.html">인스턴스 유형</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/instance-purchasing-options.html">인스턴스 구입 옵션</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/using-regions-availability-zones.html">리전 및 가용 영역</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/RootDeviceStorage.html">Amazon EC2 루트 디바이스 볼륨</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/monitoring_ec2.html">Amazon EC2 모니터링</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/EC2_Network_and_Security.html">네트워크 및 보안</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/Storage.html">스토리지</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/InstanceStorage.html">Amazon EC2 인스턴스 스토어</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/autoscaling/latest/userguide/WhatIsAutoScaling.html">Auto Scaling 설명서</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/using-eni.html">탄력적 네트워크 인터페이스(ENI:Elastic Network Interface)</a>
[ ] - <a href="https://aws.amazon.com/ec2/faqs/">EIP</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">인스턴스 메타데이터 및 사용자 데이터</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/vpc/faqs/">VPC</a>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AmazonVPC/latest/UserGuide/VPC_Introduction.html">VPC 사용자 가이드</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AmazonVPC/latest/PeeringGuide/Welcome.html">VPC 피어링이란?</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://d0.awsstatic.com/International/ko_KR/whitepapers/Extend%20your%20IT%20infrastructure%20with%20Amaon%20VPC.pdf">Amazon Virtual Private Cloud 를 이용한 IT 인프라의 확장</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://aws.amazon.com/ko/elasticloadbalancing/faqs/">ELB</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/lambda/faqs/">AWS Lambda</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/step-functions/faqs/">AWS Step Functions</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/dynamodb/faqs/">Amazon DynamoDB</a>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/SQLtoNoSQL.html">SQL에서 NoSQL로</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/HowItWorks.ProvisionedThroughput.html">프로비저닝된 처리량</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/QueryAndScan.html">DynamoDB의 쿼리 및 스캔 작업</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html">파티션 및 데이터 배포</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/SecondaryIndexes.html">DynamoDB에서 보조 인덱스를 사용하여 데이터 액세스 향상</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/WorkingWithTables.html">DynamoDB의 테이블 작업</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/WorkingWithItems.html">DynamoDB에서의 항목 작업</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/Programming.html">DynamoDB 및 AWS SDK를 사용한 프로그래밍</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/DynamoDBLocal.html">컴퓨터에서 DynamoDB 실행</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/Streams.html">DynamoDB Streams를 사용하여 Table Activity 캡처하기</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/elasticbeanstalk/faqs/">Elastic Beanstalk</a>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/gettingstarted/latest/deploy/overview.html">Elastic Beanstalk를 이용한 웹 앱 배포</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/EBSVolumes.html">EBS</a>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/ebs/faqs/">EBS FAQ</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">EBS 볼륨 유형</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/EBSSnapshots.html">EBS 스냅샷</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/EBSEncryption.html">EBS 암호화</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/EBSPerformance.html">Linux 인스턴스의 Amazon EBS 볼륨 성능</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/efs/faq/">EFS</a></li>
<li><input disabled="" type="checkbox"/>
S3
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/s3/faqs/">Amazon S3 FAQ</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/s3-access-control.html">Amazon S3 리소스에 대한 액세스 권한 관리</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/s3/storage-classes/">S3 스토리지 클래스</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/s3/reduced-redundancy/">S3 Reduced Redundancy Storage</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/cloudformation/faqs/">CloudFormation</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/opsworks/faqs/">OpsWorks</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/sns/faqs/">Amazon SNS</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/sqs/faqs/">Amazon SQS</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/storagegateway/faqs/">AWS Storage Gateway</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/kinesis/streams/faqs/">Amazon Kinesis</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/emr/faqs/">Amazon EMR</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/directconnect/">AWS Direct Connect</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/documentation/importexport/?nc1=h_ls">AWS Import/Export</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/directoryservice/faqs/">AWS Directory Service</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/route53/details/">Amazon Route53</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/Introduction.html">Amazon CloudFront</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/ecs/faqs/">Amazon ECS</a>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/ecr/faqs/">AWS ECR</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/fargate/faqs/">AWS Fargate</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/eks/faqs/">Amazon EKS</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/kms/faqs/">AWS KMS</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://aws.amazon.com/ko/amazon-mq/faqs/">Amazon MQ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>원문: <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/overview.html#overview">Spring Framework 5.2.3 overview</a></p>
</blockquote>
<h1 id="spring-framework-overview"><a class="header" href="#spring-framework-overview">Spring Framework Overview</a></h1>
<p>Version <code>5.2.3.RELEASE</code></p>
<blockquote>
<p>원문: <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/overview.html">Spring Framework 5.2.3 overview</a></p>
</blockquote>
<p>스프링은 자바 엔터프라이즈 애플리케이션을 쉽게 만들수 있게 한다. 스프링은 엔터프라이즈 환경에서 당신이 자바 언어를 수용하기 위한 모든 것을 제공한다. 그리고 JVM 언어인 Groovy와 Kotlin도 지원한다. 그리고 애플리케이션의 요구사항에 맞는 여러 종류의 아키텍쳐를 만들 수 있는 유연성을 가지고 있다. 스프링 프레임워크 5.1 버전부터 스프링은 JDK 8 이상의 버전이 필요하고 JDK 11 LTS 버전에 대해서도 out-of-the-box support(별도 설정 필요 없는 지원)를 제공합니다. Java SE 8 update 60 버전은 Java 8 버전에 대한 최소 요구 버전으로 지원되나 최신 패치버전도 일반적으로 사용할 수 있습니다.</p>
<p>스프링은 다양한 애플리케이션 시나리오를 지원합니다. 대규모 엔터프라이즈 상황에서 애플리케이션은 종종 오랜 시간 유지되어야 하고 개발자의 관리범위를 넘어서는 업그레이드 주기를 가진 애플리케이션 서버를 실행해야 할 때가 있습니다. 또다른 경우는 클라우드 환경에서 임베디드 서버를 내장한 single jar를 실행해야 하는 경우입니다. 그리고 서버가 필요 없는 배치나 워크로드 통합을 위한 standalone 애플리케이션의 경우가 있습니다.</p>
<p>스프링은 오픈소스이다. 다양한 실제 사용 사례에 기반한 지속적인 피드백을 제공하는 크고 활성화된 커뮤니티가 있다. 이는 스프링을 오랜시간동안 성공적으로 발전시켜나가는데 도움을 주고 있다.</p>
<h2 id="1-spring의-의미"><a class="header" href="#1-spring의-의미">1. &quot;Spring&quot;의 의미</a></h2>
<p>&quot;Spring&quot;이라는 용어는 다양한 상황에서 다양한 의미를 가지고 있다. 이 것은 Spring Framework 자체를 의미할 수 있다. 시간이  흐르면서, 다른 스프링 프로젝트들이 스프링 프레임워크의 위에 생겼다. 오늘날 자주 사용하는, 사람들이 말하는 &quot;Spring&quot;은 스프링 프로젝트의 전체를 의미하기도 한다. 이 문서는 스프링 프레임워크에 초점을 맞추고 있다.</p>
<p>스프링 프레임워크는 모듈들로 분리되어 있다. 애플리케이션은 필요한 모듈을 선택할 수 있다. 핵심은 configuration model과 dependency injection 메카니즘이 포함된 코어 컨테이너의 모듈이다. 이 외에도 스프링 프레임워크는 여러 애플리케이션 아키텍쳐, 메시징, 데이터 트랜잭션과 영속성, 웹 등에 대한 기초적인 지원을 제공합니다. 서블릿 기반의 Spring MVC 웹 프레임워크와 Spring WebFlux reactive 웹 프레임워크를 함께 지원합니다.</p>
<blockquote>
<p>모듈에 대한 메모: 스프링의 프레임워크 jar 파일은 JDK 9의 모듈화(Jigsaw) 배포를 허용합니다. Jigsaw 활성화 애플리케이션에서 사용하기 위해 스프링 프레임워크 5 는 jar artifact 이름(e.g. &quot;spring-core&quot;, &quot;spring-context&quot;)에서 독립된 안정적인 언어 레벨의 모듈 이름을 정의하는 &quot;Automatic Module-Name&quot; 매니페스트 항목(e.g. &quot;spring.core&quot;, &quot;spring.context&quot;, ...)이 제공됩니다.  물론 스프링 프레임워크 jar는 JDK 8과 JDK 9+에서 동일하게 잘 동작합니다.</p>
</blockquote>
<h2 id="2-스프링과-스프링-프레임워크의-역사"><a class="header" href="#2-스프링과-스프링-프레임워크의-역사">2. 스프링과 스프링 프레임워크의 역사</a></h2>
<p>스프링은 2003년에 초기 <a href="https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition">J2EE</a> 명세의 복잡함에 대한 대안(response)로 시작되었습니다. 일부는 Java EE와 스프링이 경쟁 관계에 있다고 생각하지만, 사실 스프링은 Java EE와 상호보완적인 관계에 있습니다. 스프링 프로그래밍 모델은 Java EE 플랫폼 명세를 포함하지 않습니다. 대신 EE 명세로부터 필요한 명세를 선택적으로 통합합니다. 아래는 그 예입니다.</p>
<ul>
<li>Servlet API (JSR 340)</li>
<li>WebSocket API (JSR 356)</li>
<li>Concurrency Utilities (JSR 236)</li>
<li>JSON Binding API (JSR 367)</li>
<li>Bean Validation (JSR 303)</li>
<li>JPA (JSR 338)</li>
<li>JMS (JSR 914)</li>
<li>트랜잭션 조정을 위한 JTA/JCA 구성 (필요하다면)</li>
</ul>
<p>스프링 프레임워크는 Dependency Injection(JSR 330) 명세와 공통 애너테이션(JSR 250) 명세도 지원한다. 애플리케이션 개발자는 스프링 프레임워크가 제공하는 특정 메카니즘들(e.g. XML 방식의 빈 등록) 대신 사용할 수 있다.</p>
<p>스프링 프레임워크 5.0 기준으로 스프링은 Java EE 7 레벨 (e.g. 서블릿 3.1+, JPA 2.1+)을 최소조건으로 요구함과 동시에 Java EE 8 레벨 (e.g. 서블릿 4.0, JSON 바인딩 API)과 즉시 통합을 지원하고 있다. 이는 스프링이 Tomcat 8, 9, WebSphere 9, JBoss EAP 7 과의 완전 호환을 유지하게 한다.</p>
<p>시간이 지남에 따라 애플리케이션 개발을 위한 Java EE의 역할을 진화했다. 초창기의 Java EE와 스프링 애플리케이션들은 애플리케이션 서버에 배포되었다. 오늘날엔 스프링 부트의 도움으로 클라우드 친화적인 devops 환경에서 서블릿 컨테이너가 내장된 애플리케이션을 생성할 수 있다. 스프링 프레임워크 5 기준으로 웹플럭스 애플리케이션은 서블릿 API를 직접적으로 사용하지 않고 서블릿 컨테이너가 아닌 (Netty와 같은) 서버에서 동작한다.</p>
<p>스프링은 계속해서 혁신하고 발전하고 있다. 스프링 프레임워크를 넘어, 스프링 부트, 스프링 시큐리티, 스프링 데이터, 스프링 클라우드, 스프링 배치와 같은 다른 프로젝트들이 있다. 각 프로젝트는 고유의 소스코드 저장소, 이슈 트래커, 릴리즈 주기가 있다는걸 명심해라. <a href="https://spring.io/projects">spring.io/projects</a>에서 스프링 프로젝트의 전체 리스트를 확인할 수 있다.</p>
<h2 id="3-디자인-철학"><a class="header" href="#3-디자인-철학">3. 디자인 철학</a></h2>
<p>프레임워크에 대해 배울 때, 그것이 하는 일 뿐만이 아니라 그에 따르는 원칙을 아는 것도 중요하다. 아래는 스프링 프레임워크의 가이드 원칙이다:</p>
<ul>
<li>모든 레벨에서의 선택을 제공한다. 스프링은 당신이 설계에 대한 결정을 가능한 늦게 미룰 수 있게 합니다. 한 예로, 코드의 변경 없이 설정만으로 영속성 제공자를 전환할 수 있다. 그외 많은 인프라스트럭쳐와 써드파티 API와의 통합에서도 마찬가지이다.</li>
<li>다양한 관점을 수용한다. 스프링은 유연성을 포용하고 문제 해결에 대한 의견을 고집하지 않는다. 다양한 관점으로 애플리케이션 요구사항에 대한 해결방법을 지원한다.</li>
<li>이전 버전과의 호환을 완벽하게 지원한다. 스프링의 발전은 매우 조심스럽게 관리되어서 버전 간의 변경 충돌이 거의 없었다. 스프링은 신중하게 선택한 JDK 버전과 써드파티 라이브러리를 지원하며 스프링에 의존하는 라이브러리와 애플리케이션들의 유지보수를 용이하게 한다.</li>
<li>API 디자인에 신경쓴다. 스프링 팀은 직관적이고 오랜 시간, 다양한 버전에 걸쳐 사용할 수 있는 API를 설계하는데 많은 시간과 노력을 투입한다.</li>
<li>높은 기준의 코드 퀄리티를 가지고 있다. 스프링 프레임워크는 의미있고 정확한 javadoc에 중점을 두고 있다. 이는 패키지 간의 순환 의존관계가 없는 클린 코드 체계를 주장하는 매우 소수의 프로젝트들 중 하나이다.</li>
</ul>
<h2 id="4-피드백과-기여"><a class="header" href="#4-피드백과-기여">4. 피드백과 기여</a></h2>
<p>어떻게 해야하는지 질문하거나 이슈 디버깅/진단을 위해 StackOverFlow와 사용을 위한 태그들이 나열된 <a href="https://spring.io%EB%90%9Cquestions">질문 페이지(역자 주: 깨져있음)</a>를 이용하는 것을 추천한다. 만약 스프링 프레임워크에 확실한 문제가 있거나 새로운 기능을 제안하고 싶을 땐 <a href="https://github.com/spring-projects/spring-framework/issues">Github Issues</a>를 사용해라.</p>
<p>만약 버그 수정이나 솔루션을 염두하고 있다면, Github로 PR을 보낼 수 있다. 그러나 대부분의 사소한 이슈는, 미래에 추가될 기능을 위해 기록을 남기거나 토론중인 이슈트래커에 티켓이 채워져 있다는 것을 명심해라.</p>
<p><a href="https://github.com/spring-projects/spring-framework/blob/master/CONTRIBUTING.md">기여</a>를 위한 가이드라인에 대해 더 알고싶다면, 탑 레벨의 프로젝트 페이지를 살펴보면 된다.</p>
<h2 id="5-시작하기"><a class="header" href="#5-시작하기">5. 시작하기</a></h2>
<p>만약 빠르게 스프링을 사용하고 싶다면, 스프링 부트 기반의 프레임워크를 고려하고 있을 것이다. 스프링 부트는 빠르고 자동 설정이 포함된 프로덕션에 바로 적용 가능한 스프링 애플리케이션을 제공한다. 이는 스프링 프레임워크에 기반하고 설정을 직접 하기보다 이미 구성된 컨벤션을 선호한다. 그리고 스프링 부트는 가능한 빨리 실행할 수 있도록 설계되어 있다.</p>
<p><a href="books/spring/start.spring.io">start.spring.io</a>나 <a href="https://spring.io/guides">&quot;시작하기&quot; 가이드</a>를 통해서 기본적인 프로젝트를 생성할 수 있다. 이런 가이드는 실제 업무에 집중되어 있기 때문에 소화하기 쉬울 뿐 아니라 대부분의 가이드가 스프링 부트 기반이다. 그리고 스프링 포트폴리오의 다른 프로젝트들 역시 특정 문제를 해결하기 위한 방안으로써 포함되어 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>원문: <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#spring-core">Spring Framework 5.2.3 Core</a></p>
</blockquote>
<h1 id="core-technologies"><a class="header" href="#core-technologies">Core technologies</a></h1>
<p>Version <code>5.2.3.RELEASE</code></p>
<p>이 장은 스프링 프레임워크에 필수적인 모든 기술에 대해 다루고 있다.</p>
<p>이 중에서 가장 중요한 것은 스프링 프레임워크의 제어 역전(IoC, Inversion of Control) 컨테이너이다. 스프링 프레임워크 IoC 컨테이너의 철저하게 다룬 후 스프링 관점 지향 프로그래밍(AOP) 기술에 대해 포괄적으로 다루고 있다. 스프링 프레임워크는 고유의 AOP 프레임워크를 가지고 있고 이는 이해하기 슆고 Java Enterprise AOP 요건의 80%에 대해 참조하고 있다.</p>
<p>스프링과 AspectJ의 통합에 대한 범위 역시 제공하고 있다.</p>
<h2 id="1-ioc-컨테이너"><a class="header" href="#1-ioc-컨테이너">1. IoC 컨테이너</a></h2>
<p>이 챕터는 스프링의 제어 역전 (IoC, Inversion of Control) 컨테이너에 대해 다룬다.</p>
<h3 id="11-스프링-ioc-컨테이너와-빈-도입부"><a class="header" href="#11-스프링-ioc-컨테이너와-빈-도입부">1.1. 스프링 IoC 컨테이너와 빈 도입부</a></h3>
<p>이 챕터는 스프링 프레임워크에서 제어 역전을 적용하는 원리에 대해 다룬다. IoC는 의존성 주입(DI, Dependency Injection)이라고도 한다. 이는 오로지 생성자 인자, 팩토리 메서드에 대한 인자 혹은 팩토리 메서드로부터 반환거나 (생성자에 의해) 생성된 객체 인스턴스에 설정된 프로퍼티에 대한 의존성에 대한 프로세스이다. 컨테이너는 빈을 생성할 때 의존성을 주입한다. 이 프로세스는 근본적으로 빈 스스로 인스턴스 생성 과정이나 그들의 의존성을 직접 클래스를 생성해서 의존성을 제어하거나 서비스 로케이터 패턴과 같은 방식을 통해 생성되는 빈과 정 반대의 방식이다. (그래서 이름이 제어의 역전이다.)</p>
<p><code>org.springframework.beans</code>, <code>org.springframework.context</code> 패키지는 스프링 프레임워크의 IoC 컨테이너의 기반이다. <code>BeanFactory</code> 인터페이슨느 객체의 타입을 관리하는 방식에 대해 고급 구성 방식을 제공한다. <code>ApplicationContext</code>는 <code>BeanFactory</code>의 하위 인터페이스이고 아래와 같은 추가 기능을 가지고 있다.:</p>
<ul>
<li>스프링 AOP 기능과의 통합</li>
<li>(국제화 같은) 메시지 리소스 핸들링</li>
<li>이벤트 발행</li>
<li>웹 애플리케이션을 위한 <code>WebApplicationContext</code>와 같은 특정 애플리케이션 레이어의 컨텍스트</li>
</ul>
<p>단순히 <code>BeanFactory</code>는 기본적인 기능과 프레임워크 구성을 제공하고, <code>ApplicationContext</code>는 특정 엔터프라이즈 기능을 추가적으로 제공한다. <code>ApplicationContext</code>는 <code>BeanFactory</code>의 완전한 수퍼셋이고 이 챕터는 스프링 IoC 컨테이너를 다루는데 대부분을 사용한다. <code>BeanFactory</code>에 대한 더 많은 정보는 <a href="books/spring/core-01-ioc-container.html#1.16.-BeanFactory">1.16. BeanFactory</a> 부분을 살펴보라.</p>
<p>스프링에서 애플리케이션의 기간을 구성하고 스프링 IoC 컨테이너가 관리하는 객체들을 빈(beans)이라고 부른다. 빈은 스프링 IoC 컨테이너에 의해 관리되고 인스턴스화하고 결합되는 객체이다. 또는 애플리케이션의 수많은 객체들 중 하나일 수도 있다. 그리고 객체들 간의 의존성에서 빈은 컨테이너에 의해 설정 메타데이터를 반영한다.</p>
<h3 id="12-컨테이너-오버뷰"><a class="header" href="#12-컨테이너-오버뷰">1.2. 컨테이너 오버뷰</a></h3>
<p><code>org.springframework.context.ApplicationContext</code> 인터페이스는 스프링 IoC 컨테이너를 대표하고 빈 인스턴스화, 구성, 결합에 대한 책임을 가지고 있다. 컨테이너는 설정 메타데이터(configuration metadata)를 읽어서 어떤 빈이 인스턴스화하고 구성하고 결합해야하는지에 대한 지시사항을 얻는다. 설정 메타데이터는 XML, 자바 어노테이션 혹은 자바 코드로 표현한다. 이는 객체들 사이의 수많은 상호의존성과 애플리케이션을 구성하는 객체들을 표현한다.</p>
<p>수많은 <code>ApplicationContext</code> 인터페이스의 구현체들은 스프링에 공급된다. Stand-alone 애플리케이션에서 <code>ClassPathXmlApplicationContext</code> 나 <code>FileSystemXmlApplicationContext</code>의 인스턴스를 생성하는 일은 빈번하다. 설정 메타데이터를 정의하기 위해 전통적인 포맷인 XML을 사용하는 것 대신, XML 설정을 최소화하면서 추가 메타데이터 형식에 대한 지원을 선언적으로 활성화해서 자바 어노테이션이나 코드를 메타데이터 포맷으로 사용할 수 있다.</p>
<p>대부분의 애플리케이션 시나리오에서, 특정 유저 코드는 스프링 IoC 컨테이너의 하나 이상의 인스턴스를 인스턴스화하는데 필요조건이 아니다. 한 예로, 웹 애플리케이션 시나리오에서, <code>web.xml</code> 의 웹 디스크립터 XML 보일러 플레이트 코드로 8 줄 정도의 라인이면 충분하다 (<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-create">웹 애플리케이션을 위한 편리한 애플리케이션 컨텍스트 인스턴스화</a> 부분을 참고하라). 만약 Spring Tool Suite을 사용한다면, 몇 번의 마우스 클릭과 키보드 클릭으로 보일러플레이트 설정코드 생성할 수 있다.</p>
<p>다음은 스프링이 어떻게 동작하는지에 대한 고수준의 다이어그램이다. 애플리케이션 클래스들은 설정 메타데이터로 결합되어 있기 때문에 <code>ApplicationContext</code>가 생성되어 초기화된 후 애플리케이션이나 실행 시스템이 완전히 구성되는 것이다.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="243px" viewBox="-0.5 -0.5 243 228" content="&lt;mxfile host=&quot;www.draw.io&quot; modified=&quot;2020-02-19T04:26:29.549Z&quot; agent=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot; etag=&quot;QpG8GJbHcqB8LZsMrUih&quot; version=&quot;12.7.1&quot; type=&quot;google&quot;&gt;&lt;diagram id=&quot;2QBm65H3RxrJj0wob88_&quot; name=&quot;Page-1&quot;&gt;1Zdbb5swFMc/jaXtYROXhJhHIOku6tSqlXp5dMAFTw6OjNOEffodg7kF0nabtq4vkc/fxzY+55dzALnR5vBJkm32TSSUI8dKDshdIsdxPAy/WihrYbGwayGVLKmlnnDNflAjWkbdsYQWA0clBFdsOxRjkec0VgONSCn2Q7cHwYenbklKR8J1TPhYvWWJymoVO4tO/0xZmjUn255fz2xI42xuUmQkEfue5K6QG0khVD3aHCLKdeyauNTrzk7Mtg8maa5esuDqS7zelezKC25us7ub+f5xd/7BXOOR8J25sHlYVTYRSKXYbY0blYoepuJO1o27NX4uu70tUELFhipZgkuzETZLyiaExt538bZ9o2W9WLdnEZPjtN27CwMMTCR+ISqzcVRWIQp9hGdoFaHAQxhrBYfVIEI4QAEsstAqQKGF/KUWQweFs3eXF18vivejqNIEMDOmkCoTqcgJX3VqCGHPE6of0wKr8zkXYguiDeJ3qlRp/jNkpwRImdpwM0sPTN3p5R/nxro3m+nx8tA3ysbIk0D/a8DMRU5r5Yzp8FXzhSJSNR4xJ0XB4kY2bvpowlmaw5jTB0hWWN9eX/kku0/RWYidjOkTfs40YJJyotjj8NApWMzSS8HgcTow3SO+4JIpVcbrCLH22N+nzpugDnCaoyCqGJuh0K4YC1HgIx9QXCLsIlwpeKnBAzdgL6ynZlp5Te761LUMTnP3Qq6ew5OTNeWXomCKCc1fDHxRCRO6cjGo6udHDkrfqcV15B6YibVQSmzeHsmmpPr/FmRnAuSmRgKYQK6uo0DxAuGaaCiWYOIK2znCUQ/kUDtjPAJ5iOk+Y4peb0kV3D28iQyRPNm+Xpa4k71rMWxd3kTnciY6l/e3Gpc7HXnHlBA/0JVDp2CO/KqDBVaVlFBnx686mONxXbLXEkZpVbz1wrb1WdUAdlhVSbEmShTsBsD5kcksNEk/GgAAKdazbyCh9qtndD7dFAbvGE2gXSOaTvG/vHHYT1Z+yJYse4u0ed+f65ZV1mTHMM2g3y6O3ma6ntJ1jNd6U4FPmKoAP/dH/oM+cII5MLsPjrrcd19t7uon&lt;/diagram&gt;&lt;/mxfile&gt;" onclick="(function(svg){var src=window.event.target||window.event.srcElement;while (src!=null&amp;&amp;src.nodeName.toLowerCase()!='a'){src=src.parentNode;}if(src==null){if(svg.wnd!=null&amp;&amp;!svg.wnd.closed){svg.wnd.focus();}else{var r=function(evt){if(evt.data=='ready'&amp;&amp;evt.source==svg.wnd){svg.wnd.postMessage(decodeURIComponent(svg.getAttribute('content')),'*');window.removeEventListener('message',r);}};window.addEventListener('message',r);svg.wnd=window.open('https://www.draw.io/?client=1&amp;lightbox=1&amp;edit=_blank');}}})(this);" style="cursor:pointer;max-width:100%;max-height:228px;"><defs/><g><path d="M 137 60.63 L 137 7" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 137 65.88 L 133.5 58.88 L 137 60.63 L 140.5 58.88 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 37px; margin-left: 139px;"><div style="box-sizing: border-box; font-size: 0; text-align: left; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; background-color: #ffffff; white-space: nowrap; ">비즈니스 객체(POJOs)</div></div></div></foreignObject><text x="139" y="40" fill="#000000" font-family="Helvetica" font-size="11px">비즈니스 객체(POJOs)</text></switch></g><path d="M 70.63 97 L 7 97" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 75.88 97 L 68.88 100.5 L 70.63 97 L 68.88 93.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe flex-end; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 94px; margin-left: 42px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; background-color: #ffffff; white-space: nowrap; ">설정 메타데이터</div></div></div></foreignObject><text x="42" y="94" fill="#000000" font-family="Helvetica" font-size="11px" text-anchor="middle">설정 메타데이터</text></switch></g><rect x="77" y="67" width="120" height="60" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 97px; margin-left: 78px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">스프링 컨테이너</div></div></div></foreignObject><text x="137" y="101" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">스프링 컨테이너</text></switch></g><rect x="77" y="167" width="120" height="60" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 197px; margin-left: 78px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">사용하려는 <br />완전히 구성된 시스템</div></div></div></foreignObject><text x="137" y="201" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">사용하려는...</text></switch></g><path d="M 137 127 L 137 160.63" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 137 165.88 L 133.5 158.88 L 137 160.63 L 140.5 158.88 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 147px; margin-left: 139px;"><div style="box-sizing: border-box; font-size: 0; text-align: left; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; background-color: #ffffff; white-space: nowrap; ">객체 생성</div></div></div></foreignObject><text x="139" y="150" fill="#000000" font-family="Helvetica" font-size="11px">객체 생성</text></switch></g></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://desk.draw.io/support/solutions/articles/16000042487" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Viewer does not support full SVG 1.1</text></a></switch></svg>
<figcaption>Figure 1. 스프링 IoC 컨테이너</figcaption>
</figure>
<h4 id="121-설정-메타데이터"><a class="header" href="#121-설정-메타데이터">1.2.1. 설정 메타데이터</a></h4>
<p>앞선 다이어그램에서 봤듯이, 스프링 IoC 컨테이너는 설정 메타데이터를 사용한다. 이 설정 메타데이터는 애플리케이션 개발자가 스프링 컨테이너에게 애플리케이션의 객체를 인스턴스화, 구성, 결합을 지시하는 방법을 나타낸다.</p>
<blockquote>
<p>XML 기반의 메타데이터는 설정 메타데이터의 유일한 형식이 아니다. 스프링 IoC 컨테이너는 스스로 어떤 설정 메타데이터 형식으로 작성되었는지와 디커플링 관계에 있다. 요즘엔 많은 개발자가 <a href="books/spring/core-01-ioc-container.html#1.12.-Java-%EA%B8%B0%EB%B0%98-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B5%AC%EC%84%B1">Java 기반 구성</a>을 선택하고 있다.</p>
</blockquote>
<p>스프링 컨테이너의 다른 메타데이터 형식에 대한 내용은 아래를 살펴봐라.:</p>
<ul>
<li><a href="books/spring/core-01-ioc-container.html#1.9.-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B0%98-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B5%AC%EC%84%B1">어노테이션 기반 구성</a>: 스프링 2.5 버전부터 어노테이션 기반 메타데이터 구성을 지원한다.</li>
<li><a href="books/spring/1.12.-Java-%EA%B8%B0%EB%B0%98-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B5%AC%EC%84%B1">Java 기반 컨테이너 구성</a>: 스프링 3.0 버전부터, 스프링 JavaConfig 프로젝트가 제공하는 많은 기능들이 Core 스프링 프레임워크의 일부분으로 포함되기 시작했다. 그래서 XML 파일 대신 Java를 이용해서 애플리케이션 클래스에 대한 추가적인 빈을 정의할 수 있다. 이런 새로운 기능들을 사용하려면, <code>@Configuration</code>, <code>@Bean</code>, <code>@Import</code> 그리고 <code>@DependsOn</code> 어노테이션을 참고해라.</li>
</ul>
<p>스프링 구성은 컨테이너가 관리하는 최소 하나 이상의 빈 설정으로 이루어져 있다. XML 기반 설정 메타데이터는 이런 빈들을 <code>&lt;beans/&gt;</code> 태그로 이루어져 있었다. Java 구성은 <code>@Configuration</code> 어노테이션이 등록된 클래스 안에 <code>@Bean</code> 어노테이션이 등록된 메서드를 사용한다.</p>
<p>이런 빈 정의는 애플리케이션을 형성하는 실제 객체들과 일치한다. 일반적으로, 서비스 레이어 객체와 데이터 엑세스 객체(DAO) 등을 정의할 것이다. 일반적으로 컨테이너에서 세밀한 도메인 객체를 구성하지 않는다. 왜냐하면 일반적으로 도메인 객체를 생성하고 로드하는 것은 비즈니스 로직과 DAO 객체의 책임이기 때문이다. 그러나 스프링과 AspectJ의 통합으로 IoC 컨테이너의 제어범위 밖에서 생성한 객체를 구성할 수 있다. <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-atconfigurable">스프링에서 AspectJ를 사용해서 도메인 객체 의존성 주입하기</a> 부분을 참고해라.</p>
<p>다음 예제는 XML 기반의 설정 메타데이터의 기본 구조를 나타낸다.:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  (1) (2)
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>(1) <code>id</code> 속성은 개별 빈 정의 식별자이다.</li>
<li>(2) <code>class</code> 속성은 빈의 타입을 정의하고, 적합한 클래스 명이어야 한다.</li>
</ul>
<p><code>id</code> 속성의 값으로 협력하는 객체들을 참조한다. 협력하는 객체들을 참조하기 위한 XML 설정은 이 예제엔 없다. <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies">의존성</a> 부분에서 더 많은 정보를 확인할 수 있다.</p>
<h4 id="122-컨테이너-인스턴스화하기"><a class="header" href="#122-컨테이너-인스턴스화하기">1.2.2. 컨테이너 인스턴스화하기</a></h4>
<p><code>ApplicationContext</code> 생성자에게 제공하는 경로는 컨테이너가 다양한 외부 리소스로부터 로드한, 로컬 파일 시스템의 자바 <code>CLASSPATH</code>와 같은, 설정 메타데이터를 로드한 리소스 문자열이다.</p>
<pre><code class="language-java">// Java
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
</code></pre>
<pre><code class="language-kotlin">// Kotlin
val context = ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;)
</code></pre>
<blockquote>
<p>스프링 IoC 컨테이너에 대해 배운 후에 스프링 (<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#resources">Resource</a>에 기술된) <code>Resource</code> 추상화에 대해 더 알고싶어 할지도 모르겠다. 이는 URI 문법으로 정의된 위치에 대한 인풋스트림을 읽기 위한 편리한 방식을 제공한다. <code>Resource</code> 경로는 애플리케이션 컨텍스트를 생성하는데 사용되고, 자세한 내용은 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#resources-app-ctx">Application Contexts and Resource Paths</a>에 기술되어 있다.</p>
</blockquote>
<p>다음 예제는 서비스 레이어 객체들에 대한 구성 파일이다.:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;!-- services --&gt;

   &lt;bean id=&quot;petStore&quot; class=&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt;
       &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;
       &lt;property name=&quot;itemDao&quot; ref=&quot;itemDao&quot;/&gt;
       &lt;!-- additional collaborators and configuration for this bean go here --&gt;
   &lt;/bean&gt;

   &lt;!-- more bean definitions for services go here --&gt;

&lt;/beans&gt;
</code></pre>
<p>다음 예제는 데이터 엑세스 객체(DAO)들에 대한 구성 파일이다.:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;accountDao&quot;
        class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;itemDao&quot; class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for data access objects go here --&gt;

&lt;/beans&gt;
</code></pre>
<p>앞선 예제에서, 서비스 레이어는 <code>PetStoreServiceImpl</code> 클래스와 두 가지 데이터 엑세스 객체 - JPA ORM 표준에 기반한 -  <code>JpaAccountDao</code>와 <code>JpaItemDao</code>로 구성되어 있다. <code>property name</code> 요소는 자바 빈 속성의 이름을 참조한다. 그리고 <code>ref</code> 요소는 다른 빈 정의의 이름을 참조한다. <code>id</code>와 <code>ref</code> 사이의 연결은 협력하는 객체들 사이의 의존성을 표현한다. 더 자세한 내용은 <a href="books/spring/core-01-ioc-container.html#1.4.-%EC%9D%98%EC%A1%B4%EC%84%B1">의존성</a> 부분을 살펴봐라.</p>
<h5 id="xml-기반의-설정-메타데이터-구성하기"><a class="header" href="#xml-기반의-설정-메타데이터-구성하기">XML 기반의 설정 메타데이터 구성하기</a></h5>
<p>복수의 XML 파일에 걸친 빈 정의는 유용하다. 개별 XML 설정 파일은 때때로 애플리케이션 아키텍쳐의 논리적 레이어나 모듈을 대표하기도 한다.</p>
<p>애플리케이션 컨텍스트 생성자를 사용해서 모든 XML 파일들로부터 빈 정의를 읽어올 수 있다. 이 생성자는 복수의 <code>Resource</code> 위치를 획득한다. 대안으로 하나 이상의 <code>&lt;import/&gt;</code> 요소로 다른 파일들의 빈 정의를 로드할 수 잇다. 아래 예제는 어떻게 표현하는지 보여준다.:</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;import resource=&quot;services.xml&quot;/&gt;
    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;
    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;

    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;
    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<blockquote>
<p>부모 디렉토리에 있는 파일을 참조하기 위해 상대 경로 &quot;../&quot; 를 사용하는 것은 가능하지만, 추천하지 않는다. 그렇게 하면 현재 애플리케이션 외부에 있는 파일에 대한 의존성이 생기게 된다. 특정한 <code>classpath:</code> 로 시작하는 URL(예: <code>classpath:../service.xml</code>)에 대한 참조도 지양해야 한다. 런타임 프로세스는 &quot;가장 근접한&quot; 클래스패스 루트를 선택한 뒤 상위 디렉토리를 찾는다. 잘못거나 다른 디렉토리를 클래스패스로 선택할 수 있다.</p>
<p>상대 경로 대신 적합한 경로(예: <code>C:/config/service.xml</code> 혹은 <code>classpath:/config/services.xml.</code>)를 선택할 수 있다. 그러나 애플리케이션 설정과 특정 절대 경로 위치와 결합되는 점을 유의해야 한다. 특정 절대 경로를 간접적으로 유지하는 방법 - 예를 들어 &quot;${...}&quot; 표현과 같은 런타임에 JVM 시스템 프로퍼티를 플레이스 홀더로 대입하는 방법 - 이 선호된다.</p>
</blockquote>
<p>네임스페이스는 임포트 지시 기능을 제공한다. 게다가 평범한 빈 정의를 넘어선 설정 기능을 스프링이 제공하는 XML 네임스페이스 선택을 통해 이용할 수 있다. 예를 들어 <code>context</code>와 <code>util</code> 네임스페이스와 같이 말이다.</p>
<h5 id="그루비groovy빈-정의-dsl"><a class="header" href="#그루비groovy빈-정의-dsl">그루비(Groovy)빈 정의 DSL</a></h5>
<p>추가적인 설정 메타데이터의 예제로서, 빈 정의는 Grails 프레임워크로 알려진 스프링 그루비 빈 정의 DSL로 표현할 수 있다. 일반적으로 이런 설정은 &quot;.groovy&quot; 파일에 있고 구조는 아래와 같다.</p>
<pre><code class="language-groovy">beans {
    dataSource(BasicDataSource) {
        driverClassName = &quot;org.hsqldb.jdbcDriver&quot;
        url = &quot;jdbc:hsqldb:mem:grailsDB&quot;
        username = &quot;sa&quot;
        password = &quot;&quot;
        settings = [mynew:&quot;setting&quot;]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean -&gt;
            dataSource = dataSource
        }
    }
}
</code></pre>
<h4 id="123-컨테이너-사용하기"><a class="header" href="#123-컨테이너-사용하기">1.2.3. 컨테이너 사용하기</a></h4>
<p><code>ApplicationContext</code>는 다른 빈들과 의존성 레지스트리를 관리하는 기능을 가진 팩토리를 위한 인터페이스이다. <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> 메서드를 사용해서, 빈 인스턴스를 검색할 수 있다.</p>
<p><code>ApplicationContext</code>는 빈 정의를 읽고 접근할 수 있게 해준다. 아래는 그 예제이다.</p>
<pre><code class="language-java">// Java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);

// retrieve configured instance
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);

// use configured instance
List&lt;String&gt; userList = service.getUsernameList();
</code></pre>
<pre><code class="language-kotlin">// Kotlin
import org.springframework.beans.factory.getBean

// create and configure beans
val context = ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;)

// retrieve configured instance
val service = context.getBean&lt;PetStoreService&gt;(&quot;petStore&quot;)

// use configured instance
var userList = service.getUsernameList()
</code></pre>
<p>Groovy 설정과 함께, 부트스트래핑하는 과정은 매우 유사하다. 이는 다른 컨텍스트 구현 클래스를 가지고 있다. 아래는 그루비 설정 예제이다.</p>
<pre><code class="language-java">ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
</code></pre>
<p>가장 유연한 방법은 <code>GenericApplicationContext</code>를 사용해서 리더 권한을 위임하도록 구성하는 것이다. 한 예로 XML 파일을 위해 <code>XmlBeanDefinitionReader</code>을 사용한다.</p>
<pre><code class="language-java">GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;);
context.refresh();
</code></pre>
<p><code>GroovyBeanDefinitionReader</code>를 사용해서 그루비 설정을 읽어올 수도 있다.</p>
<pre><code class="language-java">GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
context.refresh();
</code></pre>
<p>이런 reader들을 혼합하거나 매칭하는 방법으로 <code>ApplicationContext</code>의 권한을 위임해서 다양한 설정 소스파일로부터 빈 정의를 읽을 수 있다. </p>
<p>그러면 <code>getBean</code>을 사용해서 빈 인스턴스를 검색할 수 있다. <code>ApplicationContext</code> 인터페이스는 빈 인스턴스 검색을 위한 다른 메서드를 가지고 있다. 그러나 애플리케이션 코드에서 그런 메서드를 사용해선 안된다. 게다가 애플리케이션 코드는 <code>getBean</code> 메서드도 호출하지 말아야 한다. 이렇게 하여 스프링 API를 호출하는 의존성을 없애야 한다. 한 예로, 스프링과 웹 프레임워크의 통합은 JSF-managed beans와 컨트롤러와 같은 여러가지 웹 프레임워크 컴포넌트들을 위한 의존성 주입을 제공한다. 그리하여 <code>@Autowire</code> 어노테이션과 같은 기능을 사용해서 특정 빈에 대한 의존성을 선언할 수 있다.</p>
<h3 id="13-bean-오버뷰"><a class="header" href="#13-bean-오버뷰">1.3. Bean 오버뷰</a></h3>
<p>스프링 IoC 컨테이너는 하나 이상의 빈을 관리한다. 이 빈들은 컨테이너에게 제공하는 설정 메타데이터로 생성된다. XML의 <code>&lt;bean/&gt;</code> 형식의로 정의된 것들 말이다.</p>
<p>컨테이너 안에서, 빈 정의는 아래 메타데이터를 <code>BeanDefinition</code> 객체로써 표시되어며, 여기엔 아래와 같은 메타데이터가 포함된다.:</p>
<ul>
<li>패키지 경로가 포함된 클래스 이름: 일반적으로 정의된 빈의 실제 구현 클래스이다.</li>
<li>컨테이너 내에서 빈이 어떻게 행동해야 하는지에 대해 기술된 빈 행동 설정 요소 (스코프, 라이프사이클 콜백 등).</li>
<li>빈이 동작하는데 필요한 다른 빈에 대한 참조정보. 이 참조는 협력자(collaborators) 혹은 의존성(dependencies)이라고도 부른다.</li>
<li>새로 생성된 객체에서 구성할 기타 설정 - 예: 커넥션 풀을 관리하는 빈에서 사용할 커넥션의 수 혹은 풀의 사이즈 제한 등</li>
</ul>
<p>이런 메타데이터는 개별 빈 정의를 구성하는 프로퍼티의 모음을 번연ㄱ한다. 다음 테이블은 이러한 프로퍼티한 기술한 것이다.:</p>
<p><strong>표 1. 빈 정의</strong></p>
<table><thead><tr><th>프로퍼티</th><th>의미</th></tr></thead><tbody>
<tr><td>Class</td><td><a href="books/spring/">빈 인스턴스화</a></td></tr>
<tr><td>Name</td><td><a href="books/spring/">빈 네이밍</a></td></tr>
<tr><td>Scope</td><td><a href="books/spring/">빈 스코프</a></td></tr>
<tr><td>Constructor arguments</td><td><a href="books/spring/">의존성 주입</a></td></tr>
<tr><td>Properties</td><td><a href="books/spring/">의존성 주입</a></td></tr>
<tr><td>Autowiring mode</td><td><a href="books/spring/">협력자 오토와이어링</a></td></tr>
<tr><td>Lazy initialization mode</td><td><a href="books/spring/">빈 지연 인스턴스화</a></td></tr>
<tr><td>Initialization method</td><td><a href="books/spring/">빈 인스턴스화 콜백</a></td></tr>
<tr><td>Destruction method</td><td><a href="books/spring/">빈 파괴 콜백</a></td></tr>
</tbody></table>
<p>특정 빈을 생성하는 방법에 대한 정보를 포함한 빈 정의 외에도, <code>ApplicationContext</code> 구현체는 (사용자에 의해) 컨테이너 외부에서 생성된 객체 등록도 허용한다. 이 것은 ApplicationContext의 BeanFactory를 <code>getBeanFactory()</code> 메서드가 반환하는 <code>DefaultListableBeanFactory</code>객체를 통해 접근함으로써 처리된다. <code>DefaultListableBeanFactory</code>는 <code>registerSingleton(..)</code> 메서드와 <code>registerBeanDefinition(..)</code> 메서드를 통해 빈 등록을 지원한다. 그러나 일반적으로 애플리케이션은 일반적인 빈 정의 메타데이터를 통해 정의된 빈들과 단독으로 동작한다.</p>
<blockquote>
<p>빈 메타데이터와 수동으로 공급된 싱글턴 인스턴스는 컨테이너가 오토와이어링(autowiring) 단계와 기타 검사 단계에서 적절하기 추론하기 위해서 가능한 빨리 등록되어야 한다. 반면에 기존 메타데이터와 싱글턴 인스턴스를 오버라이딩한 것은 어느정도 지원되는 반면에, 런타임에서의 신규 빈 등록은 공식적으로 지원되지 않고 동시 접근 예외(concurrent access exception)와 빈 컨테이너의 모순된 상태를 유발할 수 있다. </p>
</blockquote>
<h4 id="131-빈-네이밍"><a class="header" href="#131-빈-네이밍">1.3.1. 빈 네이밍</a></h4>
<p>모든 빈은 하나 이상의 식별값을 가지고 있다. 이 식별값들은 빈의 호스트 컨테이너 내에서 유일해야 한다. 빈은 보통 유일한 식별값을 가지고 있다. 그렇지만 만약 하나 이상의 식별값이 필요한 경우, 추가적으로 별칭(alias)을 가질 수 있다.</p>
<p>XML 기반의 설정 메타데이터에서 빈 식별값으로 <code>id</code> 속성이나 <code>name</code> 속성, 혹은 두 속성 모두 사용했을 것이다. <code>id</code> 속성은 정확히 하나의 id만을 명시하게 한다. 관습적으로, id 값은 문자+숫자(alphanumeric, e.g. 'myBean', 'someService' 등)로 명명한다. 그러나 특별한 문자를 포함하는 것도 가능하다. 만약 빈에 대한 다른 별칭(alias)를 도입하길 원한다면, 빈의 <code>name</code> 속성에 명시할 수 있다. 이는 쉼표(,), 세미콜론(;) 혹은 공백문자(whitespace)로 구분한다. 스프링 3.1 버전 이전에는 <code>id</code> 속성은 입력 가능한 문자를 제한하는 <code>xsd:ID</code> 타입으로 정의되었다. 3.1 버전부터, <code>xsd:string</code> 타입으로 정의되었다. 더이상 XML 파서를 사용하지 않더라도 빈의 <code>id</code> 유일성은 컨테이너에 의해 강요된다.</p>
<p>빈의 <code>id</code> 속성이나 <code>name</code> 속성을 지정할 필요는 없다. 만약 명시적으로 지정하지 않는 경우, 컨테이너는 빈의 유일한 명칭을 생성한다. 그러나 만약 <code>ref</code> 요소나 서비스 로케이터 스타일의 룩업 방식을 사용해서 이름으로 빈을 참조하려면, 빈의 이름을 지정해야 한다. 이름을 제공하지 않는 이유는 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans">inner beans</a>와 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire">autowiring collaborators</a>와 관련이 있다.</p>
<blockquote>
<h4 id="빈-명명-규칙"><a class="header" href="#빈-명명-규칙">빈 명명 규칙</a></h4>
<p>빈을 이름을 명명할 때 인스턴스 필드 이름에 대해 표준 자바 규칙을 사용한다. 빈 이름은 소문자로 시작하고 카멜 케이스를 사용한다. 예를 들어 <code>accountmanager</code>, <code>accountService</code>, <code>userDao</code> 등 처럼 말이다.<br />
빈 명명은 지속적으로 설정에 대한 가독성과 이해를 쉽게 만든다. 스프링 AOP를 사용할 때도, 이름으로 관련된 빈들에 대한 어드바이스를 적용하는데 도움을 준다.</p>
</blockquote>
<blockquote>
<p>클래스패스를 컴포넌트 스캔하면, 스프링은 이름이 없는 컴포넌트들에 대한 빈 이름을 앞서 기술한 것과 같이 생성한다.: 근본적으로, 클래스 이름을 획득하여 첫 번째 문자열을 소문자로 변환한다. 그러나 드물게 클래스 명의 첫 번째와 두 번째 문자 모두 대문자인 특별한 경우엔 원래의 케이스가 유지된다. 이는 <code>java.beans.Introspector.decapitalize</code>에 의해 정의된 규칙과 동일하다. (스프링은 이를 사용한다.)</p>
</blockquote>
<h5 id="빈-정의-외부의-빈에-대한-별칭-정하기"><a class="header" href="#빈-정의-외부의-빈에-대한-별칭-정하기">빈 정의 외부의 빈에 대한 별칭 정하기</a></h5>
<p>빈을 정의할 때, 빈의 <code>id</code> 속성과 <code>name</code> 속성을 조합하여 하나 이상의 이름을 지정할 수 있다. 이 이름들은 동일한 빈에 별칭을 지정하는 것과 동등하고 특별한 상황에서 유용하다. 예를 들어 애플리케이션의 개별 컴포넌트가 컴포넌트에 명시된 빈 이름을 사용해서 공통의 의존성을 참조해야 할 때 말이다.</p>
<p>실제로 정의된 빈에 대한 모든 별칭을 명시하는 것은 항상 적절한 것은 아니다. 때때로 다른 곳에 빈에 대한 별칭에 대한 방식을 정의하는 것이 바람직하다. 다음은 대규모 시스템에서 흔히 사용하는, 개별 하위 시스템의 객체 정의에 대한 설정을 나누는 방법이다. XML 기반의 설정 메타데이터에서, <code>&lt;alias/&gt;</code> 요소를 사용해서 이를 적용할 수 있다. 다음 예제는 적용 방법에 대해 보여준다.:</p>
<pre><code class="language-xml">&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;
</code></pre>
<p>이 예에서, 동일 컨테이너의 <code>fromName</code>이라고 명명된 빈은, <code>toName</code>이라는 별칭으로 정의되어 참조될 수 있다.</p>
<p>예를 들어, 하위시스템 A에 대한 설정 메타데이터는 <code>subsystemA-dataSource</code>라는 이름으로 명명된 데이터소스를 참조할 수 있다. 하위 시스템 B에 대한 설정 메타데이터는 <code>subsystemB-dataSource</code>라고 명명된 데이터 소스를 참조할 수 있다. 모든 하위시스템을 사용해서 메인 애플리케이션을 구성할 때, 메인 애플리케이션은 <code>myApp-dataSource</code>로 명명된 데이터소스를 참조할 수 있다. 세 개의 이름들이 모두 동일한 객체를 참조하도록 하려면, 다음의 별칭 정의를 설정 메타데이터에 추가하여 사용할 수 있다.:</p>
<pre><code class="language-xml">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt;
&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;
</code></pre>
<p>이제 개별 컴포넌트와 메인 애플리케이션은 (네임스페이스를 효과적으로 작성하여) 다른 정의와 충돌하지 않도록 보장된 고유한 이름을 통해 데이터 소스를 참조할 수 있지만, 여전히 동일한 빈을 참조한다.</p>
<blockquote>
<h5 id="자바-설정"><a class="header" href="#자바-설정">자바 설정</a></h5>
<p>자바 설정을 사용하려면, <code>@Bean</code> 어노테이션을 사용해서 별칭을 제공할 수 있다. <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation"><code>@Bean</code> 어노테이션 사용하기</a>를 참고하라.</p>
</blockquote>
<h4 id="132-빈-인스턴스화"><a class="header" href="#132-빈-인스턴스화">1.3.2. 빈 인스턴스화</a></h4>
<p>빈 정의는 본질적으로 하나 이상의 객체를 생성하기 위한 레시피(방법)이다. 컨테이너는, 실제 객체를 생성하거나 가져오기 위한 빈 정의에 의해 캡슐화된 설정 메타데이터를 사용하거나 요청할 때, 이름을 가진 빈을 위한 레시피(빈 정의)를 본다.</p>
<p>만약 XML 기반의 설정 메타데이터를 사용한다면, <code>&lt;bean/&gt;</code> 요소의 <code>class</code> 속성으로 인스턴스화 된 객체의 타입(클래스)를 명시해야 한다. 이 <code>class</code> 속성 (내부적으로 <code>BeanDefinition</code> 인스턴스의 <code>Class</code>프로퍼티이다.)은 대개 필수요소이다. (예외 경우는 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class-instance-factory-method">인스턴스 팩토리 메서드로 인스턴스화하기</a>와 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-child-bean-definitions">빈 정의 상속</a>을 살펴보라.) <code>Class</code> 속성은 두 가지 방법 중 하나로 사용할 수 있다.:</p>
<ul>
<li>일반적으로, 컨테이너가 직접 빈의 생성자 - 자바 코드의 <code>new</code> 연산자와 동등한 - 를 호출(reflectively)하여 생성한, 빈 클래스를 지정한 것</li>
<li>객체를 생성하기 위해 호출되는 <code>static</code> 팩토리 메서드를 포함하는 실질적인 클래스를 명시한 것, 컨테이너가 빈을 생성하는 클래스의 <code>static</code> 팩토리 메서드를 호출하는 흔하지 않은 케이스이다. <code>static</code> 팩토리 메서드 호출로 반환된 객체 타입은 동일한 클래스이거나 다른 클래스일 수 있다.</li>
</ul>
<blockquote>
<h4 id="내부-클래스-이름"><a class="header" href="#내부-클래스-이름">내부 클래스 이름</a></h4>
<p>만약 <code>static</code> 중첩 클래스의 빈 정의를 설정하려면, 중첩 클래스의 바이너리 이름을 알아야 한다.<br />
예를 들어, 만약 <code>com.example</code> 패키지의 <code>Something</code> 클래스를 가지고 있고 <code>Something</code> 클래스가 <code>OtherThing</code>이란 <code>static</code> 중첩 클래스를 가지고 있다면, 빈 정의의 <code>class</code> 속성의 값은 <code>com.example.Something$OtherThing</code>이 될 것이다.<br />
<code>$</code> 문자는 외부 클래스와 중첩 클래스의 이름을 구분하기 위해 사용한다.</p>
</blockquote>
<h5 id="생성자로-인스턴스화하기"><a class="header" href="#생성자로-인스턴스화하기">생성자로 인스턴스화하기</a></h5>
<p>생성자를 사용하여 빈을 생성할 때, 일반적인 모든 클래스들은 스프링과 호환되며 사용 가능하다. 개발중인 클래스는 특정한 인터페이스를 구현하거나 특정 방식으로 코딩할 필요가 없다는 것이다. 단순히 빈  클래스를 명시하는 것 만으로 충분하다. 그러나 사용하는 IoC 컨테이너의 타입에 따라 기본 생성자가 필요할 수도 있다.</p>
<p>스프링 IoC 컨테이너는 관리하고자 하는 어떤 클래스라도 관리할 수 있다. 실ㅈ레 자바빈을 관리하는 것에 제한은 없다. 대부분의 스프링 사용자는 (인자가 없는) 기본 생성자가 있고 적절한 세터/게터가 있는 자바 빈을 선호한다. 컨테이너에서 빈 스타일이 아닌 클래스를 사용할 수 있다. 예를 들어, 만약에 자바빈 규격에 맞지않는 레거시 커넥션 풀을 사용해야 한다면, 스프링은 그것을 잘 관리할 것이다.</p>
<p>XML 기반 설정 메타데이터에서 아래와 같이 빈 클래스를 명시할 수 있다.</p>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;/&gt;

&lt;bean name=&quot;anotherExample&quot; class=&quot;examples.ExampleBeanTwo&quot;/&gt;
</code></pre>
<p>생성자 인자를 공급하는 방식과 객체가 생성된 후에 인스턴스 프로퍼티를 구성하는 방식에 대한 자세한 내용은 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators">의존성 주입</a>을 참고하라.</p>
<h5 id="스태틱-팩토리-메서드로-인스턴스화하기"><a class="header" href="#스태틱-팩토리-메서드로-인스턴스화하기">스태틱 팩토리 메서드로 인스턴스화하기</a></h5>
<p>스태틱 팩토리 메서드로 생성한 빈을 정의할 때, <code>class</code> 속성을 사용해서 <code>static</code> 팩토리 메서드를 포함하는 클래스를 명시하고, <code>factory-method</code> 속성으로 팩토리 메서드의 이름을 명시할 수 있다. (나중에 기술할 선택적 인자와 함께) 이 메서드를 호출할 수 있고, 생성자를 통해 생성된 것처럼 처리되는 오브젝트를 반환할 수 있다. 이런 빈 정의의 용도 중 하나는 레거시 코드에서 <code>static</code> 팩토리를 호출하는 것이다.</p>
<p>다음 빈 정의는 팩토리 메서드를 호출해서 생성된 빈에 대해 명시하는 것이다. 정의는 반환된 객체의 타입 (클래스)를 명시하지 않고, 오직 팩토리 메서드를 포함한 클래스만 알 수 있다. 이 예제에서, <code>createInstance()</code> 메서드는 스태틱 메서드여야 한다. 다음 예제는 팩토리 메서드를 명시하는 방법을 보여준다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;clientService&quot;
    class=&quot;examples.ClientService&quot;
    factory-method=&quot;createInstance&quot;/&gt;
</code></pre>
<p>다음 예제는 앞선 빈 정의와 동작하는 클래스이다.:</p>
<pre><code class="language-java">public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
</code></pre>
<p>팩토리 메서드에 선택적 인자를 공급하고 팩토리 메서드로부터 반환된 오브젝트에 프로퍼티를 설정하는 방식은 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed">의존성과 설정에 대한 상세내용</a>을 참고하라.</p>
<h5 id="인스턴스-팩토리-메서드를-사용해서-인스턴스화하기"><a class="header" href="#인스턴스-팩토리-메서드를-사용해서-인스턴스화하기">인스턴스 팩토리 메서드를 사용해서 인스턴스화하기</a></h5>
<p>스태틱 팩토리 메서드를 통해 인스턴스화하는 것과 유사하게, 인스턴스 팩토리 메서드는 컨테이너가 생성한 빈의 논 스태틱 메서드를 호출한다. 이 방식을 사용하려면, <code>class</code> 속성을 비우고, <code>factory-bean</code> 속성에 인스턴스 메서드를 포함한 빈의 이름을 명시해야 한다. <code>factory-method</code> 속성에 메서드 이름을 추가한다. 다음은 그 예제이다.:</p>
<pre><code class="language-xml">&lt;!-- createInstance() 메서드를 포함한 팩토리 빈 --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- 로케이터 빈이 요구하는 의존성을 주입 --&gt;
&lt;/bean&gt;

&lt;!-- 팩토리 빈을 통해 생성뙨 빈 --&gt;
&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;
</code></pre>
<p>다음 예제는 상응하는 클래스 예제이다.:</p>
<pre><code class="language-java">public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
</code></pre>
<p>팩토리 클래스는 하나 이상의 팩토리 메서드를 가질 수 있다. 다음은 그 예제이다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;

&lt;bean id=&quot;accountService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createAccountServiceInstance&quot;/&gt;
</code></pre>
<p>다음은 상응하는 클래스이다.:</p>
<pre><code class="language-java">public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}
</code></pre>
<p>이런 접근은 팩토리 빈이 의존성 주입(DI)를 통해 구성되고 관리됨을 보여준다.</p>
<blockquote>
<p>스프링 문서에서, &quot;팩토리 빈&quot;은 스프링 컨테이너에서 구성되고 인스턴스 팩토리 메서드 혹은 스태틱 팩토리 메서드를 통해 생성한 객체를 말한다. 이와 대조적으로, <code>FactoryBean</code> (대문자 사용을 유심히 보라.)은 스프링의 특정한 <code>FactoryBean</code>을 말한다.</p>
</blockquote>
<h3 id="14-의존성"><a class="header" href="#14-의존성">1.4. 의존성</a></h3>
<p>일반적인 엔터프라이즈 애플리케이션은 하나의 객체로 구성되지 않는다. 심지어 간단한 애플리케이션도 최종 사용자가 보는 것처럼 일관성 있는 애플리케이션으로 보여주려면 서로 상호작용하는 여러 객체를 가지고 있어야 한다. 다음 섹션은 객체가 목표를 달성하기 위해 상호작용하는 완전 실질적인 스탠드-얼론 애플리케이션을 위한 수많은 빈 정의 방법을 설명한다.</p>
<h4 id="141-의존성-주입"><a class="header" href="#141-의존성-주입">1.4.1. 의존성 주입</a></h4>
<p>의존성 주입은 객체가 그들과 동작하는 다른 객체에 대한 의존성을 정의하는 프로세스이다. 생성자 인자, 팩토리 메서드의 인자, 혹은 팩토리 메서드로부터 반환되거나 생성된 후 인스턴스에 주입될 수도 있다. 그 다음 컨테이너는 빈을 생성할 때 의존성을 주입한다. 이 프로세스는 근본적으로 빈 자신이 인스턴스화 과정이나 클래스의 직접 생성을 이용한 의존 혹은 서비스 로케이터 패턴 등으로 제어하는 방식에서 역전된다. 그래서 제어의 역전(Inversion of Control)이란 이름이다.</p>
<p>DI 원리에 의해 코드는 더 깔끔해지고, 객체가 의존성을 제공받음으로써 디커플링은 더 효과적이다. 객체는 그들의 의존성을 탐색하지 않고 의존할 클래스나 위치도 알지 못한다. 결과적으로, 클래스는 특히 의존성이 인터페이스나 추상 클래스 기반이면 더 테스트하기 쉬워지고, 유닛 테스트에서 사용되는 스텁(stub)이나 목(mock) 구현체를 허용한다.</p>
<p>의존성 주입엔 두 가지 방법이 있다.: <a href="books/spring/core-01-ioc-container.html#%EC%83%9D%EC%84%B1%EC%9E%90-%EA%B8%B0%EB%B0%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85">생성자 기반 의존성 주입</a>입 <a href="books/spring/core-01-ioc-container.html#%EC%84%B8%ED%84%B0-%EA%B8%B0%EB%B0%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85">세터 기반 의존성 주입</a></p>
<h5 id="생성자-기반-의존성-주입"><a class="header" href="#생성자-기반-의존성-주입">생성자 기반 의존성 주입</a></h5>
<p>생성자 기반 의존성 주입은 컨테이너가 의존성을 나타내는 여러 인자를 가진 생성자를 호출함으로 써 동작한다. 빈을 생성하기 위한 특정한 인자를 가진 <code>static</code> 메서드를 호출하는 것과 거의 동등하고, 이 주제는 생성자의 인자와 <code>static</code> 팩토리 메서드를 유사하게 다룬다. 다음 예제는 생성자로 의존성 주입만이 가능한 클래스를 보여준다.:</p>
<pre><code class="language-java">public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
</code></pre>
<p>이 클래스엔 특별한게 없다. 이는 특정 컨테이너에 종속되거나, 특정 인터페이스, 기본 클래스, 어노테이션이 없는 POJO(Plain Old Java Object)이다.</p>
<h6 id="생성자-인자-결정"><a class="header" href="#생성자-인자-결정">생성자 인자 결정</a></h6>
<p>생성자 인자 결정 방식은 인자의 타입을 사용함으로써 발생한다. 만약 빈 정의의 생성자 인자가 잠재적으로 모호한 경우가 아니라면, 빈 정의에 의해 정의된 생성자 인자가 정의되는 순서는 빈이 인스턴스화할 때 해당 인자가 적절한 생성자에 의해 제공되는 순서이다. 다음 클래스를 살펴보자.:</p>
<pre><code class="language-java">package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
</code></pre>
<p><code>ThingTwo</code>와 <code>ThingThree</code> 클래스가 상속과 관련된 것이 없고, 잠재적으로 모호함이 없다고 가정하자. 그럼련 다음 설정은 제대로 동작할 것이다. 그리고 특정 생성자 인자의 순서나 타입을 명시적으로 <code>&lt;constructor-arg/&gt;</code> 요소에 명시할 필요가 없다.</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg ref=&quot;beanTwo&quot;/&gt;
        &lt;constructor-arg ref=&quot;beanThree&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;

    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>타입이 알려진 다른 빈이 참조될 때, (이전 예제의 케이스로) 매칭이 발생한다. <code>&lt;value&gt;true&lt;/value&gt;</code>와 같은 단순한 타입이 사용될 때, 스프링은 값의 타입을 결정할 수 없고, 도움 없인 매칭 작업을 할 수 없다. 다음 예제를 살펴보자.:</p>
<pre><code class="language-java">package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
</code></pre>
<p><strong>생성자 인자 타입 매칭</strong></p>
<p>이전 시나리오에서, 명시적으로 생성자의 타입을 <code>type</code> 속성으로 명시한다면 컨테이너는 단순한 타입으로 타입 매칭을 사용할 수 있다. 다음의 예제를 보면 알 수 있다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>생성자 인자의 순서</strong></p>
<p><code>index</code> 속성을  사용해서 생성자 인자의 순서를 명시할 수 있다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>추가로 여러 개의 단순한 값의 모호성을 해결하려면, 순서를 명시하여 생성자가 가진 동일한 두 개 이상의 인자의 모호성을 해결할 수 있다.</p>
<blockquote>
<p>순서는 0부터 시작한다.</p>
</blockquote>
<p><strong>생성자 인자의 이름</strong></p>
<p>값을 명확히 설정하기 위해 생성자 파라미터 이름을 사용할 수 있다. 다음의 예제를 보자.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>이 작업을 즉시 수행하려면, 코드가 디버그 플래그로 컴파일되어야 스프링이 생성자로부터 파라미터 이름을 찾을 수 있다. 만약 디버그 플래그로 컴파일하길 원치 않으면, [@ConstructorProperties] JDK 어노테이션을 사용해서 명시적으로 생성자 인자에 이름을 붙일 수 있다. 샘플 클래스를 보자.:</p>
<pre><code class="language-java">package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({&quot;years&quot;, &quot;ultimateAnswer&quot;})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
</code></pre>
<h5 id="세터-기반-의존성-주입"><a class="header" href="#세터-기반-의존성-주입">세터 기반 의존성 주입</a></h5>
<p>세터 기반 의존성 주입은 컨테이너가 기본 생성자로 빈을 생성하거나 인자가 없는 <code>static</code> 팩토리 메서드로 빈 인스턴스를 생성한 후 세터 메서드를 호출하는 경우에 사용한다.</p>
<p>다음 예제는 순수한 세터 주입을 사용해서 의존성 주입을 해야하만 하는 클래스를 보여준다. 이 클래스는 관습적인 자바 코드이다. 아무런 의존성이 없는 POJO이다.</p>
<pre><code class="language-java">public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
</code></pre>
<p><code>ApplicationContext</code>는 생성자 기반/세터 기반 의존성 주입을 지원한다. 생성자 주입 후 세터 주입을 해야하는 경우도 지원한다. 어떤 형식에서 다른 형식으로 프로퍼티를 변환하는 <code>PropertyEditor</code> 인스턴스와 함께 사용해서 <code>BeanDefinition</code>의 형식으로 의존성을 설정해야 한다. 그러나 대부분의 스프링 사용자는 이런 클래스들을 직접 다루기보단 XML 빈 정의, (<code>@Controller</code>, <code>@Component</code> 등의 어노테이션이 달린) 컴포넌트 등을 다루거나 자바 기반의 <code>@Configuration</code> 클래스의 <code>@Bean</code> 메서드를 다룰 것이다. 이런 소스는 내부적으로 <code>BeanDefinition</code> 인스턴스로 변환되고 전체 스프링 IoC 컨테이너 인스턴스를 로드하는데 사용한다.</p>
<blockquote>
<h5 id="생성자-기반-의존성-주입과-세터-기반-의존성-주입"><a class="header" href="#생성자-기반-의존성-주입과-세터-기반-의존성-주입">생성자 기반 의존성 주입과 세터 기반 의존성 주입?</a></h5>
<p>생성자 주입과 세터 주입을 적절하게 섞어 사용할 수 있기 때문에, 생성자를 사용해서 필수적인 의존성을 주입하고 세터 메서드나 설정 메서드로 선택적인 의존성을 주입하는 방법은 적절하다. 세터 메서드에 <code>@Required</code> 어노테이션을 사용해서 프로퍼티를 필수적으로 의존받아야 함을 나타낼 수 있다. 그러나 생성자 주입이 더욱 선호된다.</p>
<p>스프링 팀은 일반적으로 생성자 주입을 지지한다. 이는 애플리케이션 컴포넌트를 불변 객체로 구현할 수 있게 하고 필수적인 의존성을 <code>null</code>이 아니게 할 수 있다. 게다가 생성자 주입 컴포넌트는 항상 (호출하는) 클라이언트 코드에게 완전히 초기화된 객체를 반환한다. 부수적으로, 너무 많은 생성자 인자는 나쁜 코드 냄새이고, 클래스가 너무 많은 책임을 가지고 있다는걸 암시한다. 그래서 적절한 관심사의 구분으로 더 나은 코드로 리팩토링해야 한다.</p>
<p>세터 주입은 주로 선택적 인자에 한해 사용해야 한다. 이런 인자는 클래스가 적절한 기본 값을 가지고 있어야 한다. 반면에 not-null 확인은 의존성 있는 모든 코드에서 반드시 수행되어야 한다. 세터 주입의 한 가지 장점은 세터 메서드가 클래스의 객체를 차후에 재설정하거나 재 주입 가능하게 한다는 것이다. 그러므로 <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/integration.html#jmx">JMX MBeans</a>를 통한 관리는 세터 주입의 강력한 사용 사례이다.</p>
<p>특정 클래스에 가장 적합한 의존성 주입 방법을 사용해야 한다. 가끔 소스를 가지고 있지 않은 써드파디 클래스를 다뤄야 할 때, 선택을 해야한다. 예를 들어, 만약 써드파티 클래스가 세터 메서드를 노출하지 않으면, 오로지 생성자 주입만이 사용 가능할 것이다.</p>
</blockquote>
<h5 id="의존성-주입의-예"><a class="header" href="#의존성-주입의-예">의존성 주입의 예</a></h5>
<p>다음 예제는 세터 의존성 주입을 위한 XML 기반의 설정 메타데이터이다. 스프링 XML 설정 파일의 일부분이 다음과 같다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;!-- setter injection using the nested ref element --&gt;
    &lt;property name=&quot;beanOne&quot;&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/property&gt;

    &lt;!-- setter injection using the neater ref attribute --&gt;
    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre>
<p>다음은 연관된 <code>ExampleBean</code> 클래스이다.:</p>
<pre><code class="language-java">public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}
</code></pre>
<p>앞선 예제에서, XML 파일의 특정한 프로퍼티에 대응하여 세터를 선언했다. 다음 예는 생성자 기반 의존성 주입을 사용한다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;!-- constructor injection using the nested ref element --&gt;
    &lt;constructor-arg&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/constructor-arg&gt;

    &lt;!-- constructor injection using the neater ref attribute --&gt;
    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;

    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre>
<p>다음 예는 연관된 <code>ExampleBean</code> 클래스이다.:</p>
<pre><code class="language-java">public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
</code></pre>
<p>빈 정의에 명시된 생성자 인자는 <code>ExampleBean</code>의 생성자의 인자로 사용된다.</p>
<p>이제 생성자를 사용하는 대신 객체의 인스턴스를 반환하는 <code>static</code> 팩토리 메서드를 호출하는 예제를 다룬다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; factory-method=&quot;createInstance&quot;&gt;
    &lt;constructor-arg ref=&quot;anotherExampleBean&quot;/&gt;
    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;constructor-arg value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre>
<p>다음 예는 <code>ExampleBean</code> 클래스이다.:</p>
<pre><code class="language-java">public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
</code></pre>
<p><code>static</code> 팩토리 메서드의 인자는 <code>&lt;constructor-arg/&gt;</code> 요소에 의해 공급된다. 정확히는 생성자가 실제로 사용된 것과 동일하다. 팩토리 메서드에 의해 반환된 클래스 타입은 <code>static</code> 팩토리 메서드를 포함하는 클래스의 타입과 동일할 필요는 없다. (논-스태틱) 인스턴스 팩토리 메서드는 본질적으로 동일한 방식으로 사용할 수 있다. 그래서 여기선 이에 대해 다루진 않는다.</p>
<h4 id="142-의존성과-설정의-상세내용"><a class="header" href="#142-의존성과-설정의-상세내용">1.4.2. 의존성과 설정의 상세내용</a></h4>
<p>이전 섹션에서 언급한 것 처럼, 빈 프로퍼티와 생성자 인자를 다른 빈(협력자)의 참조로 사용하거나, 인라인으로 정의된 값으로 사용할 수 있다. 스프링의 XML 기반 설정 메타데이터는 <code>&lt;property/&gt;</code> 와 <code>&lt;constructor-arg/&gt;</code> 요소를 제공한다.</p>
<h5 id="값-primitive-string-등"><a class="header" href="#값-primitive-string-등">값 (Primitive, String 등)</a></h5>
<p><code>&lt;property/&gt;</code> 요소의 <code>value</code> 속성은 사람이 읽을 수 있는 문자열 값으로써 프로퍼티 혹은 생성자 인자를 명시하게 한다. 스프링의 <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#core-convert-ConversionService-API">변환 서비스(conversion service)</a>는 <code>String</code> 타입의 값을 실제 속성이나 인자의 타입의 값으로 변환하는데 사용한다. 다음은 다양한 값을 설정하는 예제이다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;!-- results in a setDriverClassName(String) call --&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;masterkaoli&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>다음은 <a href="books/spring/">p-네임스페이스</a>를 사용해서 더욱 간단한 XML 설정하는 예제이다.:</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;
        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;
        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;
        p:username=&quot;root&quot;
        p:password=&quot;masterkaoli&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>이전 XML은 더욱 간단하다. 그러나 IDE의 자동 완성 기능을 사용하지 않는 한, 오타가 설계 시점이 아닌 런타임 시점에 발견된다. IDE의 어시스턴스 기능을 강력히 권고한다.</p>
<p>다음과 같이 <code>java.util.Properties</code> 인스턴스를 설정할 수 있다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;mappings&quot;
    class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;

    &lt;!-- typed as a java.util.Properties --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>스프링 컨테이너는 <code>&lt;value/&gt;</code> 요소의 텍스트를 자바 빈 <code>PropertyEditor</code> 방식을 사용하는 <code>java.util.Properties</code> 인스턴스로 변환한다. 이는 유용한 축약어로, 스프링 팀이 중첩된 <code>&lt;value/&gt;</code> 요소 사용보다 선호하는 몇 안되는 방법 중 하나이다.</p>
<h6 id="idref-요소"><a class="header" href="#idref-요소"><code>idref</code> 요소</a></h6>
<p><code>idref</code> 요소는 다른 빈의 <code>id</code> 문자열 값을 <code>&lt;constructor-arg/&gt;</code> 혹은 <code>&lt;property/&gt;</code> 요소로 전달하는 오류방지 방법이다. 다음 예제는 사용하는 방법에 대해 보여준다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;

&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;targetName&quot;&gt;
        &lt;idref bean=&quot;theTargetBean&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>앞선 빈 정의에서 스니핏은 다음 스니핏과 완전히 동등하다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;

&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>전자는 후자보다 선호되는데, <code>idref</code> 태그를 사용함으로써 컨테이너는 배포 시점에 참조된 빈이 실제로 존재하는지 검증한다. 후자의 경우, <code>client</code> 빈의 <code>targetName</code> 프로퍼티를 전달하면서 어떤 검증도 수행하지 않는다. 오타는 <code>client</code> 빈을 생성할 때 발견된다. 만약 <code>client</code> 빈이 <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#beans-factory-scopes">프로토타입</a> 빈인 경우, 오타와 야기되는 예외는 컨테이너가 배포되고 한참 지난 후에 발견된다.</p>
<blockquote>
<p><code>idref</code> 요소의 <code>local</code> 속성은 4.0 beans XSD에서 더이상 지원되지 않는다. 4.0 명세로 업그레이드할 때 <code>idref local</code> 참조를 <code>idref bean</code>으로 변경하라.</p>
</blockquote>
<p>스프링 2.0 버전 이전에서 <code>&lt;idref/&gt;</code> 요소가 가져오는 값들은 <code>ProxyFactoryBean</code> 빈 정의 안의 <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#aop-pfb-1">AOP 인터셉터</a> 설정에 위치한다. 인터셉터 이름을 명시할 때 <code>&lt;idref/&gt;</code> 요소를 사용하는 것은 인터셉터 ID를 잘못쓰는 것을 방지하게 한다.</p>
<h5 id="다른-빈-협력자-참조"><a class="header" href="#다른-빈-협력자-참조">다른 빈 (협력자) 참조</a></h5>
<p><code>ref</code> 요소는 <code>&lt;constructor-arg/&gt;</code>와 <code>&lt;property/&gt;</code> 정의 요소 내 마지막 요소이다. 빈의 특정 프로퍼티에 컨테이너가 관리하는 다른 빈(협력자)의 참조값을 설정한다. 이 참조된 빈은 프로퍼티로 설정한 빈이 의존한다. 그리고 이는 프로퍼티 값으로 설정하기 전에 필요할 때 초기화된다. (만약 협력자가 싱글턴 빈이라면, 컨테이너에 의해 이미 초기화됐을 것이다.) 모든 참조는 결국 다른 객체의 참조이다. 범위와 검증은 <code>bean</code>, <code>local</code>, <code>parent</code> 요소를 통해 어떤 객체의 ID 혹은 이름을 명시하냐에 따라 결정된다.</p>
<p><code>&lt;ref/&gt;</code> 태그의 <code>bean</code> 요소를 통해 타겟 빈을 명시하는 것은 일반적인 형식이고 동일한 XML 파일에 있지 않더라도 동일 컨테이너나 부모 컨테이너의 어떤 참조된 빈이라도 생성할 수 있게 허용한다. <code>bean</code> 속성의 값은 타겟 빈의 <code>id</code> 속성이나 <code>name</code> 속성과 동일하다. 다음 예제는 <code>ref</code> 요소를 어떻게 사용하는지 보여준다.:</p>
<pre><code class="language-xml">&lt;ref bean=&quot;someBean&quot;/&gt;
</code></pre>
<p><code>parent</code> 속성을 통해서 타겟 빈을 명시하는 것은 현재 컨테이너의 부모 컨테이너에 있는 빈의 참조를 생성한다. <code>parent</code> 속성의 값은 타겟 빈의 <code>id</code> 속성이나 <code>name</code> 속성의 값 중 하나와 같다. 타겟 빈은 부모 컨테이너에 있어야 한다. 컨테이너의 계층이 있고 부모 컨테이너에 존재하는 빈을 동일한 이름의 프록시로 감싸고 싶다면 주로 이런 빈 참조 변형을 사용해야 한다. 다음 리스트 쌍은 <code>parent</code> 속성을 사용하는 방법을 보여준다.:</p>
<pre><code class="language-xml">&lt;!-- in the parent context --&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.something.SimpleAccountService&quot;&gt;
    &lt;!-- insert dependencies as required as here --&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-xml">&lt;!-- in the child (descendant) context --&gt;
&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;
    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;
    &lt;/property&gt;
    &lt;!-- insert other configuration and dependencies as required here --&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p><code>idref</code> 요소의 <code>local</code> 속성은 4.0 beans XSD에서 더이상 지원되지 않는다. 4.0 명세로 업그레이드할 때 <code>idref local</code> 참조를 <code>idref bean</code>으로 변경하라.</p>
</blockquote>
<h5 id="내부-빈"><a class="header" href="#내부-빈">내부 빈</a></h5>
<p><code>&lt;property/&gt;</code> 혹은 <code>&lt;constructor-arg/&gt;</code> 요소 내 <code>&lt;bean/&gt;</code> 요소는 다음ㄱ뫄 같이 내부 빈을 정의한다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>내부 빈 정의는 ID나 이름가 필요없다. 만약 명시한다면, 컨테이너는 식별자로써 그 값을 사용하지 않는다. 컨테이너는 <code>scope</code> 플래그도 생성 과정에서 무시한다. 왜냐하면 내부 빈은 항상 익명이고 오로지 외부 빈과 함께 생성하기 때문이다. 내부 빈에 독립적으로 접근하거나, 이를 포함하는 (외부) 빈 외에 협력자로 주입하는 것은 불가능하다.</p>
<p>코너 케이스로, 임의의 범위 - 예를들어 싱글턴 빈을 포함한 요청 범위(request-scoped)의 내부 빈 - 로부터의 소멸 콜백(destruction callback)을 받는 것도 가능하다. 내부 빈 인스턴스의 생성은 그 빈이 포함한 빈과 동일하다. 그러나 소멸 콜백은 요청 범위의 라이프사이클 안에서 참여하게 한다. 이는 일반적인 시나리오는 아니고, 내부 빈은 일반적으로 포함하는 빈의 범위를 단순하게 공유한다.</p>
<h5 id="컬렉션"><a class="header" href="#컬렉션">컬렉션</a></h5>
<p><code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code> 그리고 <code>&lt;props/&gt;</code> 요소들은 각각 프로퍼티와 인자로써 Java의 <code>Collection</code> 타입 - <code>List</code>, <code>Set</code>, <code>Map</code>, <code>Properties</code> - 을 설정한다. 다음 예는 이 것들을 사용하는 방법을 보여준다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>Map의 Key/Value 값, 혹은 Set 값은 다음 요소 중 무엇이라도 가능하다.:</p>
<pre><code class="language-plain">bean | ref | idref | list | set | map | props | value | null
</code></pre>
<h6 id="컬렉션-병합"><a class="header" href="#컬렉션-병합">컬렉션 병합</a></h6>
<p>스프링 컨테이너는 컬렉션 병합을 지원한다. 애플리케이션 개발자는 부모 요소인 <code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code> 혹은 <code>&lt;props/&gt;</code> 를 정의하고 자식 요소 <code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code> 그리고 <code>&lt;props/&gt;</code> 등을 부모 컬렉션으로부터 상속받고 값을 덮어쓸 수 있다. 이는 자식 컬렉션의 값이 부모 컬렉션과 자식 컬렉션의 병합 결과가 되는 것이다. 부모 컬렉션의 특정 값을 자식 요소가 덮어쓸 수 있다.</p>
<p>병합에 대한 이 섹션은 부모-자식 빈 방식에 대해 다룬다. 부모-자식 빈 정의에 대해 낯선 독자는 계속 읽기 전에 <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions">관련 섹션</a>에 대해 먼저 읽어보길 권한다.</p>
<p>다음 예제는 컬렉션 병합을 구현한다.:</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;administrator&quot;&gt;administrator@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;!-- the merge is specified on the child collection definition --&gt;
            &lt;props merge=&quot;true&quot;&gt;
                &lt;prop key=&quot;sales&quot;&gt;sales@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.co.uk&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;
</code></pre>
<p><code>adminEmails</code> 프로퍼티에 <code>&lt;props/&gt;</code> 요소에 <code>merge=true</code> 속성이 사용된 것을 유심히 봐라. <code>child</code> 빈을 생성할 때, 인스턴스는 <code>adminEmails</code>라는 <code>Properties</code> 컬렉션을 가지고 있다. 이는 자식과 부모의 <code>adminMails</code>의 병합 결과를 가지고 있다. 다음 리스트는 그 결과를 나타낸다.:</p>
<pre><code class="language-properties">administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
</code></pre>
<p>자식 <code>Properties</code> 컬렉션의 값은 부모 <code>&lt;props/&gt;</code> 로부터 모든 요소를 상속받아 설정한다. 그리고 자식 컬렉션의 값의 <code>support</code> 프로퍼티 값은 부모 컬렉션의 값을 덮어쓰게 된다.</p>
<p>이 병합 행위는 <code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code> 컬렉션 타입들에서 유사하게 지원한다. <code>&lt;list/&gt;</code>의 특정한 상황에서, 리스트 컬렉션 타입과 관련된 의미(값이 정렬된 컬렉션과 같은 개념)의 경우 유지된다. 부모 값은 모든 자식 리스트의 값을 앞선다. <code>Map</code>, <code>Set</code>, <code>Properties</code> 컬렉션 타입의 경우, 순서가 존재하지 않는다. 그러므로, 순서라는 의미는 컨테이너가 내부적으로 사용하는 이 타입들의 구현체에선 사실상 없다.</p>
<h6 id="컬렉션-병합의-제한"><a class="header" href="#컬렉션-병합의-제한">컬렉션 병합의 제한</a></h6>
<p>다른 컬렉션 타입간의 병합은 할 수 없다. 만약 시도한다면, 적절한 예외가 발생할 것이다. <code>merge</code> 속성은 자식 정의에 명시해야 한다. 부모 컬렉션 정의에 <code>merge</code> 속성을 명시하는 것은 불필요하고 기대하는 병합 결과가 나타나지 않을 것이다.</p>
<h6 id="강타입-컬렉션"><a class="header" href="#강타입-컬렉션">강타입 컬렉션</a></h6>
<p>Java 5에서 제네릭 타입의 도입으로, 컬렉션의 타입을 제한할 수 있다. 이는 <code>String</code> 타입으로 구성된 컬렉션을 선언할 수 있다는 것이다. 만약 스프링을 사용할 때 타입이 명시된 컬렉션을 빈의 의존성으로 주입하면, 스프링 타입 변환 지원 기능의 도움을 얻을 수 있다. 다음 자바 클래스와 빈 정의는 사용 방법을 보여준다.:</p>
<pre><code class="language-java">public class SomeClass {

    private Map&lt;String, Float&gt; accounts;

    public void setAccounts(Map&lt;String, Float&gt; accounts) {
        this.accounts = accounts;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;something&quot; class=&quot;x.y.SomeClass&quot;&gt;
        &lt;property name=&quot;accounts&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;one&quot; value=&quot;9.99&quot;/&gt;
                &lt;entry key=&quot;two&quot; value=&quot;2.75&quot;/&gt;
                &lt;entry key=&quot;six&quot; value=&quot;3.99&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><code>something</code> 빈의 <code>accounts</code> 속성이 주입받을 준비가 됐을 때, <code>Map&lt;String, Float&gt;</code> 타입의 요소에 대한 제네릭 정보가 리플렉션에 의해 사용 가능해진다. 그러므로 스프링의 타입 변환 기능은 <code>Float</code> 타입이 되어야 할 다양한 값 요소와 문자열 값들 (<code>9.99</code>, <code>2.75</code> 등)을 실제 <code>Float</code> 타입으로 변환되어야 함을 인식한다.</p>
<h5 id="null과-빈-문자열-값"><a class="header" href="#null과-빈-문자열-값">Null과 빈 문자열 값</a></h5>
<p>스프링은 비어있는 인자를 빈 문자열 <code>&quot;&quot;</code>처럼 다룬다. 다음 스니핏은 <code>email</code> 프로퍼티에 빈 문자열 (&quot;&quot;)를 설정하는 예제이다.:</p>
<pre><code class="language-xml">&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>이전 예제는 다음 자바 코드와 동일하다.:</p>
<pre><code class="language-java">exampleBean.setEmail(&quot;&quot;);
</code></pre>
<p><code>&lt;null/&gt;</code> 요소는 <code>null</code> 값을 다룬다. 다음 예제가 이를 보여준다.:</p>
<pre><code class="language-xml">&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot;&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>앞선 설정은 다음 자바 코드와 동등하다.:</p>
<pre><code class="language-java">exampleBean.setEmail(null);
</code></pre>
<h5 id="p-네임스페이스-xml-축약어"><a class="header" href="#p-네임스페이스-xml-축약어">p-네임스페이스 XML 축약어</a></h5>
<p>p-네임스페이스는 빈 요소의 속성을 협력하는 빈 프로퍼티를 기술하는 용도로 사용하게 한다.</p>
<p>스프링은 XML 스키마 정의 기반의 <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#xsd-schemas">네임스페이스</a>로 확장성을 가진 설정 포맷을 지원한다. 이 챕터의 <code>bean</code> 설정 포맷은 XML 스키마 문서로 정의된다. 그러나 p-네임스페이스는 XSD 파일로 정의되지 않고 오직 스프링 코어에만 존재한다.</p>
<p>다음 예제는 두 가지 XML 스니핏을 보여준다. 첫 번째는 표준 XML 형식을 사용하고 두 번째는 p-네임스페이스를 사용한다. 두 경우의 결과는 같다.:</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;
        &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;
        p:email=&quot;someone@somewhere.com&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>예제는 <code>email</code>이라는 p-네임스페이스의 속성을 빈 정의로 나타낸다. 이는 스프링에게 프로퍼티를 선언하라고 명령하는 것이다. 앞서 말한대로, p-네임스페이스는 스키마 정의에 없기 때문에, 속성의 이름을 프로퍼티 이름으로 설정해야 한다.</p>
<p>다음 예제는 다른 빈을 참조하는 두 가지 이상의 빈 정의를 포함한다.:</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;
        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;john-modern&quot;
        class=&quot;com.example.Person&quot;
        p:name=&quot;John Doe&quot;
        p:spouse-ref=&quot;jane&quot;/&gt;

    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>이 예제는 p-네임스페이스를 사용하는 프로퍼티 값 뿐만이 아니라 프로퍼티 참조를 선언하는 특별한 형식도 사용한다. 첫 번째 빈 정의가 <code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot; /&gt;</code> 코드를 사용해서 <code>john</code> 빈이 <code>jane</code> 빈에 대한 참조를 생성한 반면에, 두 번째 빈 정의는 <code>p:spouse-ref=&quot;jane&quot;</code> 을 속성으로 사용해서 동일한 작업을 수행한다. 이 경우에 <code>-ref</code> 부분은 직접 값을 주입하는게 아니라 다른 빈에 대한 참조를 가리키는 반면에, <code>spouse</code> 는 프로퍼티의 이름이다.</p>
<blockquote>
<p>p-네임스페이스는 표준 XML 형식만큼 유연하지 않다. 한 예로, 프로퍼티 참조를 선언하는 형식은 <code>Ref</code>로 끝나는 이름을 가진 프로퍼티와 충돌한다. 반면에 표준 XML 포맷은 그렇지 않다. 우린 팀 멤버와 커뮤니케이션 한뒤 조심스럽게 접근하여 모든 방법을 동시에 사용하는 XML 문서 작성을 피할 것을 추천한다.</p>
</blockquote>
<h5 id="c-네임스페이스-xml-축약어"><a class="header" href="#c-네임스페이스-xml-축약어">c-네임스페이스 XML 축약어</a></h5>
<p>p-네임스페이스 XML 축약어와 유사하게, c-네임스페이스는 스프링 3.1부터 도입되어, 중첩된 <code>constructor-arg</code> 요소 대신 생성자 인자를 인라인 속성으로 설정하는 것을 허용한다.</p>
<p>다음 예제는 <code>c:</code> 네임스페이스를 사용해서 <a href="books/spring/core-01-ioc-container.html#%EC%83%9D%EC%84%B1%EC%9E%90-%EA%B8%B0%EB%B0%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85">생성자 기반 의존성 주입</a>과 동일한 작업을 수행한다.:</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;
    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;

    &lt;!-- traditional declaration with optional argument names --&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;
        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;
        &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- c-namespace declaration with argument names --&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;
        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p><code>c:</code> 네임스페이스는 생성자 인자를 이름으로 설정하는데 <code>p:</code> 네임스페이스와 동일한 규칙을 사용한다. 유사하게 XSD 스키마가 정의되어 있지 않지만 XML 파일에 선언되어야 한다. (스프링 코어 내부에 존재한다.)</p>
<p>생성자 인자의 이름이 허용되지 않는 드문 케이스에서, 인자의 순서를 사용할 수 있다.:</p>
<pre><code class="language-xml">&lt;!-- c-namespace index declaration --&gt;
&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:_0-ref=&quot;beanTwo&quot; c:_1-ref=&quot;beanThree&quot;
    c:_2=&quot;something@somewhere.com&quot;/&gt;
</code></pre>
<blockquote>
<p>XML 문법에 따라, 인덱스 표기는 <code>_</code>를 먼저 써야 한다. XML 속성은 숫자로 시작할 수 없기 때문이다(몇몇 IDE에선 이를 허용함). 상응하는 익덱스 표기는 <code>&lt;constructor-arg&gt;</code> 요소에서도 사용할 순 있으나 일반적인 방법으로 충분하다.</p>
</blockquote>
<p>실제로 생성자 처리 방식은 인자를 매칭하는데 꽤 효율적이어서, 정말 필요하지 않으면 이름 표기법을 사용하는 것이 좋다.</p>
<h5 id="복합-프로퍼티-이름"><a class="header" href="#복합-프로퍼티-이름">복합 프로퍼티 이름</a></h5>
<p>빈 프로퍼티를 설정할 때, 마지막 프로퍼티 이름을 제외한 경로 값이 <code>null</code>이 아닌 모든 컴포넌트에 대해 복합되거나 중첩판 프로퍼티 이름을 사용할 수 있다. 다음 빈 정의를 고려하라.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;something&quot; class=&quot;things.ThingOne&quot;&gt;
    &lt;property name=&quot;fred.bob.sammy&quot; value=&quot;123&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><code>something</code> 빈은 <code>bob</code> 프로퍼티를 가진 <code>fred</code> 프로퍼티를 가지고 있다. <code>bob</code>은 값이 <code>123</code>인 <code>sammy</code> 프로퍼티를 가지고 있다. 이 작업에서 <code>fred</code>와 <code>bob</code> 프로퍼티가 null이 아니어야 한다. 아니면 <code>NullPointerException</code>이 발생한다.</p>
<h4 id="143-depends-on-사용하기"><a class="header" href="#143-depends-on-사용하기">1.4.3. <code>depends-on</code> 사용하기</a></h4>
<p>만약 다른 빈에서 의존하고 있는 빈이라면 대개 빈이 다른 빈의 프로퍼티로 설정되어 있다는 의미이다. 일반적으로 XML 기반 설정 메타데이터에서 <code>&lt;ref/&gt;</code> 요소를 사용해서 해결한다. 그러나 가끔 빈들 사이에 덜 직접적인 의존성이 있을 때가 있다. 데이터베이스 드라이버 등록과 같은, 트리거되어야 하는 클래스의 정적 초기화 블록이 그 예이다. <code>depends-on</code> 요소는 빈이  명시적으로 하나 이상의 빈이 초기화되어야 함을 강요한다. 다음 예제는 <code>depends-on</code> 속성을 사용해서 단일 빈의 의존성을 표현한다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;
&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
</code></pre>
<p>여러 빈에 대한 의존성을 표현하려면, <code>depends-on</code> 속성에 빈 이름의 리스트를 작성한다. (콤마, 공백 그리고 세미콜론이 유효한 구분자임):</p>
<pre><code class="language-xml">&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager,accountDao&quot;&gt;
    &lt;property name=&quot;manager&quot; ref=&quot;manager&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
&lt;bean id=&quot;accountDao&quot; class=&quot;x.y.jdbc.JdbcAccountDao&quot; /&gt;
</code></pre>
<blockquote>
<p><code>depends-on</code> 속성은 초기화 시점, 그리고 싱글턴 빈의 경우 상응하는 소멸 시점 의존 성의 경우 명시할 수 있다. 먼저 소멸하는 주어진 빈과 <code>depends-on</code> 관계를 정의해서 의존하는 빈은 소멸하는 빈에 앞서 소멸한다. 그러므로 <code>depends-on</code>은 소멸 명령을 제어하기도 한다.</p>
</blockquote>
<h4 id="144-지연-초기화-빈-lazy-initialized-beans"><a class="header" href="#144-지연-초기화-빈-lazy-initialized-beans">1.4.4. 지연 초기화 빈 (Lazy-initialized Beans)</a></h4>
<p>기본적으로 <code>ApplicationContext</code> 구현체는 초기화 과정의 일부로써 싱글턴 빈을 구성하고 생성한다. 이 인스턴스화 전 단계는 바람직하다. 왜냐하면 몇 시간 혹은 며칠 뒤가 아닌 구성 혹은 주위 환경의 에러가 즉각 발생하기 때문이다. 이 행위가 바람직하지 않을 때, 빈 정의에 지연 초기화로 표시함으로써 싱글턴 빈의 인스턴스화 전 단계를 방지할 수 있다. 지연 초기화 빈은 IoC 컨테이너에게 (구동할 때가 아닌) 빈의 요청이 최초 발생할 때 빈을 생성하라고 지시한다.</p>
<p>XML에서 <code>&lt;bean/&gt;</code> 요소의 <code>lazy-init</code> 속성에 의해 행동을 제어한다. 다음 예제를 봐라.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;lazy&quot; class=&quot;com.something.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;
&lt;bean name=&quot;not.lazy&quot; class=&quot;com.something.AnotherBean&quot;/&gt;
</code></pre>
<p>앞선 설정이 <code>ApplicationContext</code>에 의해 사용될 때, <code>lazy</code> 빈은 <code>ApplicationContext</code>가 시작할 때 인스턴스화 되지 않는다. 반면에 <code>not.lazy</code> 빈은 인스턴스화한다.</p>
<p>그러나 지연 초기화 빈이 다른 빈에 의존될 때, <code>ApplicationContext</code>는 지연 초기화 빈을 구동 시점에 생성한다. 왜냐하면 싱글턴의 의존성을 채워야하기 때문이다. 지연 초기화 빈은 지연 초기화 빈이 아닌 곳으로 주입된다.</p>
<p><code>&lt;beans/&gt;</code> 요소의 <code>default-lazy-init</code> 속성을 사용해서 컨테이너 레벨에서 지연 초기화를 제어할 수 있다. 다음 예제를 보자.:</p>
<pre><code class="language-xml">&lt;beans default-lazy-init=&quot;true&quot;&gt;
    &lt;!-- no beans will be pre-instantiated... --&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="145-협력자-자동주입-autowiring-collaborators"><a class="header" href="#145-협력자-자동주입-autowiring-collaborators">1.4.5. 협력자 자동주입 (Autowiring Collaborators)</a></h4>
<p>스프링 컨테이너는 협력하는 빈 사이의 관계를 자동 구성한다. <code>ApplicationContext</code>의 내용을 검사해서 스프링이 자동으로 협력자(다른 빈)을 주입하게 할 수 있다. 자동 구성은 다음과 같은 장점이 있다.:</p>
<ul>
<li>자동 구성을 사용해서 프로퍼티나 생성자 인자를 명시해야 하는 필요를 줄일 수 있다. (<a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions">다른 곳</a>에서 다루는 빈 템플릿과 같은 방식 역시 이와 관련하여 가치있다.)</li>
<li>자동 구성은 객체가 발전함에 따라 설정을 업데이트할 수 있다. 한 예로, 만약 클래스에 의존성을 추가해야 한다면, 설정을 수정할 필요 없이 의존성이 자동으로 충족된다. 그러므로 자동 구성은 개발 단계에서 특히 유용하다(코드가 안정적일 때 명시적으로 연결하는 옵션을 부정하지 않는).</li>
</ul>
<p>XML 기반 설정 메타데이터를 사용할 때(<a href="books/spring/core-01-ioc-container.html#1.4.1.-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85">의존성 주입</a> 참고), <code>&lt;bean/&gt;</code> 요소의 <code>autowire</code> 속성을 통해 빈 정의에서 자동구성 모드를 명시할 수 있다. 자동 구성 모드는 네 가지가 있다. 빈마다 자동 구성 방법을 선택해서 명시할 수 있다. 다음 표는 네 가지 방법을 기술한다.:</p>
<p><strong>표 2. 자동구성 모드</strong></p>
<table><thead><tr><th>모드</th><th>설명</th></tr></thead><tbody>
<tr><td><code>no</code></td><td>(기본설정) 자동구성을 하지 않는다. 빈 참조는 <code>ref</code> 요소에 의해 정의되어야 한다. 대규모 배포에서 기본 설정을 바꾸는 것은 권고되지 않는다. 왜냐하면 협력자를 명시하는 것은 통제력과 명확성이 향상되기 때문이다. 이는 어느정도 시스템의 구조를 문서화한다.</td></tr>
<tr><td><code>byname</code></td><td>프로퍼티 이름으로 자동 구성한다. 스프링은 자동 구성해야하는 프로퍼티와 동일한 이름을 가진 빈을 탐색한다. 예를 들어 빈 정의에 <code>master</code> 프로퍼티를 포함하고 이름으로 자동 구성하게 설정되어 있으면, 스프링은 <code>master</code>라는 이름을 가진 빈 정의를 찾고 프로퍼티를 설정할 때 그 빈을 사용한다.</td></tr>
<tr><td><code>byType</code></td><td>컨테이너에서 자동구성하려는 프로퍼티가 타입 당 하나의 빈만 존재할 때 사용하자. 만약 여러개으이 빈이 존재한다면, 치명적인 예외가 발생할 것이다. 만약 일치하는 빈이 존재하지 않으면, 아무 일도 일어나지 않는다. (프로퍼티는 설정되지 않음)</td></tr>
<tr><td><code>constructor</code></td><td><code>byType</code>과 유사하지만 생성자 인자에 적용된다. 만약 생성자 인자 타입의 빈이 정확히 하나가 아니라면 치명적인 오류가 발생한다.</td></tr>
</tbody></table>
<h5 id="자동-구성의-제약과-단점"><a class="header" href="#자동-구성의-제약과-단점">자동 구성의 제약과 단점</a></h5>
<p>자동 구성은 프로젝트 전체에서 일관되게 사용할 때 잘 작동한다. 만약 자동 구성이 일반적으로 사용되지 않는다면, 개발자는 몇몇 빈 정의에서 구성할 때 사용하는건지 혼란스러울 것이다.</p>
<p>자동 구성의 제약과 단점에 대해 고려하라.:</p>
<ul>
<li>프로퍼티와 생성자 인자의 명시적 의존성 설정은 항상 자동 구성을 우선한다. 원시 타입, 스트링, 클래스, 배열 등과 같은 단순 프로퍼티는 자동 구성할 수 없다. 이는 설계상의 제약이다.</li>
<li>자동 구성은 명시적 구성보다 덜 정확하다. 앞선 표에 기술한 것 처럼 스프링이 예상치 못한 결과를 가진 모호한 경우를 피하려고 애쓴다. 스프링이 관리하는 객체들 사이의 관계는 명시적으로 문서화되지 않을 것이다.</li>
<li>스프링 컨테이너로부터 문서를 생성하는 도구는 구성이 불가능할 수 있다.</li>
<li>컨테이너의 여러 빈 정의들은 세터 메서드나 생성자 인자에 의해 타입이 자동 구성해야 할 빈과 일치해야 한다. 배열, 컬렉션 혹은 맵 인스턴스의 경우 이는 문제가 아니지만, 단일 값을 가지는 경우, 모호함이 의도한대로 해결되지 않을 수 있다. 만약 유일한 빈 정의가 없다면, 예외가 발생할 것이다.</li>
</ul>
<p>마지막 시나리오에서 여러 옵션이 있다:</p>
<ul>
<li>명시적인 구성으로 바꾼다.</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#beans-factory-autowire-candidate">다음 섹션</a>에서 기술할, 자동 구성 속성을 <code>false</code>로 설정하여 자동 구성을 회피한다.</li>
<li>하나의 빈 정의를 <code>&lt;bean/&gt;</code> 요소의 <code>primary</code> 속성을 true로 설정하여 우선 순위로 지정한다.</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#beans-annotation-config">어노테이션 기반 컨테이너 설정</a>에서 기술할, 어노테이션 기반 설정으로 더욱 세밀한 제어가 가능하게 구현한다.</li>
</ul>
<h5 id="자동-구성으로부터-빈-제외하기"><a class="header" href="#자동-구성으로부터-빈-제외하기">자동 구성으로부터 빈 제외하기</a></h5>
<p>빈마다 자동 구성으로부터 설정을 비활성화 할 수 있다. 스프링의 XML 포맷에서 <code>&lt;bean/&gt;</code> 요소의 <code>autowire-candidate</code> 속성을 <code>false</code>로 설정한다. 컨테이너는 특정 빈 정의를 (<code>@Autowired</code>와 같은 어노테이션 스타일 설정을 포함해서) 자동 구성하지 못하도록 한다.</p>
<blockquote>
<p><code>autowire-candidate</code> 속성은 타입 기반 자동구성에서만 적용하도록 설계되었다. 이는, 특정 빈이 자동 구성 빈이 아니라고 표시되어 있어도, 이름에 의한 참조에선 적용되지 않는다. 그럼에도 불구하고 결과적으로 이름에 의한 자동 구성은 이름이 일치해도 주입될 것이다.</p>
</blockquote>
<p>빈 이름 패턴 매칭을 기반으로 자동 구성 빈을 제한할 수 있다. 탑 레벨 <code>&lt;beans/&gt;</code> 요소는 <code>default-autowire-candidates</code> 속성 내에 하나 이상의 패턴을 허용한다. 예를 들어, <code>Repository</code>로 끝나는 이름을 가진 빈을 자동 구성 요소에서 제외하려면, <code>*Repository</code> 값을 패턴에 설정한다. 여러 패턴을 사용하려면, 쉼표(<code>,</code>)를 구분자로 사용한다. 빈 정의 <code>autowire-candidate</code> 속성애 <code>true</code>나 <code>false</code>같은 명시적인 값은 항상 우선한다. 특정 빈에선 패턴 매칭 규칙은 적용되지 않는다.</p>
<p>이런 기술은 특정 빈이 자동 구성에 의해 주입되길 원하지 않을 때 유용하다. 이는 자동 구성을 사용해서 제외된 빈 자체를 구성할 수는 없다. 빈 스스로 자동구성할 빈의 후보가 될 순 없다.</p>
<h4 id="146-메서드-주입-method-injection"><a class="header" href="#146-메서드-주입-method-injection">1.4.6. 메서드 주입 (Method Injection)</a></h4>
<p>대개의 애플리케이션 시나리오에서, 대부분의 빈들은 싱글턴이다. 싱글턴 빈이 다른 싱글턴 빈이나 싱글턴이 아닌 빈들과 협력해야 할 때, 보통 다른 빈의 프로퍼티로 의존성을 다룰 것이다. 빈 라이프사이클이 상이할 때 문제가 발생할 것이다. 싱글턴 빈 A가 각 메서드를 호출할 때마다 프로토타입 빈 B를 사용한다고 가정하자. 컨테이너는 싱글턴 빈 A를 1회 생성한다. 그러므로 프로퍼티를 설정할 기회는 오로지 한 번이다. 컨테이너는 필요할 때 마다 새로운 빈 인스턴스 B를 제공할 수 없다.</p>
<p>솔루션은 어떤 제어 역전을 선행하는 것이다. <code>ApplicationContext</code> 인터페이스를 구현하고 <code>getBean(&quot;B&quot;)</code> 코드로 빈 인스턴스 B가 필요할 때마다 컨테이너에게 요청해서 빈 인스턴스 A를 만들 수 있다. 다음 예제는 이런 접근을 보여준다.:</p>
<pre><code class="language-java">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre>
<p>앞선 예제는 바람직하지 않다, 왜냐하면 비즈니스 코드가 스프링 프레임워크를 인지하고 결합되어 있기 때문이다. 스프링 IoC 컨테이너의 기능인 메서드 주입은 이런 상황을 깔끔하게 정리한다.</p>
<blockquote>
<p>메서드 주입의 동기에 대해 알고 싶다면 <a href="https://spring.io/blog/2004/08/06/method-injection/">이 블로그</a>를 참고하라.</p>
</blockquote>
<h5 id="탐색-메서드-주입-lookup-method-injection"><a class="header" href="#탐색-메서드-주입-lookup-method-injection">탐색 메서드 주입 (Lookup Method Injection)</a></h5>
<p>탐색 메서드 주입은 메서드를 컨테이너가 관리하는 빈의 메서드를 다른 빈을 이름으로 탐색해서 반환하게 하는 컨테이너의 기능이다. 일반적으로 탐색은 프로토타입 빈도 포함한다. 스프링 프레임워크는 CGLIB 라이브러리의 바이트 코드 생성 기능을 사용해서 메서드 주입을 구현한다. 동적으로 메서드를 오버라이드하는 서브클래스를 생성한다.</p>
<blockquote>
<ul>
<li>동적으로 서브클래스를 생성하는 작업을 할 때, <code>final</code> 클래스, <code>final</code> 메서드는 오버라이드 할 수 없다.</li>
<li><code>abstract</code> 메서드를 가진 클래스의 단위테스트는 클래스 자신의 서브클래스를 생성하고 <code>abstract</code> 메서드에 대한 stub을 구현해야 한다.</li>
<li>구체 메서드는 구체 클래스 탐색을 위한 컴포넌트 스캔을 위해 필요하다.</li>
<li>추가적인 제한사항으로 탐색 메서드가 팩토리 메서드에서 동작하지 않으며, 특히 <code>@Bean</code> 메서드에서 작동하지 않는다. 왜냐하면 이 경우에 컨테이너는 인스턴스를 생성할 책임이 없어서 런타임 시점에 서브클래스를 생성할 수 없다.</li>
</ul>
</blockquote>
<p><code>CommandManager</code> 클래스의 경우, 스프링 컨테이너는 동적으로 <code>createCommand()</code> 메서드를 오버라이드해서 구현한다. <code>CommandManager</code> 클래스는 스프링 의존성이 없다.:</p>
<pre><code class="language-java">package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
</code></pre>
<p>주입될 메서드를 포함하는 클라이언트 클래스 (이 경우엔 <code>CommandManager</code> 클래스) 는 다음과 같은 형식의 시그니쳐가 필요하다.</p>
<pre><code class="language-plain">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);
</code></pre>
<p>만약 추상 메서드라면, 동적으로 생성된 서브클래스가 메서드를 구현한다. 아니면, 원래 클래스에 정의된 구체 메서드를 덮어쓴다. 다음 예를 고려해라.:</p>
<pre><code class="language-xml">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;
    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><code>commandManager</code>로 식별되는 빈은 <code>myCommand</code> 빈이 필요 할 때마다 <code>createCommand()</code> 메서드를 호출한다. 실제로 필요한 경우 <code>myCommand</code> 빈을 프로토타입으로 다뤄야한다. 만약 싱글턴이라면, 매번 동일한 인스턴스인 <code>myCommand</code> 빈이 반환될 것이다.</p>
<p>어노테이션 기반 컴포넌트 모델의 경우, 다음 예제와 같이 <code>@Lookup</code> 어노테이션을 통해 탐색 메서드를 선언할 수 있다.:</p>
<pre><code class="language-java">public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup(&quot;myCommand&quot;)
    protected abstract Command createCommand();
}
</code></pre>
<p>관용적으로, 탐색 메서드의 반환 타입으로 타겟 빈을 식별할 수 있다. </p>
<pre><code class="language-java">public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}
</code></pre>
<p>추상 클래스가 기본적으로 무시되는 스프링 컴포넌트 스캔 규칙에 호환되려면, 일반적으로 어노테이션 탐색 메서드는 구체 스텁 구현을 통해 선언해야 한다. 이 제한은 명시적으로 등록되었거나 명시적으로 클래스 등록된 빈 클래스엔 적용하지 않는다.</p>
<p>상이한 범위가 적용된 타겟 빈에 접근하는 다른 방법으로 <code>ObjectFactory</code>/<code>Provider</code> 주입 포인트가 있다. <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-other-injection">Scoped Beans as Dependencies</a> 부분을 참고하라.<br />
<code>org.springframework.beans.factory.config</code> 패키지의 <code>ServiceLocatorFactoryBean</code>도 유용하다.</p>
<h5 id="임의의-메서드-교체-arbitrary-method-replacement"><a class="header" href="#임의의-메서드-교체-arbitrary-method-replacement">임의의 메서드 교체 (Arbitrary Method Replacement)</a></h5>
<p>탐색 메서드 주입보다 덜 유용한 방법으로 빈의 또다른 메서드 구현을 통한 임의의 메서드 교체가 있다. 실제로 이 기능이 필요하지 않으면 나머지 부분을 건너뛰어도 된다.</p>
<p>XML 기반 설정 메타데이터에서, <code>replaced-method</code> 요소를 사용해서 배치된 빈에 존재하는 메서드 구현을 다른 것으로 교체할 수 있다. 오버라이드하려는 <code>computeValue</code> 메서드를 가진 다음 클래스를 살펴보아라.:</p>
<pre><code class="language-java">public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
</code></pre>
<p><code>org.springframework.beans.factory.support.MethodReplacer</code> 인터페이스를 구현한 클래스는 새 메서드 정의를 제공한다. 다음 예를 보자.:</p>
<pre><code class="language-java">/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
</code></pre>
<p>원래 클래스를 배포하고 메서드 오버라이드를 명시하는 빈 정의 예제는 다음과 같다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;
</code></pre>
<p>하나 이상의 <code>&lt;arg-type/&gt;</code> 요소를 <code>&lt;replaced-method/&gt;</code> 요소 내에 사용해서 오버라이드하려는 메서드의 시그니쳐를 지정할 수 있다. 인자에 대한 시그니쳐는 클래스 내에 존재하는 오직 메서드가 오버로드되어 여러 경우가 존재할 때만 필요하다. 편의상 인자의 타입 문자열은 적절한 타입 명의 부분문자열이 될 수 있다. 예를 들어 <code>java.lang.String</code>은 다음과 일치한다.:</p>
<pre><code class="language-plain">java.lang.String
String
Str
</code></pre>
<p>인자의 수는 가끔 개별 가능한 선택을 구별하기에 충분하기 때문에, 이 축약어는 타이핑을 줄일 수 있다.</p>
<h3 id="15-빈-범위"><a class="header" href="#15-빈-범위">1.5. 빈 범위</a></h3>
<p>빈 정의를 작성할 때, 빈 정의의 클래스 실제 인스턴스를 생성하는 레시피를 작성한다. 빈 정의가 레시피라는 아이디어는 중요하다, 이는 하나의 레시피로 많은 객체 인스턴스를 만들 수 있다는 의미이다. </p>
<p>특정 빈 정의로 생성된 객체에 연결할 의존성이나 설정 값과 같은 것뿐만이 아니라, 객체의 범위까지 제어할 수 있다. 이 접근은 강력하고 유연하다. 자바 클래스 레벨에서의 객체 범위를 다루지 않고, 작성한 설정을 통해 객체의 범위를 선택할 수 있기 때문이다. 빈은 많은 범위 중 하나를 선택하여 정의할 수 있다. 스프링 프레임워크는 여섯 종류의 범위를 제공한다, 그 중 네 가지는 웹과 관련된 <code>ApplicationContext</code>에서만 사용 가능하다. 또한 커스텀 범위를 만들 수도 있다.</p>
<p>다음 표는 제공되는 범위를 기술한 것이다.</p>
<p><strong>표 3. 빈 범위</strong></p>
<table><thead><tr><th>범위</th><th>설명</th></tr></thead><tbody>
<tr><td>싱글턴(singleton)</td><td>(기본) 스프링 IoC 컨테이너마다 빈 정의당 하나의 객체 인스턴스만을 가진다.</td></tr>
<tr><td>프로토타입(prototype)</td><td>빈 정의당 여러 객체 인스턴스를 가질 수 있다.</td></tr>
<tr><td>요청(request)</td><td>빈 정의당 단일 HTTP 요청의 라이프사이클을 범위로 가진다. 각각의 HTTP 요청은 빈 정의로 생성된 하나의 인스턴스 빈을 가진다. 오직 웹 관련 <code>ApplicationContext</code>에서만 유효하다.</td></tr>
<tr><td>세션(session)</td><td>빈 정의당 HTTP <code>Session</code>의 라이프사이클을 범위로 가진다. 오직 웹 관련 <code>ApplicationContext</code>에서만 유효하다.</td></tr>
<tr><td>애플리케이션(application)</td><td>빈 정의당 <code>ServletContext</code>의 라이프사이클을 범위로 가진다. 오직 웹 관련 <code>ApplicationContext</code>에서만 유효하다.</td></tr>
<tr><td>웹소켓(websocket)</td><td>빈 정의당 <code>WebSocket</code>의 라이프사이클을 범위로 가진다. 오직 웹 관련 <code>ApplicationContext</code>에서만 유효하다.</td></tr>
</tbody></table>
<blockquote>
<p>스프링 3.0부터, 쓰레드 범위가 사용 가능하지만 기본적으로 등록되어있진 않다. 더 만흥ㄴ 정보는 <code>SimpleThreadScope</code> 문서를 살펴봐라. 이 범위를 등록하는 방법이나 다른 커스텀 범위에 대한 내용은 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-custom-using">커스텀 범위 사용하기</a>를 살펴봐라.</p>
</blockquote>
<h4 id="151-싱글턴-범위"><a class="header" href="#151-싱글턴-범위">1.5.1. 싱글턴 범위</a></h4>
<p>오직 싱글턴 빈 하나의 인스턴스만이 관리되고, 스프링 컨테이너에 의해 빈에 대한 모든 요청이 하나의 빈 인스턴스만 반환한다.</p>
<p>빈을 정의하고 범위가 싱글턴일 때, 스프링 IoC 컨테이너는 빈 정의에 의해 객체당 정확히 하나의 인스턴스만 생성한다. 이 인스턴스는 싱글턴 빈 캐시에 저장된다. 그리고 이후 빈에 대한 요청과 참조는 캐시된 객체를 반환한다. 다음은 싱글턴 범위가 동작하는 방법을 나타낸다.:</p>
<p><img src="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/images/singleton.png" alt="싱글턴 작동원리" /></p>
<p>싱글턴 빈에 대한 스프링 컨셉은 GoF 디자인 패턴에 정의된 싱글턴과 다르다. GoF 싱글턴은 객체의 범위를 하드코드로 제한하고 클래스로더 당 특정 클래스의 하나의 인스턴스만 가지게 한다. 스프링 싱글턴의 범위는 컨테이너 당, 빈 당 하나로 제한된다. 이는 단일 스프링 컨테이너에서 특정 클래스의 하나의 빈을 정의한다면, 스프링 컨테이너는 빈 정의에 의해 하나의 클래스의 인스턴스를 생성한다는 것이다. 싱글턴 범위는 스프링 기본 범위이다. XML로 싱글턴 빈을 정의하려면, 다음 예제처럼 정의하면 된다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot;/&gt;

&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;
</code></pre>
<h5 id="152-프로토타입-범위"><a class="header" href="#152-프로토타입-범위">1.5.2. 프로토타입 범위</a></h5>
<p>싱글턴이 아닌 프로토타입 범위는 특정 빈에 대한 매 요청마다 새로운 빈 인스턴스를 생성한다. 빈이 다른 빈에 주입되거나 <code>getBean()</code> 메서드로 컨테이너에게 호출해서 빈을 요청한다. 규칙에 따라, 상태를 가진(stateful) 빈은 프로토타입 범위를 사용해야 하고, 상태가 없는(stateless) 빈은 싱글턴 범위를 사용해야 한다.</p>
<p>다음 다이어그램은 스프링 프로토타입 범위를 나타낸다.:</p>
<p><img src="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/images/prototype.png" alt="prototype" /></p>
<p>(Data Access Object(DAO)는 보통 프로토타입으로 구성되지 않는다. 왜냐하면 DAO는 특정 상태를 가지고 있지 않기 때문이다.)</p>
<p>다음 예는 XML에서 프로토타입 빈을 정의한다.:</p>
<pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<p>다른 범위와 대조적으로, 스프링은 프로토타입 빈의 모든 라이프사이클을 관리하지 않는다. 컨테이너는 프로토타입 객체를 인스턴스화하고, 구성한다. 그리고 빈을 클라이언트에게 건낸다. 그리고 이 과정에서 아무런 기록이 없다. 그러므로 모든 범위의 객체에서 초기화 라이프사이클 콜백 메서드가 호출됨에도, 프로토타입의 경우 소멸(destsruction) 콜백이 호출되지 않는다. 클라이언트 코드는 프로토타입 객체에 대해 스스로 정리해야 하고, 객체가 소유한 자원을 해제해야 한다. 스프링 컨테이너가 프로토타입 빈을 해제하려면 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-extension-bpp">bean post-processor</a>를 사용해라.  이는 정리해야 할 빈의 참조를 가지고 있다.</p>
<p>어떤 점에서 스프링 컨테이너 프로토타입 빈의 역할은 자바 <code>new</code> 연산자를 대체하는 것이다.모든 생명주기는 클라이언트가 관리해야 한다. (스프링 컨테이너 빈의 생명주기는 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle">생명주기 콜백</a>을 참고하라.)</p>
<blockquote>
<p>Work In Process</p>
</blockquote>
<h5 id="153-프로토타입-빈을-의존하는-싱글턴-빈"><a class="header" href="#153-프로토타입-빈을-의존하는-싱글턴-빈">1.5.3. 프로토타입 빈을 의존하는 싱글턴 빈</a></h5>
<h5 id="154-요청-세션-애플리케이션-웹소켓-범위"><a class="header" href="#154-요청-세션-애플리케이션-웹소켓-범위">1.5.4. 요청, 세션, 애플리케이션, 웹소켓 범위</a></h5>
<h5 id="155-커스텀-범위"><a class="header" href="#155-커스텀-범위">1.5.5. 커스텀 범위</a></h5>
<h3 id="16-빈-생태계-커스터마이징"><a class="header" href="#16-빈-생태계-커스터마이징">1.6. 빈 생태계 커스터마이징</a></h3>
<h3 id="17-빈-정의-상속"><a class="header" href="#17-빈-정의-상속">1.7. 빈 정의 상속</a></h3>
<h3 id="18-컨테이너-확장-지점"><a class="header" href="#18-컨테이너-확장-지점">1.8. 컨테이너 확장 지점</a></h3>
<h3 id="19-어노테이션-기반-컨테이너-설정"><a class="header" href="#19-어노테이션-기반-컨테이너-설정">1.9. 어노테이션 기반 컨테이너 설정</a></h3>
<h3 id="110-클래스패스-스캐닝과-컴포넌트-관리"><a class="header" href="#110-클래스패스-스캐닝과-컴포넌트-관리">1.10. 클래스패스 스캐닝과 컴포넌트 관리</a></h3>
<h3 id="111-jsr-330-표준-어노테이션-사용하기"><a class="header" href="#111-jsr-330-표준-어노테이션-사용하기">1.11. JSR 330 표준 어노테이션 사용하기</a></h3>
<h3 id="112-java-기반-컨테이너-설정"><a class="header" href="#112-java-기반-컨테이너-설정">1.12. Java 기반 컨테이너 설정</a></h3>
<h3 id="113-환경-추상화"><a class="header" href="#113-환경-추상화">1.13. 환경 추상화</a></h3>
<h3 id="114-loadtimeweaver-등록하기"><a class="header" href="#114-loadtimeweaver-등록하기">1.14. LoadTimeWeaver 등록하기</a></h3>
<h3 id="115-applicationcontext의-추가-기능"><a class="header" href="#115-applicationcontext의-추가-기능">1.15. ApplicationContext의 추가 기능</a></h3>
<h3 id="116-beanfactory"><a class="header" href="#116-beanfactory">1.16. BeanFactory</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="운영-체제"><a class="header" href="#운영-체제">운영 체제</a></h1>
<p>운영체제와 셸 명령어 위주의 내용입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="커널-kernel"><a class="header" href="#커널-kernel">커널 (Kernel)</a></h1>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램으로, <strong>시스템의 모든 것(CPU, Memory, Devices, ...)</strong> 을 통제한다.</p>
<p>대부분의 시스템에서 부팅할 때, 부트로더 이후에 로드하는 프로그램 중의 하나이다. 커널은 소프트웨어로부터의 입출력 요청과 같은 부팅과정을 관리한다. </p>
<h2 id="역할"><a class="header" href="#역할">역할</a></h2>
<ul>
<li>보안: 컴퓨터 하드웨어와 프로세스의 보안을 책임진다.</li>
<li>자원 관리: 한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원할하게 한다.</li>
<li>추상화: 운영 체제의 복잡한 내부를 감추고 깔끔하고 일관성 있는 <strong>인터페이스</strong>를 제공하기 위해 하드웨어 추상화를 한다. 이는 프로그래머가 여러 장비에서 작동하는 프로그램을 개발하는 것을 돕는다. </li>
</ul>
<h2 id="종류"><a class="header" href="#종류">종류</a></h2>
<ul>
<li>단일형 커널: 커널의 다양한 서비스 및 고수준의 하드웨어 추상화를 하나로 묶은 것, OS개발자 입장에서 유지 보수가 어렵지만 성능이 좋다.
<ul>
<li>단일형 커널의 예: Linux, Unix, 윈도9X 계열</li>
</ul>
</li>
<li>마이크로 커널: 하드웨어 추상화에 대한 간결한 작은 집합을 제공하고, 더 많은 기능은 서버 응용 소프트웨어를 통해 제공
<ul>
<li>마이크로 커널의 예: 미닉스</li>
</ul>
</li>
<li>하이브리드 커널: 모노리틱 커널과 마이크로 커널의 혼합형</li>
<li>나노 커널
<ul>
<li>커널 코드의 양이 매우 작은 커널</li>
<li>OS 하위의 하이퍼바이저 레이어</li>
<li>하드웨어 추상화 계층(HAL)</li>
</ul>
</li>
</ul>
<h2 id="참고"><a class="header" href="#참고">참고</a></h2>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%84%90_(%EC%BB%B4%ED%93%A8%ED%8C%85)">커널 - 위키백과</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="posix"><a class="header" href="#posix">POSIX</a></h1>
<h2 id="tldr-1"><a class="header" href="#tldr-1">TL;DR</a></h2>
<p>POSIX는 서로 다른 UNIX OS의 공통 API를 정리한 IEEE 애플리케이션 인터페이스 규격이다. 목적은 이식성이 높은 유닉스 응용 프로그램 개발하는 것이다.</p>
<h2 id="posix의-내용"><a class="header" href="#posix의-내용">POSIX의 내용</a></h2>
<p>POSIX엔 아래 외에 다양한 분야의 규격이 존재한다.</p>
<ul>
<li>커널로의 C 언어 인터페이스 시스템 콜</li>
<li>프로세스 환경</li>
<li>파일과 디렉토리</li>
<li>시스템 데이터베이스</li>
<li>tar 압축 포맷</li>
</ul>
<h2 id="리눅스와-포직스"><a class="header" href="#리눅스와-포직스">리눅스와 포직스</a></h2>
<p>리눅스는 포직스 호환 운영 체제 커널을 목표로 개발되었다.</p>
<h2 id="posix-인증-운영-체제들"><a class="header" href="#posix-인증-운영-체제들">POSIX 인증 운영 체제들</a></h2>
<p><a href="https://en.wikipedia.org/wiki/POSIX#POSIX-certified">위키백과</a>에 따르면 AIX, HP-UX, macOS, Solaris 등이 POSIX 표준을 따르는 운영 체제로 알려져있다. 대부분의 리눅스 배포판은 POSIX 호환성 인증은 없지만, 대부분 준수하는 것으로 알려져있다.</p>
<h2 id="ms-windows를-위한-posix"><a class="header" href="#ms-windows를-위한-posix">MS Windows를 위한 POSIX</a></h2>
<ul>
<li>Cygwin: MS Windows를 위한 가능한 큰 POSIX 호환 개발환경과 런타임 환경을 제공한다. Linux 호환 Layer를 구성하기 때문에, MinGW에 비해 Unix 호환성이 높고 안정적으로 작동한다.</li>
<li>MinGW: 쵝소한의 POSIX 환경을 제공한다. Windows Native로 동작하기 때문에 Cygwin에 비해 성능이 좋다.</li>
<li>Windows Subsystem for Linux: Ubuntu 이미지를 통해 리눅스 실행환경을 제공한다. Windows 10부터 지원</li>
</ul>
<h2 id="signal-ipc-inter-process-communication"><a class="header" href="#signal-ipc-inter-process-communication">Signal (IPC, Inter-Process Communication)</a></h2>
<p>Signal, 유닉스 신호는 POSIX 호환 운영 체제에서 쓰이는 프로세스 간의 통신이다. </p>
<h3 id="신호-보내기"><a class="header" href="#신호-보내기">신호 보내기</a></h3>
<ul>
<li><code>Ctrl-C</code> (SIGINT): 기본적으로 프로세스를 종료</li>
<li><code>Ctrl-Z</code> (SIGTSTP): 프로세스가 실행을 유예</li>
<li><code>Ctrl-\</code> (SIGQUIT): 프로세스를 종료시킨 뒤 코어를 덤프</li>
<li><code>Ctrl-T</code> (SIGINFO): (모든 유닉스에서 지원하진 않음) 명령에서 지원하는 경우 운영 체제가 실행 중인 명령에 대한 정보를 표시</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell"><a class="header" href="#shell">Shell</a></h1>
<h2 id="tldr-2"><a class="header" href="#tldr-2">TL;DR</a></h2>
<p>운영 체제 기능과 서비스를 구현하는 인터페이스를 제공하는 프로그램이다. <strong>사용자</strong>와 <strong>운영 체제의 커널</strong> 사이의 인터페이스를 감싸는 프로그램이기 때문에 셸이란 이름이 붙었다.</p>
<h2 id="셸의-목록"><a class="header" href="#셸의-목록">셸의 목록</a></h2>
<h3 id="cli-1"><a class="header" href="#cli-1">CLI</a></h3>
<ul>
<li>Unix
<ul>
<li>sh - ash, bash</li>
<li>csh - tsch</li>
<li>ksh</li>
<li>zsh</li>
</ul>
</li>
<li>COMMAND.COM: MS-DOS 용</li>
<li>CMD.EXE: Windows NT 용</li>
</ul>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<ul>
<li>윈도 탐색기: MS Windows 계열</li>
<li>매킨토시 파인더</li>
<li>X 윈도 시스템</li>
</ul>
<h2 id="참고-1"><a class="header" href="#참고-1">참고</a></h2>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EC%85%B8">셸 - 위키백과</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="심볼릭-링크-하드-링크"><a class="header" href="#심볼릭-링크-하드-링크">심볼릭 링크, 하드 링크</a></h1>
<h2 id="심볼릭-링크symbolic-link"><a class="header" href="#심볼릭-링크symbolic-link">심볼릭 링크(symbolic link)</a></h2>
<p>소프트 링크(soft link)라고도 한다. 윈도우의 바로가기와 비슷한 개념으로 파일을 복사할 필요 없이 사용 가능하고, 원본 파일이 업데이트될 경우 링크된 파일에 바로 적용된다. 하나의 파일을 여러 사용자가 사용하거나 동일한 라이브러리를 구성해야 할 경우 사용된다.
<code>ls</code> 명령어를 사용해서 심볼릭 링크를 보면 아래와 같이 실제 파일 혹은 프로세스가 존재하는 위치를 가리킨다.</p>
<pre><code class="language-sh">$ ln -s /home/ubuntu/workspace/nginx /etc/nginx

$ ls /etc/ | grep nginx
lrwxrwxrwx  1 root root      28 Dec 18 06:13 nginx -&gt; /home/ubuntu/workspace/nginx
</code></pre>
<h2 id="하드-링크hard-link"><a class="header" href="#하드-링크hard-link">하드 링크(hard link)</a></h2>
<p>하드 링크는 링크된 파일의 내용이 변경된 경우에 원본 파일도 동일하게 변경된다. 하나의 파일을 가리키는 링크가 하나 더 생기는 것이다. 그러므로 파일이 삭제되어도 남아있는 링크가 있다면 자원에 접근할 수 있다.</p>
<pre><code class="language-sh">$ echo hello &gt; hello
$ cat hello
hello
$ ln hello bye
$ echo bye &gt;&gt; bye
$ cat bye
hello
bye
$ cat hello
hello
bye
$ rm hello
$ cat bye
hello
bye
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="셸-명령어-목록"><a class="header" href="#셸-명령어-목록">셸 명령어 목록</a></h1>
<h2 id="chsh"><a class="header" href="#chsh">chsh</a></h2>
<p>기본 사용 셸을 변경할 때 사용한다.</p>
<pre><code class="language-sh">$ chsh -s /bin/zsh
</code></pre>
<h2 id="which"><a class="header" href="#which">which</a></h2>
<p>프로그램의 위치를 리턴한다.</p>
<pre><code class="language-sh">$ which mdbook
/home/ubuntu/.cargo/bin/mdbook
</code></pre>
<h2 id="uname"><a class="header" href="#uname">uname</a></h2>
<p>현재 시스템의 정보를 출력한다. 플래그 없이 사용하는 경우 -s(커널 명) 플래그를 사용하는 것과 같다.</p>
<pre><code class="language-sh">$ uname -a # 모든 정보 표시

Linux a2f3d1dd-5b17-e822-f4c8-c7bc7075f1c3 3.13.0-100-generic #147-Ubuntu SMP Tue Oct 18 16:48:51 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aix-모니터링-명령어들"><a class="header" href="#aix-모니터링-명령어들">AIX 모니터링 명령어들</a></h1>
<p>AIX 자원 모니터링을 위한 셸 스크립트들입니다.</p>
<h2 id="process"><a class="header" href="#process">Process</a></h2>
<pre><code class="language-sh">echo `ps -ef | grep &quot;java&quot; | wc -l`
</code></pre>
<h2 id="cpu-사용량"><a class="header" href="#cpu-사용량">CPU 사용량</a></h2>
<pre><code class="language-sh">#!/bin/ksh

#create timestamp
timestamp=`date +%Y%m%d_%H%M%S`

#echo &quot;Gathering CPU usage : &quot;$timestamp

#create target file name
target='./dat/cpu_'$timestamp'.out'
#echo 'file path is '$target

#bulk=`vmstat`

#count
cnt=3
#create target file to gather vmstat information
vmstat 1 $cnt &gt; $target

user=`tail -n $cnt $target | awk '{print $14}'`
sys=`tail -n $cnt $target | awk '{print $15}'`
idle=`tail -n $cnt $target | awk '{print $16}'`

sum=0
for KK in $idle
do
#   echo 'idle: '$KK
   let &quot;sum=sum+$KK&quot;
done
let &quot;avg=sum/$cnt&quot;
let &quot;avg=100-avg&quot;

#echo 'Average idle of CPU usage: '$avg

echo $avg

#echo &quot;Job ends...&quot;
</code></pre>
<h2 id="메모리-사용량"><a class="header" href="#메모리-사용량">메모리 사용량</a></h2>
<pre><code class="language-sh">#!/bin/ksh

# getMEMusage.sh


# Physical Memory
#phy=`svmon -G |grep memory |perl -ane 'printf&quot;%0.1f \n&quot;, 100 - ( ( $F[3] / $F[1] ) * 100 )'`

# Paging space
#pg=`svmon -G |grep 'pg space' |perl -ane 'printf&quot;%0.1f \n&quot;, ( ( $F[3] / $F[2] ) * 100 )'`

#echo &quot;Physical MEM usage: &quot;$phy
#echo &quot;Paging Space usage: &quot;$pg
#echo $phy&quot;, &quot;$pg

###########################
total=`svmon -G -O unit=MB | grep &quot;memory&quot; | awk '{print $2}'`
work=`svmon -G -O unit=MB | grep &quot;in use&quot; | awk '{print $3}'`

#echo &quot;total: &quot;$total
#echo &quot;work: &quot;$work

used=`echo &quot;$work $total&quot; | awk '{printf &quot;%.2f&quot;, $1/$2*100}'`

#echo &quot;MEM usage(%): &quot;$used
echo $used

# Job finished...
</code></pre>
<h2 id="디스크-사용량"><a class="header" href="#디스크-사용량">디스크 사용량</a></h2>
<pre><code class="language-sh">#!/bin/ksh
# getDiskUsage.sh

#target: grep으로 검색할 경로
target=$1

#disk usage
disk=`df -gi | grep &quot;.*&quot;$target&quot;$&quot; | awk '{print $4}' | tr -d '\%'`

echo $disk

#echo &quot;Job ends...&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-커맨드-프롬프트에서-환경변수-설정하기"><a class="header" href="#windows-커맨드-프롬프트에서-환경변수-설정하기">Windows 커맨드 프롬프트에서 환경변수 설정하기</a></h1>
<h2 id="환경변수-조회"><a class="header" href="#환경변수-조회">환경변수 조회</a></h2>
<p><code>set</code> 명령으로 시스템/사용자 환경변수 모두 조회할 수 있다.</p>
<pre><code class="language-cmd">set
</code></pre>
<p>구분하여 보려면, 아래의 명령어로</p>
<h3 id="시스템-환경변수-조회"><a class="header" href="#시스템-환경변수-조회">시스템 환경변수 조회</a></h3>
<pre><code class="language-cmd">reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&quot;
</code></pre>
<h3 id="사용자-환경변수-조회"><a class="header" href="#사용자-환경변수-조회">사용자 환경변수 조회</a></h3>
<pre><code class="language-cmd">reg query HKEY_CURRENT_USER\Environment
</code></pre>
<h2 id="setx-명령으로-변수-설정"><a class="header" href="#setx-명령으로-변수-설정"><code>setx</code> 명령으로 변수 설정</a></h2>
<pre><code class="language-cmd">setx \m coffee &quot;starbucks&quot;
</code></pre>
<h2 id="chocolatey의-refreshenv-명령으로-환경변수-refresh"><a class="header" href="#chocolatey의-refreshenv-명령으로-환경변수-refresh">chocolatey의 <code>RefreshEnv</code> 명령으로 환경변수 refresh</a></h2>
<pre><code class="language-cmd">RefreshEnv
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux의-hostid"><a class="header" href="#linux의-hostid">Linux의 <code>hostid</code></a></h1>
<ul>
<li>hostid Man page: https://linux.die.net/man/1/hostid</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-시작하기"><a class="header" href="#docker-시작하기">Docker 시작하기</a></h1>
<p>Docker 공식 문서 <a href="https://docs.docker.com/get-started/">Get started with Docker</a>를 번역한 내용입니다. 직접 실습하면서 결과를 적어두기 때문에 공식 웹사이트의 문서와 다를 수 있습니다.</p>
<h2 id="차례"><a class="header" href="#차례">차례</a></h2>
<ol>
<li>Docker 소개 및 설치</li>
<li>컨테이너</li>
<li>서비스</li>
<li>스웜</li>
<li>스택</li>
<li>애플리케이션 배포하기</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="시작하기---part-1-docker-소개-및-설치"><a class="header" href="#시작하기---part-1-docker-소개-및-설치">시작하기 - Part 1: Docker 소개 및 설치</a></h1>
<p>환영합니다! 당신이 Docker에 대해 배우길 원해서 기쁩니다. The <em>Docker Get Started Tutorial</em> 튜토리얼은 아래와 같이 진행될 것입니다.</p>
<ol>
<li>Docker 환경 설치하기 (이번 페이지)</li>
<li>이미지를 만들고 컨테이너로 실행하기</li>
<li>다중 컨테이너에서 실행하기 위한 애플리케이션 확장하기</li>
<li>클러스터로 애플리케이션 분산하기</li>
<li>데이터베이스 추가로 서비스 쌓기</li>
<li>운영환경으로 애플리케이션 배포하기</li>
</ol>
<h2 id="docker-컨셉"><a class="header" href="#docker-컨셉">Docker 컨셉</a></h2>
<p>Docker는 개발자와 시스템 관리자를 위한 애플리케이션 <strong>개발, 배포, 실행</strong> 가능한 컨테이너 플랫폼입니다. 애플리케이션 배포를 위한 리눅스 컨테이너 사용을 <em>containerization</em>이라고 불렀습니다. 컨테이너 자체는 새롭지 않지만, 애플리케이션 배포를 단순화하기 위한 컨테이너는 그렇지 않습니다.</p>
<p><em>Containerization</em>은 아래의 특징 때문에 나날이 유명해졌습니다.</p>
<ul>
<li>유연함: 아무리 복잡한 애플리케이션도 컨테이너화 할 수 있습니다.</li>
<li>가벼움: 컨테이너들은 호스트 커널과 자원을 공유합니다.</li>
<li>교환 가능함: 업데이트와 업그레이드를 위한 즉시 배포가 가능합니다.</li>
<li>휴대성: 로컬 환경에서 빌드하고, 클라우드 환경으로 배포하고, 어디에서나 실행 가능합니다.</li>
<li>확장 가능함: 컨테이너를 늘리고 자동으로 분산 환경을 만들 수 있습니다.</li>
<li>적재 가능함: 서비스들을 즉시 수직적으로 쌓을 수 있습니다.</li>
</ul>
<h3 id="이미지와-컨테이너"><a class="header" href="#이미지와-컨테이너">이미지와 컨테이너</a></h3>
<p>컨테이너는 이미지를 통해 구동할 수 있습니다. <strong>이미지</strong>는 , 애플리케이션을 구동하는데 필요한 코드, 실행환경, 라이브러리, 환경변수, 설정 파일 등의 필요한 모든 것들을 포함한, 실행 가능한 패키지입니다.</p>
<p><strong>컨테이너</strong>는 이미지의 런타임 인스턴스입니다. 컨테이너는 이미지가 실행될 때 메모리 상에 올라간 이미지를 의미합니다. 이는 상태가 있는 이미지, 유저 프로세스 등을 의미합니다. 우리는 구동 중인 컨테이너의 목록을 <code>docker ps</code> 명령어로 확인할 수 있습니다.</p>
<h3 id="컨테이너와-가상-머신"><a class="header" href="#컨테이너와-가상-머신">컨테이너와 가상 머신</a></h3>
<p><strong>컨테이너</strong>는 리눅스 상에서 네이티브로 실행되고 호스트의 커널을 다른 컨테이너들과 공유합니다. 컨테이너는 별개의 프로세스로 동작하지만, 다른 실행 가능한 컨테이너나 프로그램보다 많은 메모리를 점유하지 않습니다. 이 것이 도커를 가볍게 만듭니다.</p>
<p>그에 반해서, <strong>가상 머신</strong>은 하이퍼바이저를 통해 호스트 자원에 가상 접근하는 게스트 운영체제를 구동합니다. 일반적으로 가상 머신은 대부분의 애플리케이션이 필요한 것보다 많은 자원을 제공합니다.</p>
<h2 id="docker-환경-준비하기"><a class="header" href="#docker-환경-준비하기">Docker 환경 준비하기</a></h2>
<p>Docker CE/EE를 설치합니다.</p>
<h3 id="docker-version-확인하기"><a class="header" href="#docker-version-확인하기">Docker version 확인하기</a></h3>
<ol>
<li><code>docker --version</code> 명령어를 통해 Docker version을 확인합니다.</li>
</ol>
<pre><code class="language-sh">$ docker --version

Docker version 18.06.1-ce, build e68fc7a
</code></pre>
<ol start="2">
<li><code>docker info</code> 혹은 <code>docker version</code> 명령어로 도커에 대한 디테일한 정보를 확인합니다.</li>
</ol>
<pre><code class="language-sh">$ docker info

Client:
 Version:           18.06.1-ce
 API version:       1.38
 Go version:        go1.10.3
 Git commit:        e68fc7a
 Built:             Tue Aug 21 17:21:31 2018
 OS/Arch:           darwin/amd64
 Experimental:      false

Server:
 Engine:
  Version:          18.06.1-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.3
  Git commit:       e68fc7a
  Built:            Tue Aug 21 17:29:02 2018
  OS/Arch:          linux/amd64
  Experimental:     true
</code></pre>
<blockquote>
<p>퍼미션 에러와 <code>sudo</code> 명령어 사용을 위해, 사용자 계정을 <code>docker</code> 그룹에 추가하세요.</p>
</blockquote>
<h4 id="permisson-error를-피하기-위한-docker-그룹에-사용자-추가하기"><a class="header" href="#permisson-error를-피하기-위한-docker-그룹에-사용자-추가하기">Permisson error를 피하기 위한 <code>docker</code> 그룹에 사용자 추가하기</a></h4>
<p>1. <code>docker</code> 그룹을 생성한다.</p>
<pre><code class="language-sh">$ sudo groupadd docker
</code></pre>
<p>2. 사용자를 <code>docker</code> 그룹에 추가한다.</p>
<pre><code class="language-sh">$ sudo usermod -aG docker $USER
</code></pre>
<p>3. 그룹권한을 재설정 하기위해 로그아웃 후 다시 접속한다.</p>
<p>4. <code>sudo</code> 명령어 없이 <code>docker</code>를 실행하여 권한테스트를 한다.</p>
<pre><code class="language-sh">$ docker run hello-world
</code></pre>
<h3 id="docker-설치-테스트하기"><a class="header" href="#docker-설치-테스트하기">Docker 설치 테스트하기</a></h3>
<ol>
<li>설치한 Docker를 간단한 도커 이미지인 hello-world를 통해 테스트합니다.</li>
</ol>
<pre><code class="language-sh">$ docker run hello-world

Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
d1725b59e92d: Pull complete
Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre>
<ol start="2">
<li>다운로드한 <code>hello-world</code> 이미지를 목록에서 확인해보세요.</li>
</ol>
<pre><code class="language-sh">docker image ls

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
postgres            latest              39dfbcb5424b        4 weeks ago         311MB
ubuntu              16.04               4a689991aa24        7 weeks ago         116MB
ubuntu              latest              ea4c82dcd15a        7 weeks ago         85.8MB
hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB
ubuntu              12.04               5b117edd0b76        20 months ago       104MB
</code></pre>
<ol start="3">
<li>이미지를 통해 생성된 <code>hello-world</code> 컨테이너를 목록에서 확인하세요. 만약 컨테이너가 여전히 구동 중이라면, <code>--all</code> 옵션은 필요하지 않습니다.</li>
</ol>
<pre><code class="language-sh">$ docker container ls --all

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
063b9e26ba47        ubuntu              &quot;/bin/bash&quot;         13 days ago         Up 13 days                              brave_liskov
</code></pre>
<h3 id="정리-및-치트-시트"><a class="header" href="#정리-및-치트-시트">정리 및 치트 시트</a></h3>
<pre><code class="language-sh">## Docker CLI 명령어 목록
docker
$ docker container --help

## Docker 버전 및 정보 조회
$ docker --version
$ docker version
$ docker info

## Docker 이미지 실행하기
$ docker run hello-world

## Docker 이미지 목록 조회
$ docker image ls

## Docker 컨테이너 목록 조회 (running, all, all in quiet mode)
$ docker container ls
$ docker container ls --all
$ docker container ls -aq
</code></pre>
<h2 id="part-1-결론"><a class="header" href="#part-1-결론">Part 1 결론</a></h2>
<p>Containerization은 CI/CD를 매끄럽게 만듭니다. 그 예로,</p>
<ul>
<li>애플리케이션은 시스템 의존성이 없습니다.</li>
<li>분산 애플리케이션의 어떤 부분도 업데이트될 수 있습니다.</li>
<li>자원 밀도가 최적화될 수 있습니다.</li>
</ul>
<p>Docker와 함께, 무거운 VM 호스트를 구동하는 것이 아닌, 애플리케이션 확장이 주된 관심사가 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="시작하기---part-2-컨테이너"><a class="header" href="#시작하기---part-2-컨테이너">시작하기 - Part 2: 컨테이너</a></h1>
<h2 id="전제-조건"><a class="header" href="#전제-조건">전제 조건</a></h2>
<ul>
<li><a href="https://docs.docker.com/install/">Docker 1.13 이상 설치</a></li>
<li><a href="devops/docker/./get-started-part1.html">Part 1</a> 읽기</li>
<li><code>hello-world</code> 이미지 실행 가능한 환경인지 테스트</li>
</ul>
<pre><code class="language-sh">$ docker run hello-world
</code></pre>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p>이제 Docker의 방식으로 애플리케이션을 만들기 시작할 때가 되었습니다. 이번 컨테이너 페이지를 통해, 우리는 애플리케이션 계층의 밑바닥부터 시작할 겁니다. 컨테이너가 어떻게 운영환경에서 행동하는지 Part 3: Service에서 다룰 것입니다. 마지막으로, Part 5: Stack에서 모든 서비스 상호작용의 정의에 대해 다룰 것입니다.</p>
<ul>
<li>Stack</li>
<li>Services</li>
<li>Container (지금 우리는 여기에 있습니다)</li>
</ul>
<h2 id="개발-환경이-필요합니다"><a class="header" href="#개발-환경이-필요합니다">개발 환경이 필요합니다</a></h2>
<p>과거엔, 파이썬 애플리케이션을 작성하려고 하면, 첫 번째 해야 할 일은 파이썬 실행환경을 설치하는 것이었습니다. 하지만 로컬 개발 환경에서 애플리케이션이 의도한 대로 동작하는 것처럼, 운영 환경에서도 잘 동작하는 것이 필요합니다.</p>
<p>Docker와 함께라면, 우리는 파이썬 런타임을 설치할 필요 없는 이미지로 가져갈 수 있습니다. 그러면, 기본 파이썬 이미지를 우리의 애플리케이션 코드 옆에 두고 빌드할 수 있습니다.</p>
<p>이런 포터블 이미지를 <code>Dockerfile</code>이라고 부릅니다.</p>
<h2 id="dockerfile로-컨테이너-정의하기"><a class="header" href="#dockerfile로-컨테이너-정의하기"><code>Dockerfile</code>로 컨테이너 정의하기</a></h2>
<p><code>Dockerfile</code>은 컨테이너가 어떤 환경을 가져야 하는지에 대해 정의합니다. 네트워크 인터페이스나 디스크 드라이버 같은 자원에 접근하는 것은 시스템의 나머지로부터 격리된 환경 안에서 가상화됩니다. 그래서 바깥세상과 통신할 수 있는 포트를 매핑해야 하고, 어떤 환경 파일을 복사해야 할지 구체적으로 정의해야 합니다. 그렇지만, 그 후엔 <code>Dockerfile</code>에 정의한 대로 애플리케이션의 빌드가 어디에서나 동일하게 수행될 것입니다.</p>
<h3 id="dockerfile"><a class="header" href="#dockerfile"><code>Dockerfile</code></a></h3>
<p>빈 디렉터리를 만드세요. 새로 생성한 디렉터리로 경로를 변경(<code>cd</code>)해서 <code>Dockerfile</code>을 생성하고, 아래 내용을 복사해서 저장합니다. Dockerfile의 스크립트를 설명하는 주석을 읽어보세요.</p>
<pre><code class="language-Dockerfile"># 파이썬 런타임을 부모 이미지로 사용합니다.
FROM python:2.7-slim

# 작업 디렉터리를 /app으로 설정합니다.
WORKDIR /app

# 현재 디렉터리의 내용을 /app의 컨테이너로 복사합니다.
COPY . /app

# requirements.txt에 기술된 패키지들을 설치합니다.
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# 컨테이너 바깥과 통신할 포트인 80번을 열어둡니다.
EXPOSE 80

# 환경 변수를 정의합니다.
ENV NAME World

# 컨테이너를 구동할 때 app.py를 실행합니다. 
CMD [&quot;python&quot;, &quot;app.py&quot;]
</code></pre>
<p><code>Dockerfile</code>은 우리가 아직 만들지 않은 <code>app.py</code>나 <code>requirements.txt</code> 같은 파일들을 필요로 합니다. 이제 이 파일들을 만들어봅시다.</p>
<h2 id="애플리케이션-그-자체"><a class="header" href="#애플리케이션-그-자체">애플리케이션 그 자체</a></h2>
<p><code>requirements.txt</code>와 <code>app.py</code>, 두 파일을 <code>Dockerfile</code>과 같은 폴더에 생성합니다. 보이는 것과 같이 쉽게 애플리케이션이 완성됐습니다. <code>Dockerfile</code>이 이미지에 들어갈 때, <code>app.py</code>와 <code>requirements.txt</code> 역시 <code>Dockerfile</code>의 <code>Copy</code> 명령어로 인해 나타납니다. 그리고 <code>app.py</code>로부터의 결과는 <code>EXPOSE</code> 명령으로 인해 HTTP로 접근 가능합니다.</p>
<h3 id="requirementstxt"><a class="header" href="#requirementstxt"><code>requirements.txt</code></a></h3>
<pre><code class="language-plain">Flask
Redis
</code></pre>
<h3 id="apppy"><a class="header" href="#apppy"><code>app.py</code></a></h3>
<pre><code class="language-python">
from flask import Flask
from redis import Redis, RedisError
import os
import socket

# Connect to Redis
redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)

app = Flask(__name__)

@app.route(&quot;/&quot;)
def hello():
    try:
        visits = redis.incr(&quot;counter&quot;)
    except RedisError:
        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;

    html = &quot;&lt;h3&gt;Hello {name}!&lt;/h3&gt;&quot; \
           &quot;&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;&quot; \
           &quot;&lt;b&gt;Visits:&lt;/b&gt; {visits}&quot;
    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)

if __name__ == &quot;__main__&quot;:
    app.run(host='0.0.0.0', port=80)
</code></pre>
<p>이제 우리는 <code>pip install -r requirements.txt</code> 스크립트 문장이 플라스크와 레디스 라이브러리를 설치하고 애플리케이션이 환경변수 <code>NAME</code>와 <code>socket.gethostname()</code>을 호출한 결과를 출력하는 것을 볼 것입니다. 마침내, 레디스가 실행 중이 아니기 때문에, 우리는 레디스를 사용하려다 실패하고 에러메시지를 뿜어내는 것을 예상할 수 있습니다.</p>
<blockquote>
<p>노트: 내부 컨테이너가 컨테이너 ID를 조회할 때 호스트의 이름에 접근하면 실행 중인 프로세스 ID가 검색됩니다.</p>
</blockquote>
<p>바로 이 것입니다! 파이썬이나 <code>requirements.txt</code> 안의 아무것도, 이미지를 빌드하거나 수행할 때 시스템에 필요로 하지 않습니다. 파이썬과 플라스크를 개발환경에 설치한 것처럼 보이지 않지만, 이미 당신은 가지고 있습니다.</p>
<h2 id="애플리케이션-빌드하기"><a class="header" href="#애플리케이션-빌드하기">애플리케이션 빌드하기</a></h2>
<p>우리는 애플리케이션을 만들 준비가 됐습니다. 여전히 디렉터리 최상위에 있는지 확인해보세요. 여기 <code>ls</code> 명령어를 사용해서 나타내 보세요.</p>
<pre><code class="language-sh">$ ls

total 24
drwxr-xr-x  5 sshplendid  staff  170 12 15 00:18 .
drwxr-xr-x  8 sshplendid  staff  272 12 14 21:54 ..
-rw-r--r--  1 sshplendid  staff  169 12 14 21:55 Dockerfile
-rw-r--r--  1 sshplendid  staff  669 12 15 00:18 app.py
-rw-r--r--  1 sshplendid  staff   12 12 14 23:54 requirements.txt
</code></pre>
<p>이제 빌드를 명령해보세요. 이는 도커 이미지를 생성하고 <code>-t</code> 태그를 사용해서 친숙한 이름을 붙일 수 있습니다.</p>
<blockquote>
<p>역자+ 지금은 제 고양이 이름인 <code>waltz</code>라는 이름으로 만들어 보겠습니다.</p>
</blockquote>
<pre><code class="language-sh">$ cd /Volumes/Mango/workspaces/kata/docker
$ docker build -t waltz .
</code></pre>
<p>빌드한 이미지가 어디에 있나요? 당신의 기기 로컬 Docker 이미지 저장소에 있습니다.</p>
<pre><code class="language-sh">$ docker image ls

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
waltz               latest              d3582b3f0b85        31 seconds ago      131MB
python              2.7-slim            0dc3d8d47241        4 weeks ago         120MB
postgres            latest              39dfbcb5424b        4 weeks ago         311MB
ubuntu              16.04               4a689991aa24        8 weeks ago         116MB
ubuntu              latest              ea4c82dcd15a        8 weeks ago         85.8MB
hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB
ubuntu              12.04               5b117edd0b76        20 months ago       104MB
</code></pre>
<blockquote>
<p>리눅스 사용자를 위한 문제 해결<br />
프록시 서버 설정<br />
%$^$%^</p>
</blockquote>
<h2 id="애플리케이션-실행하기"><a class="header" href="#애플리케이션-실행하기">애플리케이션 실행하기</a></h2>
<p>컨테이너의 80번 포트와 호스트 장비의 4000번 포트를 매핑해서 <code>-p</code> 태그와 함께 애플리케이션을 실행합니다.</p>
<pre><code class="language-sh">$ docker run -p 4000:80 waltz
</code></pre>
<p><code>http://0.0.0.0:80</code>에서 파이썬으로 동작하는 애플리케이션이 있다는 메시지를 보셨을 겁니다. 그러나 메시지는 컨테이너 내부로부터 오는 것으로, 이는 올바른 URL인 <code>http://localhost:4000</code>을 만들 필요가 없이 컨테이너의 80번 포트가 4000번 포트에 매핑되었다는 것을 알 필요가 없다는 의미입니다.</p>
<p>웹브라우저에 접속해서 위 URL을 입력하고 이동해봅시다.</p>
<blockquote>
<p>노트: 만약 윈도7에서 도커 툴박스를 사용하고 있다면, Docker 장비 IP를 사용하세요. http://192.168.99.100:4000이 예입니다. IP 주소를 찾기 위해, <code>docker-machine ip</code> 명령어를 사용하세요.</p>
</blockquote>
<p><code>curl</code> 명령어를 사용해서 동일한 내용을 볼 수 있습니다.</p>
<pre><code class="language-sh">curl http://localhost:4000

&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 3dbbee09f22c&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;%
</code></pre>
<blockquote>
<p>윈도에서 컨테이너를 멈추는 방법<br />
윈도에서 <code>CTRL+C</code> 명령으로 컨테이너를 멈출 수 없습니다. 그러므로 먼저 <code>CTRL+C</code>를 치고 프롬프트로 돌아가거나 새로운 셸을 열어서 <code>docker container ls</code>를 입력해서 구동 중인 컨테이너의 리스트를 확인합니다. 그리고 <code>docker container stop &lt;컨테이너 이름이나 ID&gt;</code>를 입력해서 컨테이너를 중지시킵니다. 그렇지 않으면 다음에 컨테이너를 재구동할 때 대몬으로부터 에러 응답을 받을 수 있습니다.</p>
</blockquote>
<p>이제 애플리케이션을 백그라운드에서 동작(detach mode)하도록 명령합니다.</p>
<pre><code class="language-sh">$ docker run -d -p 4000:80 waltz
</code></pre>
<p>이 명령을 실행하면 컨테이너에 대한 긴 ID를 출력하고 다시 터미널 명령으로 돌아옵니다. 컨테이너는 백그라운드에서 동작합니다. 우리는 <code>docker container ls</code> 명령을 통해 짧은 컨테이너 ID를 확인할 수 있습니다. 그리고 두 ID 모두 명령을 실행할 때 사용할 수 있습니다.</p>
<pre><code class="language-sh">$ docker continaer ls

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
abf81e3f6825        waltz               &quot;python app.py&quot;     6 seconds ago       Up 4 seconds        0.0.0.0:4000-&gt;80/tcp   trusting_khayyam
</code></pre>
<p><code>CONTAINER ID</code>는 <code>http://localhost:4000</code> 과 매핑됩니다.</p>
<p>이제 <code>CONTAINER ID</code>를 사용해서 <code>docker container stop</code> 명령으로 프로세스를 끝내봅시다.</p>
<pre><code class="language-sh">$ docker container stop abf81e3f6825
</code></pre>
<h2 id="이미지-공유하기"><a class="header" href="#이미지-공유하기">이미지 공유하기</a></h2>
<p>방금 생성한 애플리케이션의 휴대성을 높이기 위해, 이미지를 업로드해서 다른 어딘가에서 실행해봅시다. 그 후에, 운영 환경에 컨테이너를 배포하기 원할 때, 레지스트리에 푸시하는 방법을 알아야 할 것입니다.</p>
<p>레지스트리는 저장소의 모음이고, 저장소는 이미지의 모음입니다. 코드가 이미 작성되었다는 사실을 제외하면 GitHub와 유사합니다. 레지스트리의 계정은 많은 저장소에서 생성할 수 있습니다. <code>docker</code> CLI는 기본적으로 Docker 퍼블릭 저장소를 사용합니다.</p>
<blockquote>
<p>Note: 우리는 여기서 도커 퍼블릭 저장소를 사용합니다. 왜냐하면 무료에다가 이미 설정되어 있기 때문입니다. 그러나 여러 저장소 중 하나를 선택해서 사용할 수 있고, 심지어 <a href="devops/docker/">Docker Trusted Registry</a>를 통해서 자신만의 개인 레지스트리를 만드는 것도 가능합니다.</p>
</blockquote>
<h3 id="docker-id로-로그인하기"><a class="header" href="#docker-id로-로그인하기">Docker ID로 로그인하기</a></h3>
<p>만약 Docker 계정이 없다면, hub.docker.com 에서 계정을 생성하세요. 가입한 사용자 명으로 도커 퍼블릭 레지스트리에 로그인하세요.</p>
<pre><code class="language-sh">$ docker login
</code></pre>
<h3 id="이미지-태그하기"><a class="header" href="#이미지-태그하기">이미지 태그하기</a></h3>
<p>레지스트리에서 저장소와 연계된 이미지의 표기는 <code>사용자명/저장소:태그</code> 입니다. 태그는 선택적이지만, 사용하길 추천합니다. 레지스트리가 도커 이미지들에게 버전을 주는 방식이기 때문입니다. 저장소와 태그에 <code>get-started:part2</code> 같은 의미 있는 이름을 붙여줍니다. 이는 <code>get-started</code> 저장소에 <code>part2</code>라고 이미지에 태그 한 것입니다.</p>
<p>이제 이미지에 태그 하기 위해 이 것들을 함께 넣어봅시다. 의도한 목적지에 이미지를 업로드하기 위해, 사용자 명과 저장소, 태그 명을 사용해서 <code>docker tag image</code> 명령을 실행해봅시다. </p>
<blockquote>
<p>역자+ 이전에 생성한 'waltz' 이미지를 docker hub 계정인 'sshplendid' 하위의 'get-started' 저장소에 'part2'라는 태그로 업로드할 것입니다.</p>
</blockquote>
<pre><code class="language-sh">$ docker tag waltz sshplendid/get-started:part2
</code></pre>
<p><code>docker image ls</code> 명령을 실행해서 새롭게 태그된 이미지를 확인해봅시다.</p>
<pre><code class="language-sh">$ docker image ls

REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
waltz                    latest              d3582b3f0b85        2 days ago          131MB
sshplendid/get-started   part2               d3582b3f0b85        2 days ago          131MB
python                   2.7-slim            0dc3d8d47241        4 weeks ago         120MB
ubuntu                   latest              ea4c82dcd15a        8 weeks ago         85.8MB
...
</code></pre>
<h3 id="이미지-발행하기"><a class="header" href="#이미지-발행하기">이미지 발행하기</a></h3>
<p>태그 한 이미지를 저장소에 업로드해봅시다.</p>
<pre><code class="language-sh">$ docker push 사용자명/저장소:태그
</code></pre>
<p>명령이 끝나면, 업로드한 이미지는 공개적으로 사용 가능합니다. 만약 <a href="https://hub.docker.com">도커 허브</a>에 로그인했다면, 그곳에 있는 이미지를 pull 명령으로 볼 수 있습니다.</p>
<h3 id="원격-저장소로부터-이미지를-끌어와-실행하기"><a class="header" href="#원격-저장소로부터-이미지를-끌어와-실행하기">원격 저장소로부터 이미지를 끌어와 실행하기</a></h3>
<p>지금부터 <code>docker run</code> 명령으로 어떤 장비에서든 애플리케이션을 실행할 수 있습니다.</p>
<pre><code class="language-sh">$ docker run -p 4000:80 username/repository:tag
</code></pre>
<p>이미지가 로컬 장비에서 사용할 수 없는 상태라면, Docker는 저장소로부터 이미지를 끌어옵니다.</p>
<pre><code class="language-sh">$ docker run sshplendid/get-started:part2
Unable to find image 'sshplendid/get-started:part2' locally
part2: Pulling from sshplendid/get-started
a5a6f2f73cd8: Already exists
8da2a74f37b1: Already exists
09b6f498cfd0: Already exists
f0afb4f0a079: Already exists
7be2300e1a8b: Already exists
b34ffcdf5978: Already exists
aa01dc4a3353: Already exists
Digest: sha256:0dff90a601cec25d6e7e7662d28e501758a7d02ebb40700a91a87117847a0a88
Status: Downloaded newer image for sshplendid/get-started:part2
 * Serving Flask app &quot;app&quot; (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)
</code></pre>
<p>어디서 <code>docker run</code> 명령을 실행하던, 파이썬과 마찬가지로 <code>requirements.txt</code>의 모든 의존성을 함께 이미지와 끌어당겨옵니다. 그리곤 코드를 실행합니다. 가벼운 짐을 싸서 여행하는 것처럼, 호스트 장비에 어떤 것도 설치할 필요 없이 Docker를 통해 실행하면 됩니다.</p>
<h2 id="part-2의-결론"><a class="header" href="#part-2의-결론">Part 2의 결론</a></h2>
<p>이 페이지의 내용은 이 것이 전부입니다. 다음 장에서 <strong>서비스</strong> 안에서 컨테이너를 구동함으로써 애플리케이션의 스케일링 방법에 대해 배울 것입니다.</p>
<h2 id="정리-및-cheat-sheet"><a class="header" href="#정리-및-cheat-sheet">정리 및 cheat sheet</a></h2>
<p>이 장에서 사용한 기본적인 docker 명령들과 알아두면 좋을 명령어 리스트입니다.</p>
<pre><code class="language-sh">docker build -t waltz .                           # 현재 디렉터리의 Dockerfile을 이용해서 이미지 생성하기
docker run -p 4000:80 waltz                       # 4000번 포트를 80번 포트와 매핑하여 &quot;waltz&quot; 실행하기
docker run -d -p 4000:80 waltz                    # 위 명령을 백그라운드 모드로 실행하기
docker container ls                               # 모든 구동 중인 컨테이너 리스트
docker container ls -a                            # 멈춰있는 컨테이너를 포함한 모든 컨테이너 리스트
docker container stop &lt;hash&gt;                      # 안전하게 특정 컨테이너 중지하기
docker container kill &lt;hash&gt;                      # 강제로 컨테이너 중지하기
docker container rm &lt;hash&gt;                        # 특정 컨테이너 삭제하기
docker container rm $(docker container ls -a -q)  # 모든 컨테이너 삭제하기
docker image ls -a                                # 모든 이미지 리스트 
docker image rm &lt;image id&gt;                        # 특정 이미지 삭제
docker image rm $(docker image ls -a -q)          # 모든 이미지 삭제
docker login                                      # Docker 자격증명을 이용하여 CLI 세션에서 로그인하기
docker tag &lt;image&gt; username/repository:tag        # 레지스트리 업로드를 위한 이미지 태그
docker push username/repository:tag               # 태그 한 이미지 업로드하기
docker run username/repository:tag                # 레지스트리의 이미지 실행하기
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="시작하기---part-3-서비스"><a class="header" href="#시작하기---part-3-서비스">시작하기 - Part 3: 서비스</a></h1>
<h2 id="전제조건"><a class="header" href="#전제조건">전제조건</a></h2>
<ul>
<li><a href="https://docs.docker.com/install/">Docker 1.13 이상 설치</a></li>
<li>Docker Compose 준비하기. Mac/Windows 용 Docker에 이미 설치되어 있습니다. Linux의 경우 직접 설치해야 합니다. Windows 10에선 <em>Hyper-V</em> 없이 Docker Toolbox를 사용하세요.</li>
<li><a href="devops/docker/./get-started-part1.html">Part 1</a>을 읽고 <a href="devops/docker/./get-started-part2.html">Part 2</a>에서 컨테이너 생성 방법에 대해서 학습합니다.</li>
<li><code>waltz</code> 이미지를 생성해서 레지스트리에 발행하는 것까지 해봐야 합니다. 이 장에서 공유한 이미지를 사용할 예정입니다.</li>
<li>그 이미지가 배포된 컨테이너로서 작동하는지 확인합니다. <code>docker run -p 4000:80 사용자명/저장소:태그</code> 명령을 실행하면, <code>http://localhost:4000/</code>으로 접속되는 것을 확인해야 합니다.</li>
</ul>
<h2 id="소개-1"><a class="header" href="#소개-1">소개</a></h2>
<p>3장에서 애플리케이션 규모를 조절하고 로드밸런싱을 활성화할 것입니다. 이 일을 하기 위해, <strong>서비스</strong>라는 분산 애플리케이션의 계층에 대해 알아야 합니다.</p>
<ul>
<li>Stack</li>
<li>Service (지금 여기에 있습니다)</li>
<li>Container (2장에서 다뤘습니다)</li>
</ul>
<h2 id="서비스에-대해"><a class="header" href="#서비스에-대해">서비스에 대해</a></h2>
<p>분산 애플리케이션에서 애플리케이션의 다른 조각들을 &quot;서비스&quot;라고 부릅니다. 한 예로, 만약 영상 공유 사이트가 있다고 가정합시다. 이 사이트는 애플리케이션 데이터를 데이터베이스에 저장하는 서비스, 사용자가 업로드한 뭔가를 백그라운드에서 변환하는 서비스, 프론트엔드를 위한 서비스 등 여러 서비스들을 포함할 것입니다.</p>
<p>서비스는 단지 &quot;운영 환경의 컨테이너들&quot;입니다. 오로지 하나의 이미지를 실행하지만, 이미지를 실행하는 방법 - 어떤 포트를 사용해야 하는지, 컨테이너의 레플리카를 수요를 충족하도록 얼마나 많이 구동해야 하는지 등 - 편성합니다. 서비스의 규모를 조절하는 것은 소프트웨어의 조각들을 실행하는 컨테이너 인스턴스의 수나 프로세스 상에서 서비스를 위한 자원을 더 할당해야 하는 것을 의미합니다.</p>
<p>운이 좋게도 Docker 플랫폼에서 서비스를 정의하고, 실행하고, 규모를 조절하는 것은 매우 쉽습니다. 단지 <code>docker-compose.yml</code> 파일을 작성하면 됩니다.</p>
<h2 id="첫-docker-composeyml-파일"><a class="header" href="#첫-docker-composeyml-파일">첫 <code>docker-compose.yml</code> 파일</a></h2>
<p><code>docker-compose.yml</code> 파일은 Docker container가 운영 환경에서 행동하는 방법을 정의한 YAML 파일입니다.</p>
<h3 id="docker-composeyml"><a class="header" href="#docker-composeyml"><code>docker-compose.yml</code></a></h3>
<p><code>docker-compose.yml</code>로 아래 내용을 저장하세요. 하지만 그전에 Part 2에서 레지스트리에 생성한 이미지를 발행하고 이 yml 파일을 업데이트 한 이미지를 수정해야 합니다.</p>
<pre><code class="language-yml">version: &quot;3&quot;
services:
  web:
    # replace username/repo:tag with your name and image details
    image: username/repo:tag
    deploy:
      replicas: 5
      resources:
        limits:
          cpus: &quot;0.1&quot;
          memory: 50M
      restart_policy:
        condition: on-failure
    ports:
      - &quot;4000:80&quot;
    networks:
      - webnet
networks:
  webnet:
</code></pre>
<p>이 <code>docker-compose.yml</code> 파일은 도커가 아래와 같은 일을 하게 합니다.</p>
<ul>
<li>레지스트리로부터 Part2에서 업로드한 이미지를 끌어오기</li>
<li><code>web</code>이라고 5개의 인스턴스를 구동하고 각각의 인스턴스가 최대 10%의 CPU와 50MB의 램을 사용할 수 있도록 제한하기</li>
<li>컨테이너 중 하나가 동작 실패하는 경우 즉시 재시작하기</li>
<li>호스트의 4000번 포트를 <code>web</code>의 80번 포트와 매핑하기</li>
<li><code>web</code>의 컨테이너들이 <code>webnet</code>이라 불리는 로드 밸런스 네트워크를 통해  80번 포트를 공유하도록 관리하기 (내부적으로 컨테이너 그 자체가 <code>web</code>의 80번 포트로 발행함)</li>
<li>webnet` 네트워크를 기본 설정(로드밸런싱으로 뒤덮은 네트워크)으로 정의하기</li>
</ul>
<h2 id="새로운-로드-밸런스-된-애플리케이션-실행하기"><a class="header" href="#새로운-로드-밸런스-된-애플리케이션-실행하기">새로운 로드 밸런스 된 애플리케이션 실행하기</a></h2>
<p><code>docker stack deploy</code> 명령을 실행하기 전에 아래 명령을 먼저 실행해야 합니다.</p>
<pre><code class="language-sh">$ docker swarm init

Swarm initialized: current node (mo9cxneiwqtmu3ewqm7q6tdwv) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-0kuhh5msy0fymymktuxwm0w0luad2jcu8nq5ldalabcckutes9-3wgp251zlg6w5moe3d9ni9ya4 192.168.65.3:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
</code></pre>
<blockquote>
<p>Note: 4장에서 이 명령이 뭘 의미하는지 알게 될 것입니다. <code>docker swarm init</code>을 실행하지 않으면 &quot;this node is not a swarm manger.(이 노트는 스웜 매니저가 아닙니다.)&quot;라는 에러를 받게 될 것입니다.</p>
</blockquote>
<p>이제 실행해봅시다. 애플리케이션의 이름을 정해야 합니다. 여기선 <code>getstartedlab</code>이라고 설정했습니다.</p>
<pre><code class="language-sh">$ docker stack deploy -c docker-compose.yml getstartedlab

Creating network getstartedlab_webnet
Creating service getstartedlab_web
</code></pre>
<p>하나의 서비스 스택은 호스트에서 배포된 이미지의 컨테이너 인스턴스 5개를 실행합니다. 이제 살펴봅시다. 애플리케이션의 서비스 ID를 확인해봅시다.</p>
<pre><code class="language-sh">$ docker service ls

ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
a690upphrjmg        getstartedlab_web   replicated          2/5                 username/repo:tag   *:80-&gt;80/tcp
</code></pre>
<p><code>web</code> 서비스의 출력 결과를 살펴보면, 애플리케이션 이름이 맨 앞에 붙어있습니다. 만약 위의 예처럼 이름을 붙였다면, 이름은 <code>getstartedlab_web</code>이 될 것 입니다. 서비스 ID는 레플리카의 수, 이미지 이름, 노출된 포트와 함께 확인할 수 있습니다.</p>
<p>서비스에서 실행되는 각각의 컨테이너를 <strong>태스크</strong>라고 부릅니다. 태스크는 산술적으로 증가되는 유일한 ID를 가지고 있고, <code>docker-compose.yml</code>에 정의한 레플리카의 수까지 증가합니다. 서비스의 태스크 목록을 확인해봅시다.</p>
<pre><code class="language-sh">$ docker service ps getstartedlab_web

</code></pre>
<p>태스크는 시스템의 모든 컨테이너들의 목록에도 나타납니다.</p>
<pre><code class="language-sh">$ docker container ls -q

0d339f851a17
b0eec7357bd9
212ef3c86f04
554db3ec624e
1fd1227f80cc
</code></pre>
<p><code>curl -4 http://localhost</code> 명령을 여러 번 호출하거나 웹 브라우저에서 저 주소로 여러 번 접속해봅시다.</p>
<p>라운드-로빈 상태에서 각 요청을 로드밸런싱 하기 위해 5개 태스크들 중 하나를 선택합니다. 어느 쪽이던 컨테이너 ID는 바뀝니다. 컨테이너 ID들은 이전 명령인 <code>docker container ls -q</code>의 결과와 일치합니다.</p>
<blockquote>
<h4 id="windows-10-환경에서-실행하기"><a class="header" href="#windows-10-환경에서-실행하기">Windows 10 환경에서 실행하기</a></h4>
</blockquote>
<p>Windows 10 파워 셸을 이미 <code>curl</code>이 사용 가능합니다. 그렇지 않으면 Git BASH나 Windows용 wget을 사용하세요.</p>
<blockquote>
<h4 id="느린-반응속도"><a class="header" href="#느린-반응속도">느린 반응속도</a></h4>
</blockquote>
<p>네트워크 설정에 따라 응답은 30초까지 걸릴 수 있습니다. 이 것이 도커나 스웜 퍼포먼스를 의미하지 않지만, 나중에 나올 Redis 의존성 때문일 수도 있습니다. 지금은 방문 카운터는 아직 서비스를 추가하지 않았기 때문에 작동하지 않습니다.</p>
<h2 id="애플리케이션-규모-설정하기"><a class="header" href="#애플리케이션-규모-설정하기">애플리케이션 규모 설정하기</a></h2>
<p><code>docker-compose.yml</code>의 <code>replicas</code>의 값을 바꿔서 애플리케이션 규모를 조절할 수 있습니다. 변경사항을 저장하면, <code>docker stack deploy</code> 명령을 재실행합니다.</p>
<pre><code class="language-sh">$ docker stack deploy -c docker-compose.yml getstartedlab
</code></pre>
<p>도커는 즉시 업데이트를 수행해서, 어떤 컨테이너도 멈추거나 스택을 중지할 필요가 없습니다.</p>
<p>이제 <code>docker container ls -q</code> 명령을 재실행해서 재설정된 인스턴스들을 봅시다. 만약 레플리카의 규모나 태스크를 늘렸다면, 이런 이유로 컨테이너가 더 구동될 것입니다.</p>
<h2 id="애플리케이션과-스웜-내리기"><a class="header" href="#애플리케이션과-스웜-내리기">애플리케이션과 스웜 내리기</a></h2>
<ul>
<li><code>docker stack rm</code>을 이용해서 애플리케이션 내리기</li>
</ul>
<pre><code class="language-sh">$ docker stack rm getstartedlab
</code></pre>
<ul>
<li>스웜 내리기</li>
</ul>
<pre><code class="language-sh">$ docker swarm leave --force
</code></pre>
<p>내리는 것은 애플리케이션 규모 조절과 올리는 것만큼 쉽습니다. 이제까지 운영환경에서 컨테이너를 실행하는 방법에 대해 학습했습니다. 앞으로 도커의 클러스터 위에서 보나파르트 떼(?)로써 애플리케이션을 실행하는 방법에 대해 배울 것입니다.</p>
<blockquote>
<p>Note: 이와 같은 컴포즈 파일들은 Docker 애플리케이션을 정의하는 데 사용되고 Docker Cloud를 사용해서 클라우드 프로바이더, 하드웨어 어디든, Docker Enterprise Edition과 함께 클라우드 프로바이더에게 업로드될 수 있습니다.</p>
</blockquote>
<h2 id="정리-및-cheat-sheet-1"><a class="header" href="#정리-및-cheat-sheet-1">정리 및 cheat sheet</a></h2>
<p><code>docker run</code>을 타이핑하는 것은 간단하지만. 운영환경에서 컨테이너를 실제로 적용하는 것은 서비스로서 구동하는 것이다. 서비스는 컨테이너의 행동을 컴포즈 파일에 따라 편성하고, 이 파일은 애플리케이션을 재배포하거나, 규모를 조정하거나, 제한하는 데 사용됩니다. 서비스를 변화시키는 것은 <code>docker stack deploy</code>를 실행하는 것과 같이 서비스를 구동하는 명령을 사용해서 응용됩니다.</p>
<pre><code class="language-sh">docker stack ls                                  # 애플리케이션이나 스택의 리스트 조회
docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;   # 특정 컴포즈 파일 실행
docker service ls                                # 애플리케이션과 연관된, 실행 중인 서비스 목록 조회
docker service ps &lt;service&gt;                      # 애플리케이션과 연관된, 태스크 목록 조회
docker inspect &lt;task or container&gt;               # 컨테이너나 태스크 검사
docker container ls -q                           # 컨테이너의 ID 목록 조회
docker stack rm &lt;appname&gt;                        # 애플리케이션 내리기
docker swarm leave --force                       # 단일 노드 스웜 내리기
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="시작하기---part-4-스웜"><a class="header" href="#시작하기---part-4-스웜">시작하기 - Part 4: 스웜</a></h1>
<h2 id="전제조건-1"><a class="header" href="#전제조건-1">전제조건</a></h2>
<ul>
<li><a href="https://docs.docker.com/install/">Docker 1.13 이상 설치</a></li>
<li><a href="devops/docker/./get-started-part3.html#a%EC%A0%84%EC%A0%9C%EC%A1%B0%EA%B1%B4">Part 3 전제조건</a>에 기술된 <a href="https://docs.docker.com/compose/overview/">Docker Compose</a> 준비</li>
<li><a href="https://docs.docker.com/machine/overview/">도커 머신</a>을 준비합니다. Mac &amp; Windows에선 미리 설치되지만, 리눅스에선 직접 설치해야 합니다. Windows 10 에선 <a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>를 사용해야 합니다.</li>
<li><a href="devops/docker/./get-started-part1.html">Part 1</a>을 읽고 <a href="devops/docker/./get-started-part2.html">Part 2</a>에서 컨테이너 생성 방법에 대해서 학습합니다.</li>
<li><code>waltz</code> 이미지를 생성해서 레지스트리에 발행하는 것까지 해봐야 합니다. 이 장에서 공유한 이미지를 사용할 예정입니다.</li>
<li>그 이미지가 배포된 컨테이너로서 작동하는지 확인합니다. <code>docker run -p 4000:80 사용자명/저장소:태그</code> 명령을 실행하면, <code>http://localhost:4000/</code>으로 접속되는 것을 확인해야 합니다.</li>
<li><a href="devops/docker/./get-started-part3.html">Part 3</a> 에서의 <code>docker-compose.yml</code> 파일의 복사본을 준비합니다.</li>
</ul>
<h2 id="소개-2"><a class="header" href="#소개-2">소개</a></h2>
<p>Part 3에서, Part 2에서 작성한 애플리케이션을 얻고 어떻게 운영 환경에서 실행할지에 대해 서비스에 넣고, 규모를 다섯 배로 늘리는 방법에 대해 정의했습니다. Part 4에선, 애플리케이션을 여러 대의 장비에서 실행하는 클러스터 위에 배포할 겁니다. 멀티 컨테이너, 멀티 머신 애플리케이션은 <strong>스웜</strong>이라 불리는 &quot;Dockerized&quot; 클러스터 안으로 여러 대의 장비를 연결하는 것을 가능케 합니다.</p>
<h2 id="스웜-클러스터-이해하기"><a class="header" href="#스웜-클러스터-이해하기">스웜 클러스터 이해하기</a></h2>
<p>스웜은 도커를 실행하고 클러스터에 연결하는 장비들의 모음입니다. 여태까지 Docker 명령으로 실행했다면, 이젠 <strong>스웜 매니저</strong>를 통해서 클러스터를 실행합니다. 스웜의 장비들은 물리적 혹은 가상의 장비가 될 수 있습니다. 일단 스웜에 연결되면, 장비들은 <strong>노드</strong>로 불립니다.</p>
<p>스웜 매니저는 &quot;emptiest node&quot; - 최소의 자원을 이용 중인 장비들을 컨테이너로 채우는 방법 - 이나, &quot;global&quot; - 각 장비가 특정 컨테이너의 정확히 하나의 인스턴스만을 갖는 방법 등의 전략을 사용하여 컨테이너를 운용합니다. 컴포즈 파일에 이런 전략들을 사용하는 지시를 작성하고 스웜 매니저를 통해 관리합니다.</p>
<p>스웜 매니저는 <strong>워커</strong>라 불리는 다른 장비들에 명령을 하거나, 인가하는, 스웜 내의 유일한 장비입니다. 워커는 작업 용량을 제공하기 위해 존재하고, 다른 장비들이 어떤 일을 해야하는지 명령할 권한이 없습니다.</p>
<p>지금까지, 로컬 장비에서 단일 호스트 모드로서 도커를 사용했습니다. 하지만 도커는 <strong>스웜 모드</strong>로 동작할 수 있습니다. 이는 스웜의 사용을 활성화시켜서 현재 장비를 즉시 스웜 매니저로 동작하도록 합니다. 그 때부터, 도커는 현재 장비 대신 관리하는 스웜 내에서 지시한 명령을 실행합니다.</p>
<h2 id="스웜-설치하기"><a class="header" href="#스웜-설치하기">스웜 설치하기</a></h2>
<p>스웜은 물리 장비 혹은 가상 장비로 만들 수 있는 다중 노드로 구성됩니다. 기본 컨셉은 간단합니다. <code>docker swarm init</code> 명령을 실행해서 스웜모드를 활성화하고 현재 장비를 스웜 매니저로 만듭니다. 그리고 다른 장비에서 <code>docker swarm join</code> 명령을 실행해서 워커 역할로 스웜에 연결합니다. 아래 보이는 탭을 선택해서 여러 환경에서 동작하는 방법을 살펴봅시다. VM을 사용해서 빠르게 두 장비를 생성하고 이를 스웜으로 바꿉니다.</p>
<h3 id="클러스터-생성하기"><a class="header" href="#클러스터-생성하기">클러스터 생성하기</a></h3>
<h4 id="mac-linux-windows-7--8-환경에서-vm-설치하기"><a class="header" href="#mac-linux-windows-7--8-환경에서-vm-설치하기">Mac, Linux, Windows 7 &amp; 8 환경에서 VM 설치하기</a></h4>
<p>VM을 생성하기 위한 하이퍼바이저가 필요합니다. 그래서 로컬 운영체제를 위한 <a href="https://www.virtualbox.org/wiki/Downloads">Oracle VirtualBox</a>를 설치합니다.</p>
<blockquote>
<p>Note: 만약 윈도우즈 시스템에 Hyper-V가 설치되었다면, VirtualBox를 설치할 필요가 없고 Hyper-V를 이용하면 됩니다. 만약 <a href="devops/docker/">Docker Toolbox</a>를 사용하고 있다면, 이미 일부로서 설치되어 있으므로 그걸 사용하면 됩니다.</p>
</blockquote>
<p>이제 <code>docker-machine</code>을 사용하여 두 대의 VM을 만들어봅시다.</p>
<pre><code class="language-sh">$ docker-machine create --driver virtualbox myvm1
$ docker-machine create --driver virtualbox myvm2
</code></pre>
<h3 id="vm-목록을-조회하고-ip-주소-얻기"><a class="header" href="#vm-목록을-조회하고-ip-주소-얻기">VM 목록을 조회하고 IP 주소 얻기</a></h3>
<p>이제 <code>myvm1</code>과 <code>myvm2</code>라고 명명된 두 가상장비를 얻었습니다.</p>
<p>아래 명령을 사용해서 장비의 목록을 조회하고 IP 주소를 확인해봅시다.</p>
<pre><code class="language-sh">$ docker-machine ls
</code></pre>
<p>그리고 이 명령의 결과를 확인합시다.</p>
<pre><code class="language-sh">$ docker-machine ls

NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS
myvm1   -        virtualbox   Running   tcp://192.168.99.100:2376           v18.09.0
myvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v18.09.0
</code></pre>
<h3 id="스웜-초기화하고-노드-추가하기"><a class="header" href="#스웜-초기화하고-노드-추가하기">스웜 초기화하고 노드 추가하기</a></h3>
<p>첫 번째 장비를 명령을 관리하고 워커들을 승인하는 매니저로 사용하고, 두 번째 장비는 워커로 사용합니다.</p>
<p><code>docker-machine ssh</code> 명령을 사용하여 VM들엑 명령을 전송합니다. <code>myvm1</code> 장비를 스웜 매니저로 만들기 위해 <code>docker swarm init</code> 명령을 지시하고 결과값을 확인합니다.</p>
<pre><code class="language-sh">$ docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr 192.168.99.100&quot;

Swarm initialized: current node (q4hro97lh4c6ry3wdnp9grmwp) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-68gk029aiohwlwkf3zgxfoj0f77x0jfof8wh83bkfmttyhl9ls-9jt74cqp9dzu6neow1pb47npj 192.168.99.100:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
</code></pre>
<blockquote>
<h4 id="포트-2377과-2376"><a class="header" href="#포트-2377과-2376">포트 2377과 2376</a></h4>
<p>항상 2377 포트(스웜 관리 포트)로 <code>docker swarm init</code> 명령과 <code>docker swarm join</code> 명령을 실행하거나 아무 포트번호 없이 실행하면 기본적으로 2377 포트를 점유합니다.</p>
<p><code>docker-machine ls</code> 명령으로 장비 IP는 2376 포트를 포함해서 반환됩니다. 이는 도커 대몬 포트입니다. 이 포트를 사용하지 마세요. 그렇지 않으면 <a href="https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2">에러</a>를 확인할 수 있습니다.</p>
</blockquote>
<blockquote>
<h4 id="ssh를-사용하는데-문제가-있나요--native-ssh-플래그를-사용해보세요"><a class="header" href="#ssh를-사용하는데-문제가-있나요--native-ssh-플래그를-사용해보세요">SSH를 사용하는데 문제가 있나요? -native-ssh 플래그를 사용해보세요.</a></h4>
<p>도커 머신은 <a href="https://docs.docker.com/machine/reference/ssh/#different-types-of-ssh">OS의 SSH를 사용할 수 있게하는 옵션</a>이 있습니다. 어떤 이유로 스웜매니저에 명령을 전송하는데 문제가 있다면, <code>--native-ssh</code> 플래그를 사용해서 ssh를 사용해보세요.</p>
<pre><code class="language-sh">docker-machine --native-ssh ssh myvm1 ...
</code></pre>
</blockquote>
<p>보이는 바와 같이 <code>docker swarm init</code> 명령의 응답은 미리 설정된 <code>docker swarm joing</code> 명령을 포함합니다. 이 명령은 어떤 노트든 추가해서 실행할 수 있습니다. 이 명령을 복사해서 <code>docker-machine ssh</code> 명령을 통해 <code>myvm2</code>에 전송합니다. 이제 <code>myvm2</code>는 워커로서 스웜에 연결되었습니다.</p>
<pre><code class="language-sh">$ docker-machine ssh myvm2 &quot;docker swarm join \
dquote&gt; --token SWMTKN-1-68gk029aiohwlwkf3zgxfoj0f77x0jfof8wh83bkfmttyhl9ls-9jt74cqp9dzu6neow1pb47npj \
dquote&gt; 192.168.99.100:2377&quot;
This node joined a swarm as a worker.
</code></pre>
<p>축하합니다! 이제 첫 번째 스웜을 만들었습니다!</p>
<p>매니저에서 <code>docker node ls</code> 명령으로 스웜의  노드듣을 확인해봅시다.</p>
<pre><code class="language-sh">$docker-machine ssh myvm1 &quot;docker node ls&quot;

ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
q4hro97lh4c6ry3wdnp9grmwp *   myvm1               Ready               Active              Leader              18.09.0
ve4jyfs9zzq5ncinylszk1qvc     myvm2               Ready               Active                                  18.09.0
</code></pre>
<blockquote>
<h4 id="스웜-떠나기"><a class="header" href="#스웜-떠나기">스웜 떠나기</a></h4>
<p>만약 다시 시작하고 싶으면, <code>docker swarm leave</code>를 각 노드에서 실행하면 됩니다.</p>
</blockquote>
<p>myvm2에서 명령을 실행하면, 아래와 같이 <code>STATUS</code>가 <code>Down</code>으로 바뀐다.</p>
<pre><code class="language-sh">$ docker-machine ssh myvm2 &quot;docker swarm leave&quot;

ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
q4hro97lh4c6ry3wdnp9grmwp *   myvm1               Ready               Active              Leader              18.09.0
ve4jyfs9zzq5ncinylszk1qvc     myvm2               Down                Active                                  18.09.0
</code></pre>
<h2 id="스웜-클러스터에-애플리케이션-배포하기"><a class="header" href="#스웜-클러스터에-애플리케이션-배포하기">스웜 클러스터에 애플리케이션 배포하기</a></h2>
<p>어려운 부분은 지나갔습니다. 이제 애플리케이션을 스웜에 배포하기 위해서 Part 3에서 했던 과정을 반복하면 됩니다. <code>myvm1</code> 처럼 하나의 스웜 매니저가 Docker 명령을 실행하는 것만 기억하세요. 워커는 작업의 수용력을 위한 것들입니다.</p>
<h3 id="스웜-매니저의-docker-machine-셸-설정하기"><a class="header" href="#스웜-매니저의-docker-machine-셸-설정하기">스웜 매니저의 <code>docker-machine</code> 셸 설정하기</a></h3>
<p>지금까지 Docker 명령을 <code>docker-machine ssh</code>으로 래핑해서 VM과 통신했습니다. 다른 방법으로 <code>docker-machine env &lt;장비명&gt;</code>을 실행해서 VM의 도커 대몬과 통신하기 위해 현재 셸을 설정할 수 있습니다. 이는 다음 단계를 위한 더 좋은 방법입니다. 이는 로컬환경의 <code>docker-compose.yml</code> 파일을 사용해서 어떤 복사본 없이 어디에든지 &quot;원격&quot;으로 애플리케이션을 배포할 수 있게 허용하기 때문입니다.</p>
<p><code>docker-machine env myvm1</code>을 타이핑하고 명령을 수행한 수, 콘솔 결과를 확인하세요. 그리고 마지막 줄의 <code>myvm1</code>과 통신하기 위한 셸 설정 명령을 실행해보세요.</p>
<h4 id="mac-혹은-linux의-docker-장비-셸-환경-설정"><a class="header" href="#mac-혹은-linux의-docker-장비-셸-환경-설정">Mac 혹은 Linux의 Docker 장비 셸 환경 설정</a></h4>
<p><code>docker-machine env myvm1</code> 명령을 실행해서 <code>myvm1</code>과 통신하기 위한 셸 설정 명령을 확인하세요.</p>
<pre><code class="language-sh">$ docker-machine env myvm1

export DOCKER_TLS_VERIFY=&quot;1&quot;
export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;
export DOCKER_CERT_PATH=&quot;/Users/sshplendid/.docker/machine/machines/myvm1&quot;
export DOCKER_MACHINE_NAME=&quot;myvm1&quot;
# Run this command to configure your shell:
# eval $(docker-machine env myvm1)
</code></pre>
<p><code>myvm1</code>과 통신하기 위한 셸 설정 명령을 실행하세요.</p>
<pre><code class="language-sh">$ eval $(docker-machine env myvm1)
</code></pre>
<p><code>docker-machine ls</code>를 실행해서 <code>myvm1</code>이 <code>*</code> 로 표시된, 활성화된 장비임을 검증하세요.</p>
<pre><code class="language-sh">$ docker-machine ls

NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS
myvm1   *        virtualbox   Running   tcp://192.168.99.100:2376           v18.09.0
myvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v18.09.0
</code></pre>
<h3 id="스웜-매니저-상에서-애플리케이션-배포하기"><a class="header" href="#스웜-매니저-상에서-애플리케이션-배포하기">스웜 매니저 상에서 애플리케이션 배포하기</a></h3>
<p>이제 <code>myvm1</code>이 있으니, Part 3에서 사용했던 <code>docker stack deploy</code> 명령과 로컬 파일 <code>docker-compose.yml</code> 으로 <code>myvm1</code>에 애플리케이션을 배포해야 합니다. 이 명령은 완료될 때 까지 몇 초가 걸리고 배포된 애플리케이션은 얼마가 지나야 가용상태가 됩니다. <code>docker service ps &lt;서비스 이름&gt;</code> 명령으로 모든 재배포된 서비스를 검증하세요.</p>
<p><code>docker-machine</code> 셸 설정으로 <code>myvm1</code>에 연결되었습니다. 그리고 여전히 로컬 호스트의 파일에 접근할 수 있습니다. 이전에 <code>docker-compose.yml</code> 파일을 작성했던 디렉토리 위치를 확인하세요. 그리고 그 위치에서 <code>myvm1</code> 상에 애플리케이션 배포를 위한 다음 명령을 실행하세요.</p>
<pre><code class="language-sh">$ docker stack deploy -c docker-compose.yml getstartedlab
</code></pre>
<p>이제 다 됐습니다. 애플리케이션이 스웜 클러스터에 배포되었습니다!</p>
<blockquote>
<p>Note: 만약 이미지가 Docker Hub 대신 개인 저장소에 저장되어 있다면, <code>docker login &lt;레지스트리 명&gt;</code>으로 로그인한 다음 <code>--with-registry-auth</code> 플래그를 추가합니다. 아래처럼 하면 됩니다.</p>
<pre><code class="language-sh">docker login registry.example.com

docker stack deploy --with-registry-auth -c docker-compose.yml getstartedlab
</code></pre>
<p>이는 암호화된 WAL 로그를 사용해서 로컬 클라이언트로부터 서비스가 배포된 스웜 노드까지 통과하게 합니다. 이 정보로, 노드는 레지스트리에 접속 가능해지고 이미지를 받아올 수 있습니다.</p>
</blockquote>
<p>이제 <a href="devops/docker/./get-started-part3.html#a%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8A%A4-%EB%90%9C-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0">Part 3에서 사용된 도커 명령</a>을 사용해야 합니다. 오직 이번만 <code>myvm1</code>과 <code>myvm2</code> 사이에 분산된 서비스를 알아차릴 것입니다.</p>
<pre><code class="language-sh">$ docker stack ps getstartedlab

ID                  NAME                  IMAGE                          NODE                DESIRED STATE       CURRENT STATE         ERROR               PORTS
219e9nvteidh        getstartedlab_web.1   sshplendid/get-started:part2   myvm1               Running             Running 6 hours ago
uczmecew5lcc        getstartedlab_web.2   sshplendid/get-started:part2   myvm3               Running             Running 6 hours ago
uoc8ulrnurdk        getstartedlab_web.3   sshplendid/get-started:part2   myvm2               Running             Running 6 hours ago
zp1553lrlph1        getstartedlab_web.4   sshplendid/get-started:part2   myvm3               Running             Running 6 hours ago
tzys637kf3hv        getstartedlab_web.5   sshplendid/get-started:part2   myvm2               Running             Running 6 hours ago
</code></pre>
<blockquote>
<h4 id="docker-machine-env와-docker-machine-ssh로-vm에-연결하기"><a class="header" href="#docker-machine-env와-docker-machine-ssh로-vm에-연결하기"><code>docker-machine env</code>와 <code>docker-machine ssh</code>로 VM에 연결하기</a></h4>
<ul>
<li><code>myvm2</code>처럼 다른 장비와 통신하기 위해 셸을 설정하려면, 간단하기 <code>docker-machine env</code> 명령을 셸에서 재실행하고 주어진 명령을 실행하면 됩니다. 이건 항상 현재 셸에서만 한정되는 명령입니다. 만약 설정되지 안흥ㄴ 셸로 변경하거나 새로운 셸을 열면, 이 명령을 재실행해야 합니다. <code>docker-machine ls</code> 명령을 사용해서 장비들을 조회하고, 각 장비가 어떤 상태인지 확인하고, IP 주소를 확인한 후, 어떤 장비에 연결되어 있는지 확인하세요. 더 알고 싶다면, <a href="https://docs.docker.com/machine/get-started/#use-machine-to-run-docker-containers">Docker Machine 시작하기</a> 문서를 살펴보세요.</li>
<li>대안으로, Docker 명령을 아래와 같은 형식으로 감싸서 사용할 수 있습니다. 이는 VM에 직접적으로 기록되지만, 로컬 호스트의 파일에 직접 접근하지 못합니다.</li>
<li>Mac이나 Linux에서, <code>docker-machine scp &lt;파일 명&gt; &lt;장비 명&gt;:~</code> 명령을 사용해서 장비 간 파일 복사가 가능합니다. 그러나 윈도우즈 사용자는 <a href="https://gitforwindows.org/">Git Bash</a> 같은 리눅스 터미널 에뮬레이터가 필요합니다.</li>
</ul>
<p>모든 플랫폼에서 <code>docker-machine</code> CLI를 사용할 수 있기 때문에, <code>docker-machine ssh</code>와 <code>docker-machine env</code> 튜토리얼 데모가 가능합니다.</p>
</blockquote>
<h3 id="클러스터에-접근하기"><a class="header" href="#클러스터에-접근하기">클러스터에 접근하기</a></h3>
<p>이제 <code>myvm1</code> 혹은 <code>myvm2</code>의 IP 주소로 애플리케이션에 접근할 수 있습니다.</p>
<p>생성된 네트워크는 그 장비들과 로드-밸런싱 사이에서 공유됩니다. <code>docker-machine ls</code> 명령을 실행해서 VM 장비들의 IP주소를 확인하고 각 장비에 브라우져를 통해 접속해보세요. (간단하게 <code>curl</code>을 사용할 수도 있습니다.)</p>
<p>여기, 로드-밸런싱 중인, 무작위로 순환하는 다섯 컨테이너가 있습니다. </p>
<p>두 IP 주소 모두 작동하는 이유는 스웜에 참가하는 노드가 **라우팅 메시(routing mesh)**에 진입했기 때문입니다. 이는 스웜 내 특정 포트에 배포된 서비스들이 항상 서비스 자신이 예약한 포트를 소유하고 있음을, 노드가 실제로 컨테이너를 구동 중이더라도, 반드시 보장하게 합니다. 여기 세 노드를 가진 스웜의 <code>8080</code> 포트에 배포된, <code>my-web</code>이라고 불리는 서비스를 위한 라우팅 메시가 어떻게 작동하는지에 대한 다이어그램을 확인해보세요.</p>
<p><img src="https://docs.docker.com/engine/swarm/images/ingress-routing-mesh.png" alt="routing mesh" /></p>
<blockquote>
<h4 id="연결에-문제가-있나요"><a class="header" href="#연결에-문제가-있나요">연결에 문제가 있나요?</a></h4>
<p>스웜 내에서 진입 네트워크를 사용하는 것은 스웜모드를 활성화하기 전에 스웜 노드 사이에 아래 포트를 개방해야 하는 것을 명심하세요.</p>
<ul>
<li>컨테이너 네트워크 탐색을 위한 7946 TCP/UDP 포트</li>
<li>컨테이너 진입 네트워크를 위한 4789 UDP 포트</li>
</ul>
</blockquote>
<h2 id="애플리케이션-규모-조절하기-및-반복하기"><a class="header" href="#애플리케이션-규모-조절하기-및-반복하기">애플리케이션 규모 조절하기 및 반복하기</a></h2>
<p>여기부턴 Part 2와 Part 3에선 배운 모든 작업을 반복합니다.</p>
<p><code>docker-compose.yml</code> 파일을 변경함으로서 애플리케이션의 규모를 조절합니다.</p>
<p>코드를 수정하고, 다시 빌드하고, 새로운 이미지를 생성함으로써, 애플리케이션의 행동을 변경합니다. (이를 위해, 이전에 배운 <a href="devops/docker/./get-started-part2.html#a%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0">애플리케이션 빌드하기</a>와 <a href="devops/docker/./get-started-part2.html#a%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B0%9C%ED%96%89%ED%95%98%EA%B8%B0">이미지 생성하기</a> 단계를 반복합니다).</p>
<p>어느 쪽이던, <code>docker stack deploy</code> 명령으로 간단하게 변경사항을 배포할 수 있습니다.</p>
<p>어떤 물리적/가상화된 장비이건, <code>docker swarm join</code> 명령으로, 스웜에 연결할 수 있습니다. <code>myvm2</code>에 사용했던 것처럼요. 그럼 클러스터의 수용력이 늘어날 것입니다. 간단하게 <code>docker stack deploy</code> 명령을 그 뒤에 실행하면, 애플리케이션은 새로운 자원을 활용할 수 있을 것입니다.</p>
<h2 id="클린업과-리부트"><a class="header" href="#클린업과-리부트">클린업과 리부트</a></h2>
<h3 id="스택과-스웜"><a class="header" href="#스택과-스웜">스택과 스웜</a></h3>
<p><code>docker stack rm</code> 명령으로 스택을 내릴 수 있습니다.</p>
<pre><code class="language-sh">docker stack rm getstartedlab
</code></pre>
<blockquote>
<h4 id="스웜을-유지하거나-삭제하기"><a class="header" href="#스웜을-유지하거나-삭제하기">스웜을 유지하거나 삭제하기</a></h4>
<p>만약 스웜을 제거하고 싶다면 매니저와 워커 각각 아래 명령으로 제거할 수 있습니다.</p>
<ul>
<li>워커: <code>docker-machine ssh myvm2 &quot;docker swarm leave&quot;</code></li>
<li>매니저: <code>docker-machine ssh myvm1 &quot;docker swarm leave --force&quot;</code></li>
</ul>
<p>하지만 Part 5에서 스웜이 필요하기 때문에, 당분간 유지해야 합니다.</p>
</blockquote>
<h3 id="docker-machine-셸-변수-설정-해제하기"><a class="header" href="#docker-machine-셸-변수-설정-해제하기">docker-machine 셸 변수 설정 해제하기</a></h3>
<p>아래 명령으로 <code>docker-machine</code> 환경 변수를 해제할 수 있습니다.</p>
<p>Mac과 Linux 환경</p>
<pre><code class="language-sh">eval $(docker-machine env -u)
</code></pre>
<p>Windows 환경</p>
<pre><code class="language-bat">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env -u | Invoke-Expression
</code></pre>
<p>이 명령은 <code>docker-machine</code>으로 생성된 가상 장비로부터 셸 접속을 끊고, 동일한 셸에서 네이티브 <code>docker</code> 명령을 사용할 수 있게 합니다. 더 알고 싶다면, <a href="https://docs.docker.com/machine/get-started/#unset-environment-variables-in-the-current-shell">환경 변수 해제하기에 대한 Machine 토픽</a>에 대해서 알아보세요.</p>
<h3 id="docker-machine-재시작하기"><a class="header" href="#docker-machine-재시작하기">Docker machine 재시작하기</a></h3>
<p>만약 로컬 호스트 장비를 정지시켰다면, 도커 머신 역시 정지합니다. <code>docker-machine ls</code> 명령으로 각 장비의 상태를 확인할 수 있습니다.</p>
<pre><code class="language-sh">$ docker-machine ls

NAME    ACTIVE   DRIVER       STATE     URL   SWARM   DOCKER    ERRORS
myvm1   -        virtualbox   Stopped                 Unknown
myvm2   -        virtualbox   Stopped                 Unknown
myvm3   -        virtualbox   Stopped                 Unknown
</code></pre>
<p>재시작하기 위해, 아래 명령을 실행합니다.</p>
<pre><code class="language-sh">docker-machine start &lt;장비 명&gt;
</code></pre>
<p>모든 장비를 재시작하기 위해서, 아래 명령을 실행하면 됩니다.</p>
<pre><code class="language-sh">$ docker-machine start $(docker-machine ls -q) # 모든 장비 시작하기

Starting &quot;myvm3&quot;...
Starting &quot;myvm1&quot;...
Starting &quot;myvm2&quot;...
(myvm3) Check network to re-create if needed...
(myvm3) Waiting for an IP...
Machine &quot;myvm3&quot; was started.
Waiting for SSH to be available...
(myvm1) Check network to re-create if needed...
(myvm1) Waiting for an IP...
(myvm2) Check network to re-create if needed...
(myvm2) Waiting for an IP...
Machine &quot;myvm1&quot; was started.
Waiting for SSH to be available...
Machine &quot;myvm2&quot; was started.
Waiting for SSH to be available...
Detecting the provisioner...
Detecting the provisioner...
Detecting the provisioner...
Started machines may have new IP addresses. You may need to re-run the `docker-machine env` command.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-note"><a class="header" href="#docker-note">Docker note</a></h1>
<h2 id="ubuntu-bash-셸-실행"><a class="header" href="#ubuntu-bash-셸-실행">Ubuntu Bash 셸 실행</a></h2>
<ul>
<li>run 옵션 
<ul>
<li>-it: 터미널 입력을 위한 실행 옵션</li>
<li>--rm: 컨테이너 종료시 컨테이너 자동 제거</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">docker run -it --rm ubuntu bash
</code></pre>
<h3 id="로컬-드라이브-볼륨-마운트"><a class="header" href="#로컬-드라이브-볼륨-마운트">로컬 드라이브 볼륨 마운트</a></h3>
<p>도커 실행(<code>docker run</code>)할 때, <code>-v 로컬호스트디렉토리:컨테이너디렉토리</code> 로 마운트 </p>
<h4 id="볼륨-마운트-테스트"><a class="header" href="#볼륨-마운트-테스트">볼륨 마운트 테스트</a></h4>
<pre><code class="language-bash"># 로컬 볼륨 마운트 테스트 
&gt; mkdir docker-vol # 로컬 디렉토리 생성
$ echo &quot;테스트 파일&quot; &gt; test.txt # 로컬 파일 생성 
$ docker run -it -v c:/Users/Administrator/docker-vol:/vol-test ubuntu bash

$ cd vol-test
$ cat test.txt
# 파일내용이 나오면 정상적으로 마운트된것

# 컨테이너 -&gt; 로컬 파일 테스트
$ echo 'This file is created from container.' &gt; from-container.txt
$ exit # 컨테이너 종료

&gt; type from-container.txt # cat과 동일한 Windows 명령
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="개발환경-세팅"><a class="header" href="#개발환경-세팅">개발환경 세팅</a></h1>
<h2 id="mariadb-연결"><a class="header" href="#mariadb-연결">MariaDB 연결</a></h2>
<pre><code class="language-bash">$ docker run --name maria -v c:/dev/docker/vol-maria:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mariadb
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="언어를-배우며"><a class="header" href="#언어를-배우며">언어를 배우며</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">Java</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparable-vs-comparator"><a class="header" href="#comparable-vs-comparator">Comparable VS Comparator</a></h1>
<h2 id="comparable"><a class="header" href="#comparable">Comparable</a></h2>
<p><code>Comparable</code> 인터페이스는 상속받는 클래스가 생성한 객체 사이의 <em>자연스러운 정렬</em> 이 가능하도록 도입되었다. 인터페이스를 상속받은 클래스는 <code>compareTo</code> 메서드를 구현해야 하며 이는 객체 사이의 비교를 담당하며 <code>Arrays.sort</code>나 <code>Collections.sort</code> 같은 정렬 API에서 사용한다.</p>
<p>아래와 같은 클래스에서 인터페이스를 상속받고 메서드를 구현했다. 이름의 오름차순으로 구현했으며, 이는 다음 테스트 코드와 같이 동작한다.</p>
<pre><code class="language-java">// Comparable 구현
class Fruit implements Comparable&lt;Fruit&gt; {
	private String name;
	private int price;
	Fruit(String name, int price) {
		this.name = name;
		this.price = price;
	}
	@Override
	public int compareTo(Fruit o) {
		Fruit f = (Fruit) o;
		return this.name.compareTo(f.name);
	}
	public String getName() {
		return name;
	}
	public int getPrice() {
		return price;
	}
}
</code></pre>
<pre><code class="language-java">// Comparable의 동작
public class CompareTest {
	@Test
	public void ObjectComparableTest() {
		Fruit[] f = new Fruit[4];
		f[0] = new Fruit(&quot;Orange&quot;, 10);
		f[1] = new Fruit(&quot;Mango&quot;, 70);
		f[2] = new Fruit(&quot;Melon&quot;, 50);
		f[3] = new Fruit(&quot;Apple&quot;, 20);

		String[] alphabet = {&quot;Apple&quot;, &quot;Mango&quot;, &quot;Melon&quot;, &quot;Orange&quot;};
		/**
		 * Fruit 클래스는 기본적으로 이름을 기준으로 비교한다.
		 */
		Arrays.sort(f);
		for(int i = 0; i &lt; 4; i++)
			assertTrue(f[i].getName().equals(alphabet[i]));
	}
}
</code></pre>
<h2 id="comparator"><a class="header" href="#comparator">Comparator</a></h2>
<p>하지만 어떤 동작에선 이름이 아니라 가격으로 비교해야 할 경우가 있다고 가정하자. 그리고 이름으로 정렬하는 기능도 동시에 사용해야 한다. 이럴 땐 <code>Comparator</code>를 사용해서 상황별 정렬 기준 변경이 가능하다.</p>
<pre><code class="language-java">public class CompareTest {
	@Test
	public void ObjectComparatorTest() {
		Fruit[] f = new Fruit[4];
		f[0] = new Fruit(&quot;Orange&quot;, 10);
		f[1] = new Fruit(&quot;Mango&quot;, 70);
		f[2] = new Fruit(&quot;Melon&quot;, 50);
		f[3] = new Fruit(&quot;Apple&quot;, 20);

		String[] cheap = {&quot;Orange&quot;, &quot;Apple&quot;, &quot;Melon&quot;, &quot;Mango&quot;};

		/**
		 * 이름 대신 가격으로 비교하고 싶다
		 * 그럼 비교할 때마다 비교로직을 변경해야 하는가?
		 * 이름과 가격 둘 다 비교해야 하는 경우는 어떻게 해야하나?
		 */
		Arrays.sort(f, new Comparator&lt;Fruit&gt;() {

			@Override
			public int compare(Fruit o1, Fruit o2) {
				// 오름차순
				return o1.getPrice() - o2.getPrice();
			}

		});

		for(int i = 0; i &lt; 4; i++)
			assertTrue(f[i].getName().equals(cheap[i]));
	}

	@Test
	public void ObjectComparatorDescendingTest() {
		Fruit[] f = new Fruit[4];
		f[0] = new Fruit(&quot;Orange&quot;, 10);
		f[1] = new Fruit(&quot;Mango&quot;, 70);
		f[2] = new Fruit(&quot;Melon&quot;, 50);
		f[3] = new Fruit(&quot;Apple&quot;, 20);

		String[] expensive = {&quot;Mango&quot;, &quot;Melon&quot;, &quot;Apple&quot;, &quot;Orange&quot;};

		Arrays.sort(f, new Comparator&lt;Fruit&gt;() {

			@Override
			public int compare(Fruit o1, Fruit o2) {
				return o2.getPrice() - o1.getPrice();
			}

		});

		for(int i = 0; i &lt; 4; i++)
			assertTrue(f[i].getName().equals(expensive[i]));
	}
}
</code></pre>
<p>위 테스트 코드는 이미 <code>Comparable</code>로 구현된 Fruit 객체를 정렬해야하는 상황 별로 <strong>price</strong> 오름차순, 내림차순으로 정렬하고 있다. 이는 클래스의 비교로직에 영향을 끼치지 않으며 익명 객체가 사용된 코드에만 영향을 미친다.</p>
<p><a href="https://brunch.co.kr/@kd4/7">Java의 Comparable, Comparator</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log와-logger-차이-그리고-다른-로깅-프레임워크"><a class="header" href="#log와-logger-차이-그리고-다른-로깅-프레임워크"><code>Log</code>와 <code>Logger</code> 차이, 그리고 다른 로깅 프레임워크</a></h1>
<p>결론적으로 사용하는 API의 차이</p>
<h2 id="commons-logging"><a class="header" href="#commons-logging">Commons Logging</a></h2>
<pre><code class="language-java">import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

class Foo {
    private static final Logger LOG = Logger.getLogger(Foo.class);
}
</code></pre>
<h2 id="log4j"><a class="header" href="#log4j">Log4J</a></h2>
<pre><code class="language-java">import org.apache.log4j.Logger;

class Foo {
    private static final Log LOGGER = LogFactory.getLog(Foo.class);
}
</code></pre>
<h2 id="slf4j"><a class="header" href="#slf4j">Slf4J</a></h2>
<ul>
<li><code>Log4J</code>를 만든 Ceki Gülcü가 만든 프레임워크.</li>
<li>Logging Facade로 <a href="lang/java/">LOGback</a>, <a href="lang/java/">LOG4J</a>, <a href="lang/java/">Commons Logging</a> 등 구현체 프레임워크와 상관 없이 일관된 코드 작성 가능</li>
<li>참고: <a href="https://beyondj2ee.wordpress.com/2012/11/09/logback-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-reasons-to-prefer-logback-over-log4j/">logback 사용해야 하는 이유 (Reasons to prefer logback over log4j)</a></li>
</ul>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

class Foo {
    private static final Logger LOGGER = LoggerFactory.getLogger(Foo.class);
}
</code></pre>
<h2 id="logback"><a class="header" href="#logback">LOGback</a></h2>
<ul>
<li>LOG4J의 아키텍쳐 기반</li>
<li>메모리 점유율 및 속도 등 비약적인 성능 개선</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ibm---java-dump-분석"><a class="header" href="#ibm---java-dump-분석">IBM - Java Dump 분석</a></h1>
<p>아래 IBM 문서를 보고 Javadump를 살펴보았다.
<a href="https://www.ibm.com/support/knowledgecenter/ko/SSYKE2_7.0.0/com.ibm.java.win.70.doc/diag/tools/javadump_interpret.html">IBM - Javadump 해석</a>
<a href="http://d2.naver.com/helloworld/10963">Naver D2 - 스레드 덤프 분석하기</a></p>
<h2 id="덤프의-종류"><a class="header" href="#덤프의-종류">덤프의 종류</a></h2>
<p>Heap Dump, Java Dump, Thread Dump, java core 등의 파일은 Java 어플리케이션의 비정상적인 상황(OOM, Hang, ...)에서 생성되는 파일이다. 이 파일들은 장애 발생 당시의 JVM 정보를 가지고 있다.</p>
<ul>
<li>Javadump: Java core 혹은 Thread dump라고 불린다. OOM같은 상황에서 JVM이 의도치않게 종료된 경우 예약된 키 조합(ex. Windows: <code>Ctrl + Break</code>, Unix: <code>kill -3 &lt;pid&gt;</code>)으로 생성된다. 혹은 어플리케이션 내부에서 <code>com.ibm.jvm.Dump.JavaDump</code> API를 사용해서 생성할 수도 있다. </li>
<li>Heapdump: 예기치않게 JVM이 종료된 경우 사용자의 요청 혹은 <code>Xdump:heap</code> 옵션을 사용해서 힙 덤프 생성시점을 제어할 수 있다. </li>
</ul>
<h3 id="덤프가-생성되지-않을-때"><a class="header" href="#덤프가-생성되지-않을-때">덤프가 생성되지 않을 때</a></h3>
<p>일부 상황에선 덤프가 생성되지 않을 수도 있다. 이땐 시스템 덤프를 확인해보자. 자세한 내용은 아래 문서 참고<br />
<a href="https://www.ibm.com/support/knowledgecenter/ko/SSYKE2_7.0.0/com.ibm.java.aix.70.doc/diag/tools/scenarioswheredumpsmightnotbeproduced.html">덤프가 생성되지 않는 경우의 시나리오</a></p>
<h2 id="그래서-javadump는"><a class="header" href="#그래서-javadump는">그래서 javadump는?</a></h2>
<p>Javadump는 JVM / Java 어플리케이션 실행 중의 특정 시점에서 캡쳐된 진단정보가 포함된 파일이다. 이 파일엔 운영 체제, 어플리케이션 환경, 스레드, 스택, 메모리 등의 정보가 포함된다. 파일은 텍스트 형식으로 사용자가 읽을 수 있으며 Java Object 컨텐츠나 데이터는 포함되지 않는다.</p>
<ul>
<li>스레드 ID와 플래그를 포함한 스레드 이름</li>
<li>개수와 플래그를 포함하는 클래스 로더 이름</li>
<li>클래스 및 메소드 이름</li>
<li>일부 Heap 주소</li>
</ul>
<p>어플리케이션을 시작할 때 <code>-Xdump:java:</code> 플래그를 사용해서 파일 생성을 제어할 수 있다. 파일 이름은 <code>javacore.&lt;date&gt;.&lt;time&gt;.&lt;pid&gt;.&lt;sequence number&gt;.txt</code>로 네이밍된다. Javacore는 시스템 덤프에서 생성하는 <strong>코어 파일</strong> 과는 다르다.</p>
<h3 id="덤프파일-생성방법"><a class="header" href="#덤프파일-생성방법">덤프파일 생성방법</a></h3>
<ul>
<li>Java 옵션 사용: <code>XDump:java</code> 옵션을 사용해서 덤프 생성을 제어할 수 있다.</li>
</ul>
<h4 id="오류-조건에-의해-생성된-javadump"><a class="header" href="#오류-조건에-의해-생성된-javadump">오류 조건에 의해 생성된 JavaDump</a></h4>
<p>아래 조건과 일치하는 상황이 발생하면 Javadump는 자동으로 생성된다.</p>
<ul>
<li>복구할 수 없는 기본 예외: JVM이 중지되는 예외상황이다. JVM은 시스템 덤프를 생성하고 스냅 추적파일 및 Javadump를 생성한 후에 프로세스를 종료한다. <strong>Java 예외상황이 아니다.</strong></li>
<li>JVM 메모리 부족: <code>OOME</code>같은 메모리 부족 상황에서 자동 생성된다.</li>
</ul>
<h4 id="요청에-의한-생성"><a class="header" href="#요청에-의한-생성">요청에 의한 생성</a></h4>
<p>사용자의 요청 혹은 API 호출로 덤프가 생성되는 경우이다.</p>
<ul>
<li>Command Line에서 JVM에 신호를 송신: <code>kill -3 &lt;pid&gt;</code>를 사용해서 Java 프로세스에 덤프 생성 신호를 보낼 수 있다. 이 경우 JVM은 덤프파일을 생성하고 계속 실행된다.</li>
<li><code>com.ibm.jvm.Dump.JavaDump</code> API 사용: 이 API를 호출하면 덤프파일이 생성된다. 동일하게 JVM은 계속 실행된다.</li>
<li><strong>WAS Utility</strong> 에 의한 생성: Weblogic과 같은 Middleware 환경에서 미들웨어 유틸리티를 사용해서 덤프를 생성 가능하다.</li>
</ul>
<h2 id="덤프-해석"><a class="header" href="#덤프-해석">덤프 해석</a></h2>
<h3 id="javadump-태그"><a class="header" href="#javadump-태그">Javadump 태그</a></h3>
<p>Dump 파일은 아래와 같이 섹션(<code>SECTION</code>)으로 구분되어 있다.</p>
<pre><code class="language-log">0SECTION       TITLE subcomponent dump routine
NULL           ===============================
1TISIGINFO     Dump Event &quot;systhrow&quot; (00040000) Detail &quot;java/lang/OutOfMemoryError&quot; received 
1TIDATETIME    Date:                 2017/10/26 at 14:39:07
1TIFILENAME    Javacore filename:    /USER/javacore.20171026.143904.33947784.0001.txt
1TIREQFLAGS    Request Flags: 0x81 (exclusive+preempt)
1TIPREPSTATE   Prep State: 0x104 (exclusive_vm_access+)
NULL           ------------------------------------------------------------------------
</code></pre>
<p>일반적인 태그는 아래와 같은 규칙을 가지고 있다.</p>
<ul>
<li>태그는 최대 15자이다.(빈 부분은 공백으로 채움)</li>
<li>첫 번째 숫자는 태그 레벨을 나타낸다. 이 숫자는 항상 순서대로 오더링되진 않는다.(2 뒤에 4, 혹은 3 뒤에 1이 나올 수 있다.)</li>
<li>태그의 두 번째와 세 번째 문자는 덤프 섹션을 식별한다. 아래는 주요 섹션을 나타내고 그 외에도 다른 섹션이 존재한다.
<ul>
<li>CI: 명령행 인터프리터</li>
<li>CL: 클래스 로더</li>
<li>LK: LOCK</li>
<li>ST: 스토리지(메모리 관리)</li>
<li>TI: 제목</li>
<li>XE: 실행 엔진</li>
</ul>
</li>
<li>나머지는 고유 문자열이다.</li>
<li>모든 섹션은 <code>0SECTION</code> 태그로 헤드가 지정된다.</li>
<li><code>NULL</code> 태그는 가독성을 위한 태그이다. 정보를 구분하는 용도로 사용한다.</li>
</ul>
<h3 id="title-gpinfo-envinfo-섹션"><a class="header" href="#title-gpinfo-envinfo-섹션">TITLE, GPINFO, ENVINFO 섹션</a></h3>
<h4 id="title"><a class="header" href="#title">TITLE</a></h4>
<p>Javadump 파일이 생성된 이벤트 및 기본정보를 나타낸다. 위의 로그가 TITLE 부분이고 <code>OutOfMemoryErorr</code>에 의한 이벤트 발생임을 알 수 있다.</p>
<h4 id="gpfino"><a class="header" href="#gpfino">GPFINO</a></h4>
<p><a href="https://en.wikipedia.org/wiki/General_protection_fault">GPF</a>로 인해 dump가 생성되었는지 여부에 따라 컨텐츠가 달라지지만 운영체제에 대한 정보가 일부 표시된다. GPF로 인해 생성된 경우 GPF정보가 제공된다.</p>
<pre><code class="language-log">0SECTION       GPINFO subcomponent dump routine
NULL           ================================
2XHOSLEVEL     OS Level         : AIX 6.1
2XHCPUS        Processors -
3XHCPUARCH       Architecture   : ppc64
3XHNUMCPUS       How Many       : 8
3XHNUMASUP       NUMA is either not supported or has been disabled by user
NULL           
1XHERROR2      Register dump section only produced for SIGSEGV, SIGILL or SIGFPE.
NULL           
NULL           ------------------------------------------------------------------------
</code></pre>
<h4 id="envinfo"><a class="header" href="#envinfo">ENVINFO</a></h4>
<p>실패한 JRE 레벨에 대한 정보와 JVM 프로세스 및 환경을 호출한 명령에 대한 세부사항을 나타낸다.</p>
<p>아래 로그를 보면 AIX6.1, JRE 1.6 환경에서 어플리케이션을 실행했고 실행할 때의 자바 옵션, 클래스패스도 확인할 수 있다.</p>
<pre><code class="language-log">0SECTION       ENVINFO subcomponent dump routine
NULL           =================================
1CIJAVAVERSION JRE 1.6.0 AIX ppc64-64 build jvmap6460sr10fp1-20120202_101568 (pap6460sr10fp1-20120321_01(SR10 FP1))
1CIVMVERSION   VM build 20120202_101568
1CIJITVERSION  r9_20111107_21307ifx1
1CIGCVERSION   GC - 20120202_AA
1CIJITMODES    JIT enabled, AOT enabled, FSD disabled, HCR disabled
1CIRUNNINGAS   Running as a standalone JVM
1CICMDLINE     /usr/java6_64/bin/java -DDOMAIN_NAME= -DSERVER_NAME=server1 -Xms2048m -Xmx2048m -Xgcpolicy:gencon -verbosegc -Dweblogic.Name=server1 -Djava.security.policy=/wlserver_10.3/server/lib/weblogic.policy -Dweblogic.ProductionModeEnabled=true -Dweblogic.security.SSL.trustedCAKeyStore=/weblogic/wlserver_10.3/server/lib/cacerts -da -Dplatform.home=/weblogic/wlserver_10.3 -Dwls.home=/weblogic/wlserver_10.3/server -Dweblogic.home=/weblogic/wlserver_10.3/server -Dweblogic.management.discover=false -Dweblogic.management.server=t3://12.30.51.107:6060 -Dwlw.iterativeDev=false -Dwlw.testConsole=false -Dwlw.logErrorsToConsole=false -Dweblogic.ext.dirs=/weblogic/patch_wls1036/profiles/default/sysext_manifest_classpath weblogic.Server
1CIJAVAHOMEDIR Java Home Dir:   /usr/java6_64/jre
1CIJAVADLLDIR  Java DLL Dir:    /usr/java6_64/jre/bin
2CIUSERARG               -DDOMAIN_NAME=
2CIUSERARG               -DSERVER_NAME=server1
2CIUSERARG               -Xms2048m
2CIUSERARG               -Xmx2048m
....
</code></pre>
<h3 id="스토리지-관리meminfo"><a class="header" href="#스토리지-관리meminfo">스토리지 관리(MEMINFO)</a></h3>
<p>MEMINFO 섹션은 Memory에 대한 정보를 제공한다. 제일 먼저 아래 정보를 보면 당시 메모리 사용 현황에 대해서 나온다. 4GB 할당된 상태에서 사용가능한 메모리는 약 44MB 정도였다. </p>
<pre><code class="language-log">0SECTION       MEMINFO subcomponent dump routine
NULL           =================================
1STHEAPFREE    Bytes of Heap Space Free: 2CA0EF0 
1STHEAPALLOC   Bytes of Heap Space Allocated: 80000000 
</code></pre>
<p>아래 덤프는 내부 메모리 섹션(SEGTYPE)이다. 클래스 메모리, JIT 코드 캐시 및 JIT 데이터 캐시등을 포함한다.</p>
<ul>
<li>segment: 세그먼트 제어 데이터 구조의 주소</li>
<li>start: 세그먼트의 시작 주소</li>
<li>alloc: 현재 할당 주소</li>
<li>end: 세그먼트의 끝 주소</li>
<li>type: 세그먼트 특성을 설명하는 내부 비트 필드</li>
<li>size: 세그먼트의 크기, 아래엔 <code>bytes</code>로 표시</li>
</ul>
<pre><code class="language-log">1STSEGTYPE     Internal Memory
NULL           segment          start            alloc            end               type     bytes
1STSEGMENT     00000100207A0C18 000001002C74D948 000001002C74D948 000001002C75D948  01000040 10000
...
1STSEGTYPE     Object Memory
NULL           segment          start            alloc            end               type     bytes
1STSEGMENT     0000010012A345F8 0700000000000000 0700000060000000 0700000060000000  00000009 60000000
NULL           
1STSEGTYPE     Class Memory
NULL           segment          start            alloc            end               type     bytes
1STSEGMENT     00000100153C9A78 0000010016306FD0 00000100163072C0 00000100163072C0  00010040 300
...
NULL           
1STSEGTYPE     JIT Code Cache
NULL           segment          start            alloc            end               type     bytes
1STSEGMENT     00000100139CBF98 000001002ACC3E48 000001002B4C3E48 000001002B4C3E48  00000068 800000
1STSEGMENT     00000100139CBED8 0000010013A143E8 00000100142143E8 00000100142143E8  00000068 800000
NULL           
1STSEGTYPE     JIT Data Cache
NULL           segment          start            alloc            end               type     bytes
1STSEGMENT     00000100139CC198 000001001424BF08 000001001486A1C0 0000010014A4BF08  00000048 800000
NULL           
1STGCHTYPE     GC History  
3STHSTTYPE     05:39:04:720827501 GMT j9mm.100 -   J9AllocateObject() returning NULL! 48 bytes requested for object of class 0000010014C5A010 from memory space 'Generational' id=0000010012A357D8 
3STHSTTYPE     05:39:04:719925874 GMT j9mm.101 -   J9AllocateIndexableObject() returning NULL! 232 bytes requested for object of class 0000010014C599F0 from memory space 'Generational' id=0000010012A357D8 
3STHSTTYPE     05:39:04:719924530 GMT j9mm.84 -   Forcing J9AllocateIndexableObject() to fail due to excessive GC 
3STHSTTYPE     05:39:04:719594780 GMT j9mm.101 -   J9AllocateIndexableObject() returning NULL! 48 bytes requested for object of class 0000010018DCC370 from memory space 'Generational' id=0000010012A357D8 
...
</code></pre>
<h3 id="locks"><a class="header" href="#locks">LOCKS</a></h3>
<h3 id="threads"><a class="header" href="#threads">THREADS</a></h3>
<h3 id="shared-classes"><a class="header" href="#shared-classes">SHARED CLASSES</a></h3>
<h3 id="classes"><a class="header" href="#classes">CLASSES</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jmeter"><a class="header" href="#jmeter">JMeter</a></h1>
<p><a href="http://jmeter.apache.org/">JMeter</a>는 Apache 재단에서 관리하는 Java 기반의 오픈소스 소프트웨어이다. 퍼포먼스 측정과 기능 테스트 등을 위해 설계되었다. 원래 웹 애플리케이션을 테스트하기 위해 개발되었지만 기능이 점점 추가되었다.</p>
<h2 id="jmeter로-할-수-있는-것"><a class="header" href="#jmeter로-할-수-있는-것">JMeter로 할 수 있는 것</a></h2>
<p>JMeter는 애플리케이션/서버/프로토콜의 타입에 따라 다양한 테스트를 할 수 있다.</p>
<blockquote>
<p>Ability to load and performance test many different applications/server/protocol types:</p>
<ul>
<li>Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …)</li>
<li>SOAP / REST Webservices</li>
<li>FTP</li>
<li>Database via JDBC</li>
<li>LDAP</li>
<li>Message-oriented middleware (MOM) via JMS</li>
<li>Mail - SMTP(S), POP3(S) and IMAP(S)</li>
<li>Native commands or shell scripts</li>
<li>TCP</li>
</ul>
</blockquote>
<h2 id="기본-사용법"><a class="header" href="#기본-사용법">기본 사용법</a></h2>
<h2 id="http-tps-부하테스트"><a class="header" href="#http-tps-부하테스트">HTTP TPS 부하테스트</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="this"><a class="header" href="#this">this</a></h1>
<p>메서드 호출시, this는 함수를 호출한 객체를 나타낸다.</p>
<h2 id="global-context"><a class="header" href="#global-context">Global Context</a></h2>
<p><code>this</code>는 global 영역에서 전역객체를 참조한다.</p>
<pre><code class="language-javascript">console.log(this.document === document); // true

// 웹 브라우저의 전역객체는 window
console.log(this === window); // true

this.a = 10;
console.log(window.a); // 10
</code></pre>
<h2 id="function-context"><a class="header" href="#function-context">Function Context</a></h2>
<p>함수 안에서의 <code>this</code>는 함수 호출방법에 따라 달라진다.</p>
<h3 id="단순-함수-호출"><a class="header" href="#단순-함수-호출">단순 함수 호출</a></h3>
<p>아래 경우 <code>this</code>는 호출에 의해 설정되지 않는다. 그리고 <code>strict mode</code>가 아니기 때문에 this는 항상 전역객체에서 기본이 되는 객채여야 한다.</p>
<pre><code class="language-javascript">function foo() {
    return this;
}

console.log(foo() === window); // true, global object
console.log(window.foo() === window); // true, global object
</code></pre>
<p>strict mode 적용시, <code>this</code>는 실행 컨텍스트에 들어갈때 할당된다. 만약 정의가 되지 않았다면 <code>undefined</code>가 된다.</p>
<pre><code class="language-javascript">function bar() {
   &quot;use strict&quot;; // strict mode
   return this;
}

console.log(bar() === undefined); // true, bar를 단독으로 호출했다.
console.log(window.bar() === window); // true, window객체의 메서드로서 호출
</code></pre>
<h3 id="객체의-메서드"><a class="header" href="#객체의-메서드">객체의 메서드</a></h3>
<p>위의 window.bar()처럼 객체의 메서드로 호출되었을 때, this는 메서드를 호출한 객체를 가리킨다.</p>
<pre><code class="language-javascript">var jane = {
    age: 10,
    growUp: function() {
        // jane 객체 하위 메서드로, 함수 호출시 this는 jane을 가리킨다.
        this.age += 1;
        return this.age;
    }
};

console.log(jane.growUp());

var john = {
    age: 10,
};
function growUp () {
    this.age += 1;
    return this.age;
}
john.growUp = growUp;

console.log(john.growUp()); // 11
console.log(growUp()) // NaN, window객체에 age라는 속성이 없기때문에

this.age = 1; // window 객체에 age 속성(수치형)을 생성
console.log(growUp()) // 2
</code></pre>
<h3 id="객체의-prototype"><a class="header" href="#객체의-prototype">객체의 prototype</a></h3>
<p>메서드가 객체의 prototype 체인에 있다면, 메서드는 호출된 객체를 나타낸다.</p>
<pre><code class="language-javascript">var o = {f:function() { return this.a + this.b; }};
var p = Object.create(o);
p.a = 1;
p.b = 2;

console.log(p.f()); // 3, p 객체의 프로퍼티 a(1) + b(2) 를 리턴
</code></pre>
<h3 id="생성자"><a class="header" href="#생성자">생성자</a></h3>
<p>생성자를 통해 생성된 객체를 가리킨다.</p>
<pre><code class="language-javascript">var age = -1; // 전역변수
function Person() {
    this.age = 0;
    this.getAge = function() {
        return this.age;
    };
    this.setAge = function(a) {
        this.age = a;
    }
}

var jane = new Person();
console.log('Jane\'s age: ' + jane.getAge());  // 0, 새롭게 생성된 jane의 age 초기값을 리턴
jane.setAge(10);
console.log('Jane\'s age: ' + jane.getAge());  // 10
console.log('global age: ' + age);             // -1, 전역변수 age는 변동없음
</code></pre>
<h3 id="anonymous-function"><a class="header" href="#anonymous-function">Anonymous function</a></h3>
<p><a href="https://stackoverflow.com/questions/8670877/this-value-in-javascript-anonymous-function">stackoverflow: this value in JavaScript anonymous function</a> 을 읽고 작성했다.</p>
<p>아래 test 함수의 첫 번째 라인을 보자. <code>A</code> 의 <code>this</code>는 test를 호출한 객체를 가리킨다. 마지막 라인의 new MyObject() 생성자를 통해 생성된 객체다.</p>
<p>반면에 <code>B</code> 는 전혀 다른 함수 범위이고, 이 함수를 호출한 객체는 없다. 그러므로 기본 값인 <code>window</code>를 가리킨다.</p>
<pre><code class="language-javascript">function MyObject() { };

MyObject.prototype.test = function () {
    console.log(&quot;A&quot;, this instanceof MyObject);
    (function () {
        console.log(&quot;B&quot;, this instanceof MyObject);
        console.log(&quot;C&quot;, this === window);
    }());
}

// A true
// B false    
new MyObject().test();
</code></pre>
<p>https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: &quot;class&quot;
category: [js]
tags: [javascript, class, es6]</h2>
<h1 id="class"><a class="header" href="#class">class</a></h1>
<p>class는 ES6에서 소개된 문법으로 기존의 프로토타입 기반 상속에 비해 객체 생성과 상속을 다루기 훨씬 간결하고 쉬워졌다.</p>
<pre><code class="language-js">
class Animal {
    constructor() {
        this.stand = false;
    }
    bark() {
        console.log('으르렁!');
    }
}

let lion = new Animal();
lion.bark();
console.assert(!lion.stand, '사자가 직립보행한다고?');
</code></pre>
<p>상속을 받는 경우, 생성자를 구현할 때 반드시 <code>super()</code> 메서드를 추가해야 한다.</p>
<pre><code class="language-js">class Dog extends Animal {
    bark() {
        console.log('멍멍');
    }
}

let jindo = new Dog();
jindo.bark();
console.assert(!jindo.stand, '진돗개가 직립보행한다고?');

class Penguin extends Animal {
    constructor() {
        super();
        this.stand = true;
    }
    
    bark() {
        console.log('펭펭..?');
    }
}

let gentoo = new Penguin();
gentoo.bark();
console.assert(gentoo.stand, '젠투펭귄이 기어간다고? 그럴지도...?');
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hoisting"><a class="header" href="#hoisting">Hoisting</a></h1>
<p><code>var</code> 로 선언된 변수는 코드가 실행되기 전에 선언 처리하기 때문에, 코드 안에서 최상위 단에 선언한 것과 동일하다.</p>
<pre><code class="language-javascript">// case A
a = 1; // 아직 선언되지 않았지만 바로 아래 선언되었기 때문에 B와 같이 동작한다.
var a;

// case B
var a;
a = 1;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iife즉시-실행-함수"><a class="header" href="#iife즉시-실행-함수">IIFE(즉시 실행 함수)</a></h1>
<p>즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 정의되자마자 즉시 실행되는 자바스크립트 함수를 말한다.</p>
<p>이는 Self-Execution Anonymous Function으로 알려진 디자인 패턴이고 크게 두 부분으로 구성된다. 첫 번째는 괄호(<code>()</code>, Grouping Operator)로 둘러싸인 익명함수(Anonymous Function)이다. 이는 전역범위를 오염시키는 것 뿐만 아니라 IIFE 내부의 변수에 접근하는 것을 방지한다.</p>
<p>두 번째 부분은 즉시 실행 함수를 생성하는 괄호<code>()</code>이다. 이를 통해 자바스크립트 엔진은 함수를 즉시 해석해서 실행한다.</p>
<h2 id="예제"><a class="header" href="#예제">예제</a></h2>
<p>아래 함수는 즉시 실행되는 함수 표현이다. 표현 내부의 변수는 외부로부터의 접근이 불가능하다.</p>
<pre><code class="language-javascript">(function() {
  var aName = 'Barry';
})();
// IIFE 내부에서 정의된 변수는 외부 범위에서 접근이 불가능하다.
aName // Uncaught ReferenceError: aName is not defined
</code></pre>
<p>IIFE를 변수에 할당하면 IIFE 자체는 저장되지 않고, 함수가 실행된 결과만 저장된다.</p>
<pre><code class="language-javascript">var result = (function () {
  var name = 'Barry';
  return name;
})();
// 즉시 결과를 생성한다.
console.log(result); // Barry;
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE">IIFE - MDN</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="promise"><a class="header" href="#promise">Promise</a></h1>
<h2 id="callback-hell을-벗어나기-위한-방법"><a class="header" href="#callback-hell을-벗어나기-위한-방법">callback hell을 벗어나기 위한 방법</a></h2>
<p>Promise 객체는 비동기 처리환경에서 이벤트의 처리 완료(혹은 실패) 상태, 그리고 그 결과값을 표현한다. 이는 비동기 메서드가 동기 메서드처럼 결과값을 반환하게 한다.(즉시 결과값을 반환하는 대신에, 비동기 메서드는 미래 어느 시점에서의 결과값을 가진 promise객체로 반환한다.)</p>
<h2 id="상태"><a class="header" href="#상태">상태</a></h2>
<ul>
<li><em>pending</em>(미결): 초기 상태, 아직 <em>fulfilled</em> 혹은 <em>rejected</em> 상태가 아님</li>
<li><em>fulfilled</em>(처리): 동작이 성공적으로 완료됨</li>
<li><em>rejected</em>(실패): 동작이 실패함</li>
</ul>
<p><em>pending</em> 상태의 promise는 결과값을 가진 <em>fulfilled</em> 혹은 에러 이유가 포함된 <em>rejected</em> 가 될 수 있다. 어떤 상태로든 변경이 일어나면, promise <code>then</code> API에 처리 대기상태에 들어간 핸들러가 호출된다.</p>
<p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="Promise의 상태" /></p>
<h2 id="사용방법"><a class="header" href="#사용방법">사용방법</a></h2>
<h3 id="promise-객체-생성하기"><a class="header" href="#promise-객체-생성하기">Promise 객체 생성하기</a></h3>
<p>아래와 같이 Promise 객체를 만들어보자. 비동기 상황을 표현하기 위해 <code>setTimeout</code> API를 사용했다. 랜덤확률에 의해 비동기 동작의 성공, 실패 상황을 분기했다.</p>
<pre><code class="language-javascript">// new
var promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    var probability = Math.random();
    if (probability &gt;= 0.5)
      resolve('async operation success!');
    else
      reject(Error('async operation failed ;('));
  }, 2000);
});

promise.then(console.log, console.error);
</code></pre>
<p>혹은 Promise객체를 리턴하는 함수로 제공할 수 있다.</p>
<pre><code class="language-javascript">    // return
    var promise2 = (param) =&gt; {
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          var probability = Math.random();
          if (probability &gt;= 0.5)
            resolve('2: async operation success!');
          else
            reject(Error('2: async operation failed ;('));
        }, 2000);
      });
    };

    promise2().then(console.log, console.error);
</code></pre>
<h3 id="promise-chainning"><a class="header" href="#promise-chainning">Promise Chainning</a></h3>
<p><code>then</code> API는 다시 pending 상태의 promise 객체를 리턴한다. 이로인해 여러 개의 프로미스를 연결하여 사용할 수 있다.</p>
<pre><code class="language-javascript">    // promise Chaining
    var promise3 = (param) =&gt; {
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          // var probability = Math.random();
          if (true)
            resolve('3: async operation success!');
          else
            reject(Error('3: async operation failed ;('));
        }, 1000);
      });
    };

    promise3().then((result) =&gt; {
      console.log('a: ' + result);
      return 10;
    }).then((result) =&gt; {
      console.log('b: ' + result);
      return result + 10;
    }).then((result) =&gt; {
      console.log('c: ' + result);
    });
</code></pre>
<p>체이닝은 아래와 같이 응용가능하다.</p>
<pre><code class="language-javascript">    // promise chaining2
    var userInfo = '{&quot;name&quot;:&quot;John&quot;, &quot;age&quot;:10}';
    function parseData(data) {
      return JSON.parse(data);
    }
    function auth(data) {
      if(data.name === 'John') {
        return data;
      }
      throw Error(data.name + ' is not an authorized user!');
    }
    function display(data) {
      console.log(`Welcome, ${data.name}!`);
    }
    function getData() {
      return new Promise((resolve) =&gt;{ return resolve(userInfo); });
    }

    getData().then(parseData)
             .then(auth)
             .then(display)
             .catch((err) =&gt; {console.error(err.message);});
    // Welcome, John!
</code></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>위 promise chaining2 예제에서 이름을 Jane을 바꾸면 auth 함수에서 에러가 발생한다. 체인에서 발생한 에러는 <code>catch</code> API로 처리한다.</p>
<pre><code class="language-javascript">    // Error Handling
    userInfo = '{&quot;name&quot;:&quot;Jane&quot;, &quot;age&quot;:10}';
    getData().then(parseData)
             .then(auth)
             .then(display)
             .catch((err) =&gt; {console.error(err.message);});
    // Jane is not an authorized user!
</code></pre>
<h3 id="promiseall-api"><a class="header" href="#promiseall-api">Promise.all API</a></h3>
<p>2 건 이상의 비동기 동작을 처리해야할 경우 <code>all</code> API를 사용해보자.</p>
<p>아래 코드는 셔츠, 바지, 자켓을 입는 함수이다. 자켓은 셔츠를 입은 후에 착용해야 한다. 이는 셔츠와 바지를 입는 순서는 상관 없다는 의미이다.</p>
<pre><code class="language-javascript">    // all API
    var body = {jacket:false, shirt:false, pants:false};
    function wearAShirt(body) {
      return new Promise((resolve) =&gt; {
        if(body.jacket)
          throw Error('셔츠를 입고 자켓을 입어야지.');
        body.shirt = true;
        console.log('셔츠를 입었다.');
        return resolve(body);
      });
    }
    function wearAJacket(body) {
      return new Promise((resolve) =&gt; {
        if(body.shirt) {
          console.log('자켓을 입었다.');
          body.jacket = true;
          return resolve(body);
        } else {
          throw Error('셔츠를 입고 자켓을 입어야지.');
        }
      });
    }
    function wearPants(body) {
      return new Promise((resolve) =&gt; {
        console.log('바지를 입었다.');
        body.pants = true;
        return resolve(body);
      });
    }
    function howDoILook(body) {
      body.shirt?console.log('셔츠를 입었네.'):null;
      body.jacket?console.log('자켓을 입었네.'):null;
      body.pants?console.log('바지를 입었네.'):null;
    }

    Promise.all([wearAShirt(body), wearPants(body)])
           .then(values =&gt; {return wearAJacket(values[0]);})
           .then(howDoILook)
           .catch(() =&gt; {console.log('잘못입었네.');});
</code></pre>
<p>셔츠와 바지는 all API로 처리하고 자켓은 then API로 처리한다.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise - MDN</a><br />
<a href="http://bcho.tistory.com/1086">빠르게 훝어 보는 node.js - promise를 이용한 node.js에서 콜백헬의 처리</a><br />
<a href="https://medium.com/witinweb/%EB%B2%88%EC%97%AD-promise-patterns-anti-patterns-4065d8c26e89">Promise Patterns &amp; Anti-Patterns</a><br />
<a href="https://joshua1988.github.io/web-development/javascript/promise-for-beginners/">자바스크립트 Promise 쉽게 이해하기</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript의-strict-mode"><a class="header" href="#javascript의-strict-mode">JavaScript의 strict mode</a></h1>
<p><strong>strict mode</strong> 는 ES5에 새롭게 추가된 기능으로, <code>strict context</code>에서 동작하고 기존에 그냥 넘어갔던 불안전한 코드에 대해 예외를 발생시킨다.</p>
<ul>
<li>공통적으로 저지르는 코드 실수를 잡아 예외를 발생시킨다.</li>
<li>(전역 객체에 접근하는 것과 같은) 비교적 불안전한 동작이 감지되는 경우를 막거나 예외를 발생시킨다.</li>
<li>혼란스럽거나 좋지 않은 기능은 비활성화한다.</li>
</ul>
<h2 id="strict-mode-사용-방법"><a class="header" href="#strict-mode-사용-방법">strict mode 사용 방법</a></h2>
<p>전역범위에서 사용하고 싶다면, 스크립트 상단에 아래와 같이 <code>'use strict'</code>를 입력하면 된다.</p>
<pre><code class="language-JavaScript">'use strict';

var foo = 'bar';
</code></pre>
<p>function scope만 적용하는 것도 가능하다.</p>
<pre><code class="language-JavaScript">function sum(a, b) {
  'use strict';

  return a + b;
}
(function() {
  // 즉시실행함수
  'use strict';

  var foo = 'bar';
})();
</code></pre>
<h2 id="특징-1"><a class="header" href="#특징-1">특징</a></h2>
<h3 id="전역-변수-할당-불가"><a class="header" href="#전역-변수-할당-불가">전역 변수 할당 불가</a></h3>
<p>기존에는 <code>var</code> 키워드 없이도 변수 선언이 가능하다. 단지 전역 변수로 선언될 뿐이었다.</p>
<pre><code class="language-JavaScript">foo = 'bar'; // 이 변수는 전역 변수로 선언되었습니다.
console.log(window.foo === foo); // true
</code></pre>
<p>strict mode에선 전역 변수 할당을 시도하는 경우, 에러가 발생한다.</p>
<pre><code class="language-javascript">'use strict';
foo = 'bar'; // Uncaught ReferenceError: foo is not defined
</code></pre>
<p>객체를 메모리 해제하는 것 역시 에러가 발생한다.</p>
<pre><code class="language-JavaScript">'use strict';
var a = 1;
delete a; // Delete of an unqualified identifier in strict mode.
function b() {return 1;};
delete b; // Delete of an unqualified identifier in strict mode.
</code></pre>
<h3 id="eval과-arguments"><a class="header" href="#eval과-arguments">eval과 arguments</a></h3>
<p><code>eval</code>과 <code>arguments</code>라는 이름을 사용하려는 시도는 에러를 발생시킨다.</p>
<pre><code class="language-JavaScript">// All generate errors... from John Resig - ECMAScript 5 Strict Mode, JSON, and More
obj.eval = ...  // 크롬에서 실행 가능
obj.foo = eval; // 크롬에서 실행 가능
var eval = ...;
for ( var eval in ... ) {}
function eval(){}
function test(eval){}
'use strict'; var aa = function(eval){}
new Function(&quot;eval&quot;) // 크롬에서 실행 가능

arguments = 1;
(function() {arguments = 1;})();
</code></pre>
<p><code>eval</code>을 이용한 변수 할당도 금지되었다.</p>
<pre><code class="language-javascript">'use strict';
eval('var foo = 1;');
console.log(foo); // undefined
</code></pre>
<h3 id="function"><a class="header" href="#function">Function</a></h3>
<p>동일한 명칭의 인자를 사용하는 것 역시 금지된다.</p>
<pre><code class="language-javascript">'use strict';
(function(a, a) { return a;})(1,2); // Duplicate parameter name not allowed in this context
</code></pre>
<p><a href="https://johnresig.com/blog/ecmascript-5-strict-mode-json-and-more/">John Resig - ECMAScript 5 Strict Mode, JSON, and More</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tagged-template-literals"><a class="header" href="#tagged-template-literals">Tagged Template Literals</a></h1>
<p>아래와 같이 태그를 사용하면 템플릿 리터럴을 문자열과 표현식으로 나눠서 파싱할 수 있다.</p>
<pre><code class="language-js">var x = 3;
var y = 5;

function getArea(literals, ...expressions) {
    for(let i = 0; i &lt; literals.length; i++)
        console.log('.'+literals[i]+'.');
    
    let area = expressions[0] * expressions[1];
    return area;
}

let area = getArea`나는 가로길이 ${x}, 세로길이 ${y} 인 직사각형 넓이를 알고싶다.`;
console.log(area);
</code></pre>
<p>출력결과</p>
<pre><code class="language-log">.나는 가로길이 .
., 세로길이 .
. 인 직사각형 넓이를 알고싶다..
15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-설치하기"><a class="header" href="#rust-설치하기">Rust 설치하기</a></h1>
<h2 id="rustup을-이용한-설치"><a class="header" href="#rustup을-이용한-설치">rustup을 이용한 설치</a></h2>
<p><strong>rustup</strong> 은 Rust 공식 릴리즈 채널의 다양한 버전의 컴파일러를 쉽게 관리하는 인스톨러이다. 루비의 rvm, 노드JS의 nvm과 유사한 역할을 한다. RustFmt와 같은 툴을 사용하기 위해서도 rustup이 필요하다.</p>
<h3 id="proxy-환경에서의-설치"><a class="header" href="#proxy-환경에서의-설치">Proxy 환경에서의 설치</a></h3>
<p>아래와 같이 환경변수 값을 설정하고 설치파일을 실행한다.</p>
<pre><code class="language-sh">RUSTUP_USE_REQWEST=1 # work-around: certificate verified error
https_proxy=프록시주소
</code></pre>
<h2 id="rust-직접-설치"><a class="header" href="#rust-직접-설치">Rust 직접 설치</a></h2>
<p>패키지 매니저를 통한 설치는 특정 버전 설치만 가능하다. 가능하면 rustup을 이용하자.</p>
<h3 id="windows-with-chocolatey"><a class="header" href="#windows-with-chocolatey">Windows with Chocolatey</a></h3>
<pre><code class="language-cmd">choco install rust
</code></pre>
<h3 id="mac-osx-with-homebrew"><a class="header" href="#mac-osx-with-homebrew">Mac OSX with Homebrew</a></h3>
<pre><code class="language-bash">brew install rust
</code></pre>
<h2 id="rust-compiler-viersion-확인"><a class="header" href="#rust-compiler-viersion-확인">Rust compiler viersion 확인</a></h2>
<pre><code class="language-bash">rustc --version
rustc 1.29.2 (17a9dc751 2018-10-05)
</code></pre>
<h2 id="cargo로-새로운-프로젝트-생성--빌드"><a class="header" href="#cargo로-새로운-프로젝트-생성--빌드">Cargo로 새로운 프로젝트 생성 &amp; 빌드</a></h2>
<p>Cargo는 Rust의 패키지 매니저이다.</p>
<pre><code class="language-bash">cargo new hello
     Created binary (application) `hello` project
cd hello
cargo run
   Compiling hello v0.1.0 (file:///D:/DEV_HOME/workspace/kata/rust/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 3.32s
     Running `target\debug\hello.exe`
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook-사용법"><a class="header" href="#mdbook-사용법"><code>mdbook</code> 사용법</a></h1>
<p><code>mdbook</code>은 Rust 언어 기반의 커맨드라인 툴 &amp; 라이브러리이다. 마크다운 파일을 이용해서 책을 만들 수 있다. Gitbook과 유사하지만, Rust 언어로 만들어졌다.</p>
<h2 id="설치"><a class="header" href="#설치">설치</a></h2>
<p>바이너리는 <a href="https://github.com/rust-lang-nursery/mdBook/releases">릴리즈 페이지</a>에서 다운로드 받을 수 있다. 그러나 난 이미 Rust를 PC에 설치한 상태이기 때문에 <strong>Cargo</strong>를 통해서 설치했다.</p>
<pre><code class="language-sh">&gt; cargo install mdbook
</code></pre>
<p>이외에 소스 레파지토리에서 <a href="https://rust-lang-nursery.github.io/mdBook/cli/index.html">직접 받아 빌드한 후 사용</a>하는 방법도 있다.</p>
<h2 id="프로젝트-구조"><a class="header" href="#프로젝트-구조">프로젝트 구조</a></h2>
<pre><code class="language-plain">mdbook-test/
├─ book
└─ src
    ├─ chapter_1.md
    └─ SUMMARY.md
</code></pre>
<ul>
<li><code>src</code> 디렉토리에 마크다운으로 작성된 파일들이 있어야 한다. 그리고 설정 파일 등이 들어갈 수 있다.</li>
<li><code>book</code> 디렉토리는 렌더링된 책이 있는 공간이다. 빌드된 결과물로 서버에 올리면 볼 수 있는 상태이다.</li>
<li><code>SUMMARY.md</code> 파일은 책의 목차를 작성하는 파일로 제일 중요하다. SUMMARY에 정의된 목차와 파일링크를 토대로 책이 렌더링된다.</li>
</ul>
<h2 id="cli-명령어"><a class="header" href="#cli-명령어">CLI 명령어</a></h2>
<h3 id="init-mdbook-생성"><a class="header" href="#init-mdbook-생성"><code>init</code>: mdbook 생성</a></h3>
<p>mdbook 보일러 플레이트를 생성하기 위해, <code>init</code> 명령어를 사용한다. .gitignore 파일을 생성여부와 책 제목을 묻는데, 책 제목은 소스 설정파일(<code>book.toml</code>)에 저장된다.</p>
<pre><code class="language-sh">&gt; mkdir mdbook-test # mdbook 루트 디렉토리 생성
&gt; cd mdbook-test/
&gt; mdbook init

Do you want a .gitignore to be created? (y/n)
y
What title would you like to give the book?
mdbook demo
2018-12-15 10:16:30 [INFO] (mdbook::book::init): Creating a new book with stub content

All done, no errors...
</code></pre>
<h3 id="build-소스를-기반으로-책을-렌더링"><a class="header" href="#build-소스를-기반으로-책을-렌더링"><code>build</code>: 소스를 기반으로 책을 렌더링</a></h3>
<pre><code class="language-sh">&gt; mdbook build
</code></pre>
<p><code>SUMMARY.md</code> 파일을 분석해서 책의 목차대로 렌더링한다. </p>
<p>기본 디렉토리는 <code>book/</code> 이지만 아래와 같이 사용자가 정의한 디렉토리에 빌드할 수 있다.</p>
<pre><code class="language-sh">&gt; mdbook build path/to/book
</code></pre>
<h3 id="serve-렌더링-된-책-웹에서-보기"><a class="header" href="#serve-렌더링-된-책-웹에서-보기"><code>serve</code>: 렌더링 된 책 웹에서 보기</a></h3>
<p><code>serve</code> 명령은 <code>localhost:3000</code>에서 HTTP를 통해 렌더링 된 책을 볼 수 있게한다.</p>
<pre><code class="language-sh">&gt; mdbook serve

2018-12-15 10:50:58 [INFO] (mdbook::book): Book building has started
2018-12-15 10:50:58 [INFO] (mdbook::book): Running the html backend
2018-12-15 10:50:58 [INFO] (mdbook::cmd::serve): Serving on: http://localhost:3000
2018-12-15 10:50:58 [INFO] (ws): Listening for new connections on [::1]:3001.
2018-12-15 10:50:58 [INFO] (mdbook::cmd::watch): Listening for changes...
</code></pre>
<h3 id="test-code-block-테스팅"><a class="header" href="#test-code-block-테스팅"><code>test</code>: code block 테스팅</a></h3>
<p>코드 블록의 테스트를 할 수 있다. 현재는 Rust 언어만 지원한다.</p>
<pre><code class="language-sh">mdbook test
</code></pre>
<p>아래와 같이 코드 블록 3건이 있는데 각각 성공 / 무시 / 무시하는 시나리오이다.</p>
<pre><code class="language-md">    ```rust
    fn main() {
        println!(&quot;hello world&quot;);
    }
    ```
</code></pre>
<pre><code class="language-md">    ```rust, ignore
    fn main() {
        println!(&quot;hello world&quot;);
    }
    ```
</code></pre>
<pre><code class="language-md">    ```rust
    // ignored
    fn main() {
    panic!(&quot;should panic!&quot;); // should panic
    }
    ```
</code></pre>
<p>결과는 아래와 같이 나온다.</p>
<pre><code class="language-sh">&gt; mdbook test

2018-12-15 11:01:47 [INFO] (mdbook::book): Testing file: &quot;D:\\...\\til\\src\\log/mdbook-guide.md&quot;
2018-12-15 11:01:49 [ERROR] (mdbook::utils): Error: Rustdoc returned an error:
running 3 tests
test C:\Users\...\mdbook-f7zZjj\log/mdbook-guide.md - mdbook::CLI_명령어::test (line 92) ... ignored
test C:\Users\...\mdbook-f7zZjj\log/mdbook-guide.md - mdbook::CLI_명령어::test (line 99) ... FAILED
test C:\Users\...\mdbook-f7zZjj\log/mdbook-guide.md - mdbook::CLI_명령어::test (line 85) ... ok

failures:

---- C:\Users\...\mdbook-f7zZjj\log/mdbook-guide.md - mdbook::CLI_명령어::test (line 99) stdout ----
thread 'C:\Users\...\mdbook-f7zZjj\log/mdbook-guide.md - mdbook::CLI_명령어::test (line 99)' panicked at 'test executable failed:

thread 'main' panicked at 'should panic!', C:\Users\...\mdbook-f7zZjj\log/mdbook-guide.md:3:3
note: Run with `RUST_BACKTRACE=1` for a backtrace.

', librustdoc\test.rs:367:17
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    C:\Users\...\mdbook-f7zZjj\log/mdbook-guide.md - mdbook::CLI_명령어::test (line 99)

test result: FAILED. 1 passed; 1 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p>테스트가 실패하는 경우 오류가 발생한 라인번호만 나오고 출력하진 않는다.</p>
<h2 id="수식-입력을-위한-mathjax-지원"><a class="header" href="#수식-입력을-위한-mathjax-지원">수식 입력을 위한 MathJax 지원</a></h2>
<p><a href="https://www.mathjax.org/">MathJax</a>를 선택적으로 적용할 수 있다. <code>book.toml</code> 파일에 아래와 같은은 설정을 추가하면 사용할 수 있다.</p>
<pre><code class="language-toml">[output.html]
mathjax-support = true
</code></pre>
<p>기존 MathJax에선 <code>&gt;&gt; ... &gt;&gt;</code>를 사용했다면, mdbook에선 <code>\\[ ... \\]</code> 방식으로 표현한다.</p>
<p>아래는 LaTex 커맨드로 작성한 수식이다.</p>
<pre><code class="language-plain">\\[ x = \frac {-b \pm \sqrt {b^2 - ac}} {a} \\]
</code></pre>
<p>\[ x = \frac {-b \pm \sqrt {b^2 - ac}} {a} \]
\[ \sqrt a \]</p>
<p>만약 인라인으로 작성하고 싶다면, <code>\\[ ... \\]</code> 대신 <code>\\( ... \\)</code> 로 쓰면 된다. \( T_1 = 2x \) 와 같이 렌더링된다.</p>
<h2 id="ci"><a class="header" href="#ci">CI</a></h2>
<p>Travis CI를 이용해서 지속적 통합을 제공한다. github와 연동하기 위해 먼저 public repository에 접근할 수 있는 access token을 발급받는다.</p>
<p>tooken을 발급받았으면 아래와 같이 <code>.travis.yml</code> 파일에 deploy 관련 설정을 추가한다. <code>local-dir</code>은 travis CI에서 실제로 소스를 pull 받은 경로를 넣어주면 된다.</p>
<pre><code class="language-yml">deploy:
  provider: pages
  skip-cleanup: true
  github-token: $GITHUB_TOKEN
  local-dir: /your/local/directory/book
  keep-history: false
  on:
    branch: master
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="코틀린-프로그래밍"><a class="header" href="#코틀린-프로그래밍">코틀린 프로그래밍</a></h1>
<h2 id="과정-소개"><a class="header" href="#과정-소개">과정 소개</a></h2>
<ul>
<li>과정 일정: 2019/01/14 ~ 2019/01/17</li>
<li>장소: 멀티캠퍼스</li>
<li>강사: 강성윤(kkang104@gmail.com)</li>
<li>강의자료: http://70.12.113.190:8080</li>
</ul>
<h2 id="왜-코틀린을-써야하는가"><a class="header" href="#왜-코틀린을-써야하는가">왜 코틀린을 써야하는가</a></h2>
<ul>
<li>Mobile App 개발
<ul>
<li>iOS: Objective C, Swift</li>
<li>Android: Java, Kotlin</li>
</ul>
</li>
<li>Java의 문제
<ul>
<li>(비교적) 구형 문법</li>
<li>유지보수 불편함</li>
</ul>
</li>
</ul>
<blockquote>
<p>2017 Google I/O에서 <strong>안드로이드 공식 언어</strong>로 발표<br />
<strong>Android first class language</strong></p>
</blockquote>
<h2 id="특징-2"><a class="header" href="#특징-2">특징</a></h2>
<ul>
<li>Java 100% 호환</li>
<li>JVM 기반 언어(Run everywhere)</li>
<li>Java/Kotlin 혼용 가능</li>
<li>개발 생산성: Java 10줄짜리 코드가 코틀린 2줄로...</li>
<li>함수형 프로그래밍, Null safety 등 언어 트렌드 지원</li>
<li>크로스 플랫폼 개발
<ul>
<li>Server-side 개발 가능(Spring 5부터 코틀린 지원)</li>
<li>Kotlin.js: 브라우져 개발</li>
<li>Kotlin/Native (v1.3부터): without JVM</li>
</ul>
</li>
<li>Google의 (전폭적인) 지원</li>
</ul>
<h2 id="개발환경"><a class="header" href="#개발환경">개발환경</a></h2>
<ul>
<li>intelliJ</li>
<li>Android studio</li>
<li>Java 1.8</li>
<li>Gradle</li>
<li>Eclipse (굳이...?)</li>
</ul>
<h2 id="참고-소스코드"><a class="header" href="#참고-소스코드">참고 소스코드</a></h2>
<ul>
<li><a href="https://github.com/sshplendid/KotlinCourseStudy">수업 예제코드</a></li>
<li><a href="https://github.com/sshplendid/AndroidWithKotlinExample">안드로이드 with Java, Kotlin 소스코드 비교</a></li>
<li><a href="https://github.com/sshplendid/JavaWithKotlinExample">스프링 부트 with Java, Kotlin 애플리케이션</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="코틀린-기본"><a class="header" href="#코틀린-기본">코틀린 기본</a></h1>
<h2 id="특징-3"><a class="header" href="#특징-3">특징</a></h2>
<ul>
<li><code>static</code> 예약어가 없다. Top-level에 선언하면 됨.</li>
<li>클래스 선언 없이 함수, 변수를 사용 가능</li>
<li>세미콜론(<code>;</code>)을 강제하지 않는다. (<code>enum</code> class 선언 제외)</li>
</ul>
<h2 id="코틀린-파일-정의"><a class="header" href="#코틀린-파일-정의">코틀린 파일 정의</a></h2>
<ul>
<li>확장자는 *.kt</li>
<li>파일과 클래스를 구분</li>
</ul>
<pre><code class="language-java">class Student {
    int id;
    void getId() {
        return this.id;
    }
}
</code></pre>
<pre><code class="language-kotlin">class Student {
    var id: int = 10
    fun getId() {
        ...
    }
}
</code></pre>
<p>클래스 없이 변수, 함수 단독으로 정의 가능하다.</p>
<blockquote>
<p>코틀린은 변수, 함수도 Top-level에 선언할 수 있다.<br />
함수 내 함수, 클래스도 선언 가능하다.<br />
Java의 경우, class만 Top-level에 선언할 수 있다.</p>
</blockquote>
<pre><code class="language-kotlin">package com.example.student

import java.util.*

var sum = 0

fun calSum() {
    for (i in 1..10) {
        sum += i
    }
}

class student {

    var id: int = 10

    fun getId() {
        id
    }
    
    fun hello() {
        println(&quot;hello&quot;)
    }
}

fun main(args: Array&lt;String&gt;) {
    calSum()
    println(sum)
    user
}
</code></pre>
<h2 id="패키지"><a class="header" href="#패키지">패키지</a></h2>
<ul>
<li>다른 패키지의 함수나 변수를 import하려면? 직접 import해서 사용하면 됨</li>
</ul>
<pre><code class="language-kotlin">package com.example.two

val threeVal = 10
fun threeFun() {

}
</code></pre>
<pre><code class="language-kotlin">package com.example.one

import com.example.two.threeVal
import com.example.two.threeFun

...
</code></pre>
<ul>
<li>가상패키지: 실제 위치와 다른 패키지명을 사용할 수 있다.</li>
</ul>
<p>파일구조</p>
<pre><code class="language-plain">src
└─one
  └─file.kt
</code></pre>
<pre><code class="language-kotlin">package my.package

...
</code></pre>
<ul>
<li>이름 변경해서 임포트할 수 있다.</li>
</ul>
<pre><code class="language-kotlin">import java.util.Date as MyDate
</code></pre>
<h3 id="기본-패키지"><a class="header" href="#기본-패키지">기본 패키지</a></h3>
<p>기본적으로 코틀린 파일에서 사용할 수 있는 패키지</p>
<pre><code class="language-plain">java.lang.*
kotlin.*
kotlin.io.*
kotlin.collections.*
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="변수와-함수"><a class="header" href="#변수와-함수">변수와 함수</a></h1>
<h1 id="변수"><a class="header" href="#변수">변수</a></h1>
<ul>
<li>
<p>변수 타입은 생략 가능하며, 초기값으로 <strong>타입 추론</strong>이 가능하다. </p>
</li>
<li>
<p>변수는 <code>var</code> <code>val</code>로 시작해야 한다.</p>
<ul>
<li><code>var</code>: mutable</li>
<li><code>val</code>: assign-once. immutable?</li>
</ul>
</li>
<li>
<p>Top-level, 클래스의 멤버 변수는 모두 초기화를 해야함.</p>
<ul>
<li>로컬 변수는 초기값을 지정하지 않아도 되지만, 기본으로 설정되진 않는다.</li>
<li>코틀린에선 모든 것이 <strong>객체</strong>이다.</li>
</ul>
</li>
<li>
<p>Null safety: 변수 선언시 명시적(<code>?</code>)으로 <em>nullable</em>/ <em>non-nullable</em> 구분해야 함.</p>
</li>
<li>
<p><code>const</code> vs <code>val</code></p>
<ul>
<li>값 변경은 불가</li>
<li><code>val</code>은 property
<ul>
<li>getter/setter를 내장하고 있음 (커스터마이징 가능함)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Java 스타일</p>
</li>
</ul>
<pre><code class="language-java">class student {
    int id;
    String name;
    void hello() {
        return &quot;Hello, &quot; + this.name;
    }
}
</code></pre>
<ul>
<li>Kotlin 스타일</li>
</ul>
<pre><code class="language-kotlin">a: Int = 10

class Student {
    val id: Int = 10
    val name: String = &quot;John&quot;

    void hello() {
        &quot;hello $name&quot;
    }
}
</code></pre>
<h1 id="함수"><a class="header" href="#함수">함수</a></h1>
<ul>
<li>매개변수는 기본으로 <code>val</code></li>
<li>의미있는 반환값이 없을때는 <code>Unit</code></li>
<li><code>Unit</code>은 생략할 수 있으며 리턴타입이 선언되지 않으면 기본적으로 적용</li>
<li>Java의 <code>void</code>는 예약어, Kotlin의 <code>Unit</code>은 타입<br />
<code>val emptyValue: Unit = Unit()</code>으로 사용 가능</li>
<li>Single expression function</li>
<li>default argument: 인자가 없는 경우</li>
<li>named argument: 연산자 오버로딩의 대안</li>
<li>중위표현식(infix): 연산자를 피연산자 중간에 위치시킨다
<ul>
<li>object 멤버함수만 가능</li>
<li>매개변수 하나만 존재해야 함</li>
</ul>
</li>
<li>가변인수</li>
<li>재귀함수: <code>tailrec</code> 예약어를 붙이면 효율적인 재귀함수를 만들 수 있다.
<ul>
<li><code>tailrec</code> 예약어는 바이트코드로 변환시 반복문으로 변환한다.</li>
<li>꼬리재귀함수의 경우에만 추가 가능</li>
</ul>
</li>
</ul>
<pre><code class="language-kotlin">// 기본 함수 형태
fun sum(a: Int, b: Int): Int {
    return a + b
}
</code></pre>
<pre><code class="language-kotlin">// Single expression function with return type
fun sum(a: Int, b: Int): Int = a + b
</code></pre>
<pre><code class="language-kotlin">Single expression function without return type
fun sum(a: Int, b: Int) = a + b
</code></pre>
<pre><code class="language-kotlin">// Default argument
fun hello(name: String = &quot;John&quot;) {
    println(&quot;Hello, &quot; + name)
}
</code></pre>
<pre><code class="language-kotlin">// Default &amp; Named argument
fun hello(name: String = &quot;John&quot;, id: Int) {
    println(&quot;Hello, &quot; + name)
}

...
fun main(args: Array&lt;String&gt;) {
    hello(&quot;Jane&quot;, 10);
    hello(no = 10, name = &quot;Jane&quot;);
    hello(no = 10);
}
</code></pre>
<pre><code class="language-kotlin">// 중위표현식

  // 함수 확장
infix fun Int.add(a: Int): Int {
    return 
}

</code></pre>
<pre><code class="language-kotlin">// 가변인수
fun &lt;T&gt; printAll(a1: Int, vararg array: T) { // Array&lt;Any&gt;
    for(a in array) {
        println(a)
    }
}

fun main(args: Array&lt;String&gt;) {
    printAll(10, &quot;Hello&quot;, &quot;world&quot;)
    printAll(10, 20, false)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기본-데이터-타입"><a class="header" href="#기본-데이터-타입">기본 데이터 타입</a></h1>
<h2 id="숫자-타입"><a class="header" href="#숫자-타입">숫자 타입</a></h2>
<ul>
<li><code>char</code> 타입을 숫자로 인식하지 않음</li>
<li>모든 숫자 타입 클래스는 <code>Number</code> 타입의 서브클래스이다</li>
<li>자동 형변형을 지원하지 않음</li>
<li>숫자 타입 데이터의 가독성을 위해서 underscore(<code>_</code>) 사용 가능.<br />
<code>val positive: Int = 1_000_000</code></li>
</ul>
<h2 id="문자열"><a class="header" href="#문자열">문자열</a></h2>
<ul>
<li>스트링 템플릿 리터럴 지원
<pre><code class="language-kotlin">val name = &quot;John&quot;
val greeting = &quot;hello ${name}&quot;
</code></pre>
</li>
<li>raw string 지원
<pre><code class="language-kotlin">val greeting = &quot;&quot;&quot;hello
world&quot;&quot;&quot;
</code></pre>
</li>
</ul>
<h2 id="any-타입"><a class="header" href="#any-타입"><code>Any</code> 타입</a></h2>
<p>코틀린의 최상위 클래스(Java <code>Object</code> 보다 상위 클래스)</p>
<pre><code class="language-kotlin">// Type check
fun getLength(obj: Any): Int {
    if(obj is String) {
        return obj.length // `length`는 String의 property, `is` 타입체크가 true일 경우, String 타입으로 스마트 캐스팅
    }
    return 0
}
</code></pre>
<pre><code class="language-kotlin">// switch 보다 기능이 많은 when
fun cases(obj: Any): String {
    when(obj) {
        1 -&gt; return &quot;One&quot;
        &quot;Hello&quot; -&gt; return &quot;Greeting&quot;
        is Long -&gt; return &quot;Long&quot;
    }
}
</code></pre>
<ul>
<li><code>Null</code> 허용 타입
<pre><code class="language-kotlin">val a: Int = null  // error
val b: Int? = null // OK

fun parseInt(str: String): Int {
    return str.toIntOrNull()
}
</code></pre>
</li>
<li><code>Any?</code> &lt;- <code>Any</code>
<ul>
<li><code>is</code>, <code>as</code>
<pre><code class="language-kotlin">val myVal1: Any = 10
val myVal2: Any? = myVal1

</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="unit--noting-제네릭의-타입-명시를-위해서"><a class="header" href="#unit--noting-제네릭의-타입-명시를-위해서"><code>Unit</code> &amp; <code>Noting</code>: 제네릭의 타입 명시를 위해서</a></h2>
<ul>
<li>Unit: 명시적인 리턴이 없다.</li>
<li>Nothing: 의미있는 리턴이 아니다, 코틀린의 최하위 클래스</li>
<li>Unit은 타입 클래스
<pre><code class="language-kotlin">// OK
fun myFun(): Unit {
    return Unit()
}
</code></pre>
</li>
<li>Nothing: 함수의 리턴타입?
<pre><code class="language-kotlin">// OK
fun myFun(): Nothing {
    throw Exception()
}
</code></pre>
</li>
</ul>
<h2 id="타입-확인과-캐스팅"><a class="header" href="#타입-확인과-캐스팅">타입 확인과 캐스팅</a></h2>
<ul>
<li>타입 체크를 위해 <code>is</code> 예약어 이용</li>
<li>타입 체크결과가 <code>true</code>이면 <strong>스마트 캐스팅</strong></li>
</ul>
<pre><code class="language-kotlin">var a1: Int = 10
var a2: Double = a1 // !error
var a3: Double = a1.toDouble() // OK
</code></pre>
<h2 id="배열-배열도-클래스array이다"><a class="header" href="#배열-배열도-클래스array이다">배열: 배열도 클래스(<code>Array</code>)이다.</a></h2>
<pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;) {
    var array = arrayOf(1, &quot;Shawn&quot;, true) // Array&lt;Any&gt;
    array[0] = 10
    array[2] = &quot;hello&quot;

    println(&quot;size: ${array.size}.. ${array[0]}, ${array.get(1)}, ${array.get(3)})
}
</code></pre>
<h2 id="컬렉션-1"><a class="header" href="#컬렉션-1">컬렉션</a></h2>
<ul>
<li>mutable 클래스와 immutable 클래스로 구분</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="조건문"><a class="header" href="#조건문">조건문</a></h1>
<h2 id="if-표현식"><a class="header" href="#if-표현식"><code>if</code> 표현식</a></h2>
<blockquote>
<h4 id="expression-vs-statement"><a class="header" href="#expression-vs-statement">expression vs statement</a></h4>
<p>statement: 문장이 실행됐을 때 결과값이 발생하지 않음<br />
expression: 결과값이 발생함</p>
</blockquote>
<ul>
<li>Java의 <code>if</code>는 statement, Kotlin의 <code>if</code>는 표현식
<ul>
<li>if 표현식의 결과를 할당 가능함
<pre><code class="language-kotlin">val number = 5
var isEven = if(number%2 == 0) {
    true
} else {
    false
}
</code></pre>
</li>
<li><code>if</code> 표현식을 변수에 할당하려면 <code>else</code>문을 꼭 정의해야 한다.
<pre><code class="language-kotlin">var isEven = if(number%2 == 0) true // [!] error
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="when-표현식"><a class="header" href="#when-표현식"><code>when</code> 표현식</a></h2>
<ul>
<li><code>in</code>: 범위 지정
<pre><code class="language-kotlin">val data = 15
when(data) {
    !in 1..100 -&gt; println(&quot;invalid data&quot;)
    in 1..10 -&gt; println(&quot;1 &lt;= data &lt;= 10&quot;)
    in 11..20 -&gt; println(&quot;11 &lt;= data &lt;= 20&quot;)
}
</code></pre>
</li>
<li>다양한 타입의 데이터에 대한 조건 지원
<pre><code class="language-kotlin">fun testWhen(data: Any) {
    when(data) {
        1 -&gt; println(&quot;data is 1&quot;)
        &quot;hello&quot; -&gt; println(&quot;data value is 'hello'&quot;)
        is Boolean -&gt; println(&quot;data value is Boolean&quot;)
    }
}
</code></pre>
</li>
<li><code>if</code>-<code>else</code> 대체용
<pre><code class="language-kotlin">val data = 10
when {
    data &lt;= 10 -&gt; println(&quot;data &lt;= 10&quot;)
    else -&gt; println(&quot;none&quot;)
}
</code></pre>
</li>
<li>표현식
<pre><code class="language-kotlin">val data = 3
val result = when(data) {
    1 -&gt; &quot;result is 1&quot;
    2 -&gt; &quot;result is 2&quot;
    else -&gt; &quot;out of range&quot;
}
</code></pre>
</li>
</ul>
<h2 id="for-반복문"><a class="header" href="#for-반복문"><code>for</code> 반복문</a></h2>
<ul>
<li><code>in</code> 연산자를 사용, 전통적인 <code>for(초기값;반복조건;증감) {}</code> 문법은 지원하지 않는다.
<pre><code class="language-kotlin"></code></pre>
</li>
<li>index 값을 획득하고자 한다면 <code>indices</code>를 이용
<pre><code class="language-kotlin">val list = arrayOf(1, 2, 3)
for(i in list.indices) {
    println(list[i])
}
</code></pre>
</li>
<li>index와 값을 함께 받고 싶으면 <code>withIndex()</code>를 이용
<pre><code class="language-kotlin">val list = listOf(1, 2, 3)
for((index, value) in list.withIndx()) {
    println(&quot;the element at $index is $value)
}
</code></pre>
</li>
<li>반복 조건
<ul>
<li><code>for(i in 1..100) { }</code>: 1 &lt;= x &lt;= 100</li>
<li><code>for(i in 1 until 100) { }</code>: 1&lt;= x <strong>&lt;</strong> 100</li>
<li><code>for(i in 1 step 100) { }</code>: ?</li>
<li><code>for(i in 1 down to 100) { }</code>: ?</li>
</ul>
</li>
</ul>
<h2 id="while-반복문-java와-차이가-없음"><a class="header" href="#while-반복문-java와-차이가-없음"><code>while</code> 반복문: Java와 차이가 없음</a></h2>
<h2 id="break-continue-그리고-label"><a class="header" href="#break-continue-그리고-label"><code>break</code>, <code>continue</code> 그리고 <code>label</code></a></h2>
<ul>
<li><code>label</code>의 사용방법
<pre><code class="language-kotlin">aaa@ for(i in 1..3) {
    for(j in 1..3) {
        if(j &gt; 1) break@aaa
        println(&quot;i: $i, j: $j&quot;)
    }
}
</code></pre>
</li>
</ul>
<h2 id="연산자"><a class="header" href="#연산자">연산자</a></h2>
<ul>
<li><strong>*</strong> 연산자: <strong>배열</strong>(not list)의 원소 나열, 가변인수의 함수를 호출할때 사용하면 편함
<pre><code class="language-kotlin">val asis = arrayOf(10, 20, 30)
val list = asList(1, 2, asis[0], asis[1], asis[3], 100, 200)
</code></pre>
<pre><code class="language-kotlin">val asis = arrayOf(10, 20, 30)
val list = asList(1, 2, *asis, 100, 200)
</code></pre>
</li>
<li><code>==</code> vs <code>===</code>
<ul>
<li><code>==</code>: 값</li>
<li><code>===</code>: 레퍼런스</li>
</ul>
</li>
<li>Integer 타입은 -128 ~ 127까지 캐싱</li>
<li><code>Null</code> 안전 관련 연산자
<ul>
<li><code>?</code>: </li>
<li><code>?:</code></li>
<li><code>?.</code></li>
<li><code>!!</code></li>
</ul>
</li>
<li>연산자 재정의 가능</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="클래스"><a class="header" href="#클래스">클래스</a></h1>
<ul>
<li><code>class</code> 예약어로 선언</li>
<li>클레스 몸체(<code>{}</code>)가 없다면 생략 가능</li>
<li><code>new</code> 연산자가 없다.</li>
<li>생성자
<ul>
<li><code>constructor</code> 키워드로 생성</li>
<li>주 생성자(primary constructor)
<ul>
<li>클래스 선언부분에 작성</li>
<li>하나의 클래스에 하나의 주 생성자만 정의 가능</li>
<li>보조 생성자(secondary constructor)가 있다면 주 생성자는 없어도 됨</li>
</ul>
</li>
<li>보조 생성자(secondary constructor)
<ul>
<li>클래스 body 영역에 선언</li>
</ul>
</li>
<li>class 내에 무조건 1개의 생성자가 존재</li>
<li>선언하지 않으면 컴파일러가 주 생성자(매개변수 없는) 선언</li>
<li>개발자에의해 주 생성자, 보조 생성자 선언 가능</li>
<li><strong>모두 선언되었다면, 보조 생성자에선 무조건 주 생성자 호출</strong></li>
<li>생성자 매개변수
<ul>
<li>클래스의 초기화(<code>init</code>) 블록, 클래스 프로퍼티에서는 접근이 되지만, 클래스에 정의된 함수에서는 사용불가</li>
</ul>
<pre><code class="language-kotlin">class User(name: String, age: Int) {
    init {
        // 객체가 생성되는 순간 생성자 초기화
        println(&quot;init... name: $name, age: $age&quot;) // OK
    }

    val upperName = name.toUpperCase() // OK

    fun sayhello() {
        println(&quot;hello $name&quot;) // [!] error
    }
}
</code></pre>
<ul>
<li>주 생성자 내에서 <code>var</code>, <code>val</code>을 이용해서 매개변수를 선언하면 <strong>클래스 멤버</strong>가 됨 (보조 생성자는 해당안됨)</li>
</ul>
<pre><code class="language-kotlin">class User(val name: String, val age: Int) { // name, age는 멤버변수가 됨
    val upperName = name.toUpperCase()
    init {
        println(&quot;init... name: $name, age: $age&quot;) // OK
    }

    fun sayHello() {
        println(&quot;hello $name&quot;) // OK
    }


</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="결론"><a class="header" href="#결론">결론</a></h2>
<ul>
<li>클래스 생성자 한개만 생성(권장사항) =&gt; <strong>주 생성자 이용</strong>
<ul>
<li>멤버 변수 선언하기 편하다</li>
<li>매개변수들 중 필수 매개변수만 주 생성자로 선언</li>
<li>보조 생성자에서는 주 생성자 연결</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로퍼티"><a class="header" href="#프로퍼티">프로퍼티</a></h1>
<h2 id="property-vs-field"><a class="header" href="#property-vs-field">property vs field</a></h2>
<ul>
<li>코틀린에서는 Top-level과 클래스의 변수를 <strong>프로퍼티(property)</strong> 라고 부름(함수 내부의 지역변수는 property가 아님)</li>
<li>Java에선 field, Kotlin에선 property</li>
<li>Property는 자체적으로 accessor(<code>getter</code>, <code>setter</code>)를 내장</li>
<li><code>var</code>로 선언하면 <code>get()</code> 추가</li>
<li><code>get</code>, <code>set</code> 내의 <code>field</code>(배킹 필드)는 프로퍼티에 저장된 값 자체를 지칭하는 예약어</li>
<li><code>val</code>의 경우, <code>get()</code>을 정의하였다면, <strong>초기값을 명시하지 않아</strong> 도 된다.</li>
<li>주 생성자의 <code>var</code>, <code>val</code>은 프로퍼티 커스터마이징이 불가능
<ul>
<li>클래스 바디에 새로운 프로퍼티를 생성해서 커스터마이징
<pre><code class="language-kotlin">class User(val name: String) {
    val myName = name
      get() = field
      set(Value) { field = value }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="기본-형태"><a class="header" href="#기본-형태">기본 형태</a></h2>
<pre><code class="language-kotlin">val name: String = &quot;Shawn&quot;
    get() = field
    set(value) = { field = value }
</code></pre>
<blockquote>
<p>캡슐화<br />
클래스의 멤버변수는 외부에서 접근을 못하게 해야한다.<br />
<code>private</code> 접근자로 변수 접근을 제한하고 다른 방법(method)을 통해서 핸들링하자.</p>
</blockquote>
<h2 id="프로퍼티-초기화-선언시-할당하지-않아도-되는-경우"><a class="header" href="#프로퍼티-초기화-선언시-할당하지-않아도-되는-경우">프로퍼티 초기화: 선언시 할당하지 않아도 되는 경우</a></h2>
<h3 id="init-블록에서-초기화"><a class="header" href="#init-블록에서-초기화"><code>init</code> 블록에서 초기화</a></h3>
<pre><code class="language-kotlin">class User {
    var name: String
    val id: Int

    init {
        name = &quot;Shawn&quot;
        id = 0
    }
}
</code></pre>
<h3 id="null-허용으로-선언"><a class="header" href="#null-허용으로-선언"><code>Null</code> 허용으로 선언</a></h3>
<pre><code class="language-kotlin">class User {
    var name: String? = null
    var age: Int? = null

    constructor()
}
</code></pre>
<h3 id="늦은-초기화late-init"><a class="header" href="#늦은-초기화late-init">늦은 초기화(late init)</a></h3>
<ul>
<li><code>var</code>에서만 사용 가능하다</li>
<li>주 생성자에서 사용할 수 없다</li>
<li>custom getter/setter를 사용하지 않은 프로퍼티에만 사용할 수 있다.</li>
<li><code>nullable</code> 프로퍼티에서 사용할 수 없다.</li>
<li>기초 타입에서 사용할 수 없다.</li>
<li><strong>Dependency Injection 사용성 증대</strong>
<ul>
<li>Nullable 없이 DI 사용 가능</li>
</ul>
</li>
</ul>
<pre><code class="language-kotlin">class User {
    lateinit var lateAge: Int
}

fun main(args: Array&lt;String&gt;) {
    val user = User()
    user.lateAge = 10
    println(user.lateAge)
}
</code></pre>
<h3 id="초기화-미루기lazy"><a class="header" href="#초기화-미루기lazy">초기화 미루기(lazy)</a></h3>
<ul>
<li>프로퍼티를 이용할 때로 초기화를 미룬다</li>
<li>lazy는 일종의 실행 영역</li>
<li><code>by lazy { }</code>로 선언</li>
<li>퍼포먼스 이슈가 있을 때 사용</li>
</ul>
<pre><code class="language-kotlin">val foo: String by lazy {
    println(&quot;lazy foo...&quot;)
    &quot;hello&quot;
}
</code></pre>
<h2 id="프로퍼티-값-변경-감지"><a class="header" href="#프로퍼티-값-변경-감지">프로퍼티 값 변경 감지</a></h2>
<pre><code class="language-kotlin">class User {
    var name: String by Delegates.observable(&quot;초기값&quot;, {props, old, new -&gt; println(&quot;$old .. $new&quot;)})
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="상속"><a class="header" href="#상속">상속</a></h1>
<h2 id="any-클래스"><a class="header" href="#any-클래스"><code>Any</code> 클래스</a></h2>
<ul>
<li>코틀린의 최상위클래스</li>
<li>모든 코틀린의 클래스는 Any의 서브클래스이다.</li>
</ul>
<h2 id="상속을-통한-클래스-정의"><a class="header" href="#상속을-통한-클래스-정의">상속을 통한 클래스 정의</a></h2>
<ul>
<li>코틀린의 모든 클래스는 기본적으로 <code>final</code></li>
<li><code>open</code> 예약어로 선언한 클래스만 상속 가능하다</li>
<li><code>extends</code> 예약어가 없음, 콜론(<code>:</code>)으로 상속관계를 표현</li>
</ul>
<pre><code class="language-kotlin">class Rect: Shape() {
    var width: Int = 0
        set(value) {
            if(value &lt; 0) field = 0
            else field = value
        }
    var height: Int = 0
        set(value) {
            if(value &lt; 0) field = 0
            else field = value
        }
}
</code></pre>
<h2 id="오버라이드"><a class="header" href="#오버라이드">오버라이드</a></h2>
<h3 id="함수-1"><a class="header" href="#함수-1">함수</a></h3>
<ul>
<li>함수를 선언하면 기본적으로 final</li>
<li>함수 오버라이드를 허용하려면 <code>open</code>으로 명시</li>
<li><code>override</code> 예약어로 상위 함수 재정의한 것을 명시
<ul>
<li><code>override</code>된 함수는 자동으로 <code>open</code> 상태이다</li>
</ul>
</li>
</ul>
<h3 id="프로퍼티-1"><a class="header" href="#프로퍼티-1">프로퍼티</a></h3>
<ul>
<li>프로퍼티는 기본적으로 <code>final</code></li>
<li>상위 클래스의 프로퍼티와 이름, 타입이 동일함</li>
<li>규칙
<ul>
<li>상위 <code>val</code>로 선언된 프로퍼티 -&gt; 하위에서 <code>val</code>, <code>var</code> 재정의 가능</li>
<li>상위 <code>var</code> 선언 프로퍼티는 -&gt; 하위에서 <code>var</code> 재정의 가능, <code>val</code> 불가</li>
<li>상위 Nullable 선언 -&gt; 하위 Non-nullable로 재정의 가능</li>
<li>상위 Non-nullable 선언 -&gt; 하위 Nullable 재정의 불가</li>
</ul>
</li>
</ul>
<h3 id="생성자-1"><a class="header" href="#생성자-1">생성자</a></h3>
<ul>
<li>주 생성자가 선언되어 있다면 보조 생성자에선 주 생성자와 연결하기 위한 <code>this()</code> 구문이 추가되어야 함</li>
<li>객체 생성시, 어떤 식으로든 상위 클래스의 생성자가 호출되어야 함</li>
<li>생성자 수행흐름
<ol>
<li><code>this()</code> or <code>super()</code></li>
<li><code>init</code> 블록 실행</li>
<li>생성자 블록 실행</li>
</ol>
</li>
</ul>
<h2 id="캐스팅"><a class="header" href="#캐스팅">캐스팅</a></h2>
<ul>
<li>기초 데이터 타입은 자동 형변환 안되고 함수에 의해서 변환 가능</li>
</ul>
<h3 id="스마트-캐스팅"><a class="header" href="#스마트-캐스팅">스마트 캐스팅</a></h3>
<ul>
<li><code>is</code> 예약어 이용 시: is 연산 결과가 true이면 타입 변환</li>
<li>하위 -&gt; 상위 타입으로: 암시적 캐스팅</li>
<li><code>as</code>를 이용한 캐스팅: 상위 -&gt; 하위로 변환할 때</li>
</ul>
<h2 id="접근제한자"><a class="header" href="#접근제한자">접근제한자</a></h2>
<ul>
<li><code>public</code>, <code>internal</code>, <code>protected</code>, <code>private</code></li>
<li><code>public</code>: 접근제한자 명시가 없으면 기본으로 적용</li>
<li><code>protected</code>: top-level에서 사용 불가</li>
<li><code>private</code>: 동일 <strong>file</strong> 내에서만 사용 가능</li>
<li><code>internal</code>: 동일 모듈 내에서 사용 가능</li>
</ul>
<h3 id="프로퍼티-접근제한자"><a class="header" href="#프로퍼티-접근제한자">프로퍼티 접근제한자</a></h3>
<ul>
<li><code>get()</code>: 프로퍼티 접근 제한자와 항상 동일하게 적용</li>
<li><code>set()</code>: 프로퍼티 접근제한자보다 범위를 넓혀서 설정할 수 없다.</li>
</ul>
<h3 id="상속과-접근제한"><a class="header" href="#상속과-접근제한">상속과 접근제한</a></h3>
<ul>
<li><code>open</code>과 <code>private</code>은 같이 사용할 수 없음</li>
<li>하위 클래스에서 상위 멤버를 <code>override</code> 할 때 접근범위를 줄일 수 없음</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="추상클래스"><a class="header" href="#추상클래스">추상클래스</a></h1>
<h2 id="선언"><a class="header" href="#선언">선언</a></h2>
<pre><code class="language-kotlin">abstract class Super {
    val no: Int = 10
    abstract val message: String

    fun foo() {
        println(&quot;abstract foo... $no&quot;)
    }

    abstract fun bar()
}

class Sub: Super() {
    override val message: String = &quot;hello&quot;
    override fun bar() {
        println(&quot;sub bar... ${message}&quot;)
    }
}
</code></pre>
<h1 id="인터페이스"><a class="header" href="#인터페이스">인터페이스</a></h1>
<ul>
<li>객체 생성 불가</li>
<li>추상 함수 선언이 주 목적 (has-a)</li>
<li>함수 기능 구현 가능(is-a...?)</li>
</ul>
<pre><code class="language-kotlin">interface Walkable {
    var numberOfLegs: Int

    fun walk();
    fun getShoes(): String { // 함수 구현 가능
        return &quot;Nike&quot;
    }
}

interface Eatable {
   fun eat(food: String)
}

class Animal {
    
}
class Human: Walkable, Animal(), Eatable { // 인터페이스는 생성자를 호출하지 않는다.
    override fun walk() {
        println(&quot;human is walking...&quot;)
    }
    override fun eat(food: String) {
        println(&quot;human is eating ${food}...&quot;)
}
</code></pre>
<h2 id="프로퍼티-2"><a class="header" href="#프로퍼티-2">프로퍼티</a></h2>
<ul>
<li>인터페이스에 프로퍼티 추가 가능</li>
<li>추상형으로 선언되어 있거나, getter/setter를 정의해야 한다.</li>
<li>추상 프로퍼티가 아니라면 
<ul>
<li><code>val</code>은 getter를 선언해야 한다.</li>
<li><code>var</code>는 getter/setter를 선언해야 한다</li>
</ul>
</li>
<li>인터페이스의 프로퍼티 getter/setter는 <code>field</code>를 사용할 수 없다.
<ul>
<li>컴파일할 때, 인터페이스의 프로퍼티는 실제 필드로 정의하지 않는다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-다양한-클래스"><a class="header" href="#11-다양한-클래스">11. 다양한 클래스</a></h1>
<h2 id="data-클래스"><a class="header" href="#data-클래스"><code>data</code> 클래스</a></h2>
<ul>
<li>Value Object, Data Trasfer Object, ...</li>
<li><code>data</code> 키워드로 선언</li>
<li>주 생성자가 선언되야 하며, 매개변수 하나 이상 선언해야 함
<ul>
<li>주 생성자의 모든 매개변수는 <code>var</code>  혹은 <code>val</code>로 선언해야 함</li>
</ul>
</li>
<li><code>abstract</code>, <code>open</code>, <code>sealed</code>, <code>inner</code> 등 키워드를 사용할 수 없음</li>
</ul>
<pre><code class="language-kotlin">data class User()       // error, 주 생성자에 매개변수가 없음
data class User2(name: String) // error, val이나 var로 매개변수 선언해야 함
data abstract class User3(val name: String) // error, abstract와 같은 키워드를 사용할 수 없음
data class User4(val name: String, no: Int) // error, 모든 매개변수는 var 혹은 val로 선언해야 함

data class User(Val name: String, val age: Int) // OK
</code></pre>
<h3 id="equals"><a class="header" href="#equals"><code>equals()</code></a></h3>
<ul>
<li>객체 비교가 아닌, 객체의 데이터 비교를 도와주는 함수이다.</li>
<li>동일한 클래스, 주 생성자에 선언된 프로퍼티만 비교</li>
</ul>
<pre><code class="language-kotlin">data class User(val name: String, val age: Int) {
    var email: String = &quot;your@email.com&quot;
}

fun main(args: Array&lt;String&gt;) {
    val shawn: User = User(&quot;Shawn&quot;, 30)
    val jane: User = User(&quot;Shawn&quot;, 30)
    jane.email = &quot;jane@gmail.com&quot;

    println(&quot;${shawn.equals(jane)}) // true
}
</code></pre>
<h3 id="tostring"><a class="header" href="#tostring"><code>toString()</code></a></h3>
<ul>
<li>데이터 클래스의 데이터를 문자열로 반환
<ul>
<li>일반 클래스는 인스턴스의 주소값을 반환</li>
<li>주 생성자의 프로퍼티만 반환</li>
</ul>
</li>
</ul>
<h3 id="componentn"><a class="header" href="#componentn"><code>componentN()</code></a></h3>
<ul>
<li>데이터 클래스 프로퍼티 값을 획득</li>
<li>비구조화 할당(destructing assignment)</li>
</ul>
<pre><code class="language-kotlin">data class User(val name: String, val age: Int)

fun main(args: Array&lt;String&gt;) {
    var user = User(&quot;Shawn&quot;, 30)

    println(&quot;name: ${user.component1()}&quot;) // Shawn
    println(&quot;age: ${user.component2()}&quot;) // 30

    val (name, age) = user // 비구조화 할당
}
</code></pre>
<h3 id="copy"><a class="header" href="#copy"><code>copy()</code></a></h3>
<ul>
<li>객체를 복사</li>
</ul>
<h2 id="enum-클래스"><a class="header" href="#enum-클래스"><code>enum</code> 클래스</a></h2>
<ul>
<li>열거형 타입</li>
<li><code>enum</code> 예약어로 생성</li>
<li><code>name</code>, <code>ordinal</code> 내장 프로퍼티가 존재</li>
</ul>
<h3 id="기본형태"><a class="header" href="#기본형태">기본형태</a></h3>
<pre><code class="language-kotlin">enum class Direction {
    NORTH, SOUTH WEST, EAST
}

fun main(args: Array&lt;String&gt;) {
    val direction: Direction = Direction.NORTH
    println(&quot;${direction.name} ... ${direction.ordinal}&quot;)
}
</code></pre>
<h3 id="개발자-임의-데이터-타입"><a class="header" href="#개발자-임의-데이터-타입">개발자 임의 데이터 타입</a></h3>
<pre><code class="language-kotlin">enum class Direction(val no: Int) {
    NORTH(0), SOUTH(1), WEST(2), EAST(3)
}
</code></pre>
<h3 id="익명-클래스-이용"><a class="header" href="#익명-클래스-이용">익명 클래스 이용</a></h3>
<ul>
<li>각 원소는 enum 클래스의 서브타입</li>
<li>열거상수는 객체</li>
<li>이름 없는 클래스를 직접 정의</li>
<li>enum 상수 영역과 클래스 바디영역을 구분하기 위해 세미콜론(<code>;</code>)을 사용해야 함</li>
</ul>
<pre><code class="language-kotlin">enum class Direction(val no: Int) {
    NORTH {
        override val bar: Int = 10
        override fun foo() { println(&quot;North foo...&quot;) }
    },
    SOUTH {
        override val bar: Int = 20
        override fun foo() { println(&quot;South foo...&quot;) }
    }; // &lt;-- 세미콜론으로 구분
    absract val bar: Int
    abstract fun foo()
}
</code></pre>
<h2 id="sealed-클래스"><a class="header" href="#sealed-클래스"><code>sealed</code> 클래스</a></h2>
<ul>
<li><code>sealed</code> 예약어로 선언</li>
<li>enum 클래스와 유사함</li>
<li>vs class: sealed class는 인스턴스 생성이 불가능</li>
<li>vs abstract class
<ul>
<li>abstract: 어디에서나 선언 가능</li>
<li>sealed: sealed class가 선언된 그 file 내에서만 선언 가능</li>
</ul>
</li>
<li>내가 선언한 클래스만 사용해라!</li>
</ul>
<h3 id="enum-vs-sealed"><a class="header" href="#enum-vs-sealed"><code>enum</code> vs <code>sealed</code></a></h3>
<ul>
<li>enum: data, function 추가 가능
<ul>
<li>enum class에서 정의한 data, function만...</li>
<li>모든 enum 상수가 동일 변수, 함수를 가지고 있음</li>
</ul>
</li>
<li>sealed: 상수(하위 class) 별 다양한 변수, 함수 가능</li>
</ul>
<h3 id="기본-형태-1"><a class="header" href="#기본-형태-1">기본 형태</a></h3>
<pre><code class="language-kotlin">sealed class Shape {
    class Circle(val radius: Double): Shape()
    class Rect(val width: Int, val height: Int): Shape()
}

class Triangle(val bottom: Int, val height: Int): Shape()
</code></pre>
<h2 id="nested-클래스"><a class="header" href="#nested-클래스">Nested 클래스</a></h2>
<ul>
<li>특정 클래스 내에 선언된 클래스를 지칭 -&gt; 예약어가 없다</li>
<li>Outer 클래스의 멤버에 접근할 수 없다.
<ul>
<li>Nested 클래스에서 Outer 클래스의 멤버에 접근하려면 <code>inner</code> 클래스를 선언해야 한다.
<ul>
<li>inner 클래스는 외부에서 객체 생성이 불가</li>
<li>외부에서 이용하려면 outer 클래스에서 인스턴스를 생성해줘야 함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="inner-클래스"><a class="header" href="#inner-클래스"><code>inner</code> 클래스</a></h2>
<h2 id="object-클래스"><a class="header" href="#object-클래스"><code>object</code> 클래스</a></h2>
<ul>
<li>기본적으로 anonymous 클래스</li>
<li><code>object Foo { }</code>로 선언시, <code>Foo</code>라는 이름을 가진 객체가 생성</li>
</ul>
<h3 id="companion"><a class="header" href="#companion"><code>companion</code></a></h3>
<ul>
<li>Java class의 static 멤버와 동일</li>
</ul>
<h2 id="클래스-별-특징"><a class="header" href="#클래스-별-특징">클래스 별 특징</a></h2>
<table><thead><tr><th>특징</th><th align="center">nested</th><th align="center"><code>inner</code></th><th align="center"><code>object</code></th><th align="center"><code>companion object</code></th></tr></thead><tbody>
<tr><td>예약어</td><td align="center">x</td><td align="center">o</td><td align="center">o</td><td align="center">o</td></tr>
<tr><td>outer 멤버 접근</td><td align="center">x</td><td align="center">o</td><td align="center">o</td><td align="center">-</td></tr>
<tr><td>outer에서 접근</td><td align="center">o</td><td align="center">o</td><td align="center">△<br/><code>private</code></td><td align="center">-</td></tr>
<tr><td>외부 접근</td><td align="center">o</td><td align="center">x</td><td align="center">△<br />상속(Type 명시)</td><td align="center">-</td></tr>
<tr><td>타입</td><td align="center">class</td><td align="center">class</td><td align="center"><code>Any</code></td><td align="center">-</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-함수형-프로그래밍과-람다"><a class="header" href="#12-함수형-프로그래밍과-람다">12 함수형 프로그래밍과 람다</a></h1>
<h2 id="함수형-프로그래밍의-정의"><a class="header" href="#함수형-프로그래밍의-정의">함수형 프로그래밍의 정의</a></h2>
<blockquote>
<p>변수(할당) 없는 프로그래밍</p>
</blockquote>
<blockquote>
<p>순수 함수로 정의되는 함수</p>
</blockquote>
<ul>
<li>순수함수는 Side-effect가 발생하지 않는다</li>
<li>함수 외부의 다른 값을 변경하지 않음</li>
<li>내부에서 별도의 I/O가 발생하지 않음</li>
<li>동일 입력 동일 출력</li>
</ul>
<h3 id="프로그래밍-패러다임"><a class="header" href="#프로그래밍-패러다임">프로그래밍 패러다임</a></h3>
<ul>
<li>
<p>절차지향</p>
<ul>
<li>알고리즘과 로직 중심으로 문제 해결</li>
</ul>
</li>
<li>
<p>객체지향 프로그래밍</p>
<ul>
<li>기능과 데이터를 묶어 객체를 만들고 조합하는 프로그래밍</li>
</ul>
</li>
<li>
<p>함수형 프로그래밍</p>
<ul>
<li>함수의 선언과 선언된 함수의 유기적인 흐름</li>
</ul>
</li>
<li>
<p>왜 함수형 프록래밍이 대두되는가</p>
<ul>
<li>복잡성 증가</li>
<li>디버깅</li>
<li>동시성 프로그래밍</li>
</ul>
</li>
</ul>
<h2 id="함수형에서의-데이터"><a class="header" href="#함수형에서의-데이터">함수형에서의 데이터</a></h2>
<ul>
<li>데이터는 변경되지 않으며 프로그램의 상태만 표현(immutable state data)</li>
<li>데이터는 변경하는 것이 아니라 새로운 데이터를 만들어 리턴</li>
</ul>
<h2 id="장점-1"><a class="header" href="#장점-1">장점</a></h2>
<ul>
<li>간결한 코드 -&gt; 유지보수성 증대</li>
<li>안전한 동시성 프로그래밍 -&gt; <strong>부수효과</strong>가 없음</li>
</ul>
<h2 id="원칙"><a class="header" href="#원칙">원칙</a></h2>
<blockquote>
<p>일급객체(First class citizen)</p>
</blockquote>
<ul>
<li>프로그램 top-level에 함수를 정의</li>
<li>모든 구성요소를 함수 안에 작성</li>
<li>함수를 변수처럼 이용</li>
</ul>
<h2 id="코틀린에서"><a class="header" href="#코틀린에서">코틀린에서</a></h2>
<h3 id="다양한-구성요소를-포함"><a class="header" href="#다양한-구성요소를-포함">다양한 구성요소를 포함</a></h3>
<p>함수 내에 변수, class, 함수 등 모든 요소를 포함 가능</p>
<h3 id="변수처럼-이용하는-함수"><a class="header" href="#변수처럼-이용하는-함수">변수처럼 이용하는 함수</a></h3>
<pre><code class="language-kotlin">// 람다 표현식
val foo = { bar: Int -&gt;
    println(&quot;hello world&quot;)
    bar + 10
}
foo(5)
</code></pre>
<pre><code class="language-kotlin">// reflection
val foo = { bar: Int -&gt;
    println(&quot;hello world&quot;)
    bar + 10
}

val bar = ::foo
</code></pre>
<h1 id="람다-표현식"><a class="header" href="#람다-표현식">람다 표현식</a></h1>
<ul>
<li>익명함수(anonymous function)</li>
<li>마지막 표현식을 리턴</li>
</ul>
<pre><code class="language-kotlin">fun sum(a: Int, b: Int): Int {
    return a + b
}
</code></pre>
<pre><code class="language-kotlin">val sum = {a: Int, b: Int -&gt; a + b }
</code></pre>
<h2 id="즉시실행함수"><a class="header" href="#즉시실행함수">즉시실행함수</a></h2>
<pre><code class="language-kotlin">{ println(&quot;hello&quot;) }()
run { println(&quot;hello&quot;) }
</code></pre>
<h2 id="매개변수가-없는-람다함수"><a class="header" href="#매개변수가-없는-람다함수">매개변수가 없는 람다함수</a></h2>
<pre><code class="language-kotlin">val foo = { -&gt; 10 + 20 }
val bar = { 10 + 20 }
</code></pre>
<h2 id="함수-타입"><a class="header" href="#함수-타입">함수 타입</a></h2>
<ul>
<li>타입을 명시하면 파라미터 타입을 명시하지 않아도 됨</li>
</ul>
<pre><code class="language-kotlin">fun sum(a: Int, b: Int): Int {
    return a + b
}

val foo: (Int, Int) -&gt; Int = { a: Int, b: Int -&gt; a + b }
val bar: (Int, Int) -&gt; Int = { a, b -&gt; a + b }
</code></pre>
<h3 id="typealias를-이용한-타입-정의"><a class="header" href="#typealias를-이용한-타입-정의"><code>typealias</code>를 이용한 타입 정의</a></h3>
<pre><code class="language-kotlin">typealias MyType = (Int) -&gt; Boolean

val foo: MyType = { it &gt; 10 }
</code></pre>
<h2 id="it을-이용한-매개변수-이용"><a class="header" href="#it을-이용한-매개변수-이용"><code>it</code>을 이용한 매개변수 이용</a></h2>
<ul>
<li>매개변수가 하나인 경우, it으로 매개변수 지칭</li>
</ul>
<pre><code class="language-kotlin">val foo: (Int) -&gt; Int = { x -&gt; x + 2 }
val bar: (Int) -&gt; Int = { it + 2 }

val bax = { it + 2 } // error, it의 타입이 명시되지 않아서
</code></pre>
<h2 id="멤버-참조"><a class="header" href="#멤버-참조">멤버 참조</a></h2>
<ul>
<li>Member reference는 (<code>::</code>)로 표현</li>
</ul>
<pre><code class="language-kotlin">class User(val name: String, val age: Int)

val bar: (User) -&gt; String = { u: User -&gt; u.name }
val foo: (User) -&gt; String = User::name
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="고차함수-high-order-function"><a class="header" href="#고차함수-high-order-function">고차함수 (high-order function)</a></h1>
<p>함수의 매개변수로 함수를 전달받거나, 리턴할 수 있는 함수</p>
<pre><code class="language-kotlin">fun foo
</code></pre>
<h2 id="함수타입-매개변수"><a class="header" href="#함수타입-매개변수">함수타입 매개변수</a></h2>
<h2 id="함수-반환"><a class="header" href="#함수-반환">함수 반환</a></h2>
<h2 id="익명함수"><a class="header" href="#익명함수">익명함수</a></h2>
<h2 id="코틀린-api의-고차함수"><a class="header" href="#코틀린-api의-고차함수">코틀린 API의 고차함수</a></h2>
<h3 id="run"><a class="header" href="#run"><code>run()</code></a></h3>
<ul>
<li>람다함수를 실행하고 그 결과값을 획득</li>
<li>객체의 멤버에 접근
<ul>
<li>반복적으로 인스턴스명을 입력하지 않아도 된다?
<pre><code class="language-kotlin">val user = User()
val runResult = user.run {
    name = &quot;Kim&quot;
    age = 10
    true
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="apply"><a class="header" href="#apply"><code>apply()</code></a></h3>
<ul>
<li>대입한 객체를 다시 리턴받음</li>
</ul>
<h3 id="let"><a class="header" href="#let"><code>let()</code></a></h3>
<ul>
<li><code>let</code>을 이용하는 객체를 매개변수로 전달</li>
</ul>
<h3 id="with"><a class="header" href="#with"><code>with()</code></a></h3>
<ul>
<li>객체를 매개변수로 전달받아 멤버들에 접근</li>
</ul>
<h2 id="인라인-함수"><a class="header" href="#인라인-함수">인라인 함수</a></h2>
<ul>
<li>고차함수의 런타임 시, 성능이슈 문제 (JVM)</li>
<li><code>inline</code> 예약어를 함수 선언 앞에 추가하면 컴파일 단계에서 정적으로 포함</li>
</ul>
<p>고차함수를 컴파일 할 때 </p>
<pre><code class="language-kotlin">fun foo(calc: (a: Int, b: Int) -&gt; Int) {
    calc(10, 20)
}

fun main(args: Array&lt;String&gt;) {
    foo { x, y -&gt; x + y }
}
</code></pre>
<pre><code class="language-java">// Java decompile
// 성능이슈 발생
public final class Ch12Kt {
   public static final void foo(@NotNull Function2 calc) {
      Intrinsics.checkParameterIsNotNull(calc, &quot;calc&quot;);
      calc.invoke(10, 20);
   }

   public static final void main(@NotNull String[] args) {
      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);
      foo((Function2)null.INSTANCE);
   }
}
</code></pre>
<h3 id="noinline"><a class="header" href="#noinline"><code>noinline</code></a></h3>
<p><code>noinline</code> 예약어로 inline에 포함하지 않아도 되는 매개변수를 명시적으로 선언</p>
<h3 id="논-로컬-반환"><a class="header" href="#논-로컬-반환">논 로컬 반환</a></h3>
<ul>
<li></li>
</ul>
<h3 id="crossinline"><a class="header" href="#crossinline"><code>crossinline</code></a></h3>
<h3 id="label을-통한-람다함수-반환"><a class="header" href="#label을-통한-람다함수-반환"><code>label</code>을 통한 람다함수 반환</a></h3>
<ul>
<li>임의의 label로 람다함수 반환이 가능</li>
<li>하지만 고차함수 이름으로도 반환 가능
<ul>
<li>모든 고차함수는 고차함수 이름으로 label이 지정되어 있음</li>
</ul>
</li>
</ul>
<h2 id="클로저"><a class="header" href="#클로저">클로저</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-컬렉션"><a class="header" href="#14-컬렉션">14 컬렉션</a></h1>
<h2 id="foreach-foreachindexed"><a class="header" href="#foreach-foreachindexed"><code>forEach()</code>, <code>forEachIndexed()</code></a></h2>
<h2 id="all-any"><a class="header" href="#all-any"><code>all()</code>, <code>any()</code></a></h2>
<h2 id="count-find"><a class="header" href="#count-find"><code>count()</code>, <code>find()</code></a></h2>
<h2 id="reduce-reduceright-fold-foldright"><a class="header" href="#reduce-reduceright-fold-foldright"><code>reduce()</code>, <code>reduceRight()</code>, <code>fold()</code>, <code>foldRight()</code></a></h2>
<h2 id="max-maxby-min-minby"><a class="header" href="#max-maxby-min-minby"><code>max()</code> <code>maxby()</code> <code>min()</code> <code>minby()</code></a></h2>
<h2 id="none-sumby"><a class="header" href="#none-sumby"><code>none()</code> <code>sumBy()</code></a></h2>
<h2 id="filter-filternot-filternotnull"><a class="header" href="#filter-filternot-filternotnull"><code>filter()</code>, <code>filterNot()</code>, <code>filterNotNull()</code></a></h2>
<h2 id="drop"><a class="header" href="#drop"><code>drop()</code></a></h2>
<h2 id="take"><a class="header" href="#take"><code>take()</code></a></h2>
<h2 id="map"><a class="header" href="#map"><code>map()</code></a></h2>
<h2 id="groupby"><a class="header" href="#groupby"><code>groupBy()</code></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-안정성"><a class="header" href="#null-안정성">Null 안정성</a></h1>
<blockquote>
<p>The billion dollor mistake</p>
</blockquote>
<p>값이 아무것도 대입되지 않은 상태</p>
<h2 id="null-허용과-불허"><a class="header" href="#null-허용과-불허">null 허용과 불허</a></h2>
<h2 id="null-확인-연산자-"><a class="header" href="#null-확인-연산자-">Null 확인 연산자 <code>?.</code></a></h2>
<pre><code class="language-kotlin">val foo: String? = &quot;hello&quot;
var length: Int? = if(foo != null) {
    foo.length
} else {
    null
}
</code></pre>
<pre><code class="language-kotlin">val foo: String? = &quot;hello&quot;
var length: Int? = foo?.length
println(length)

val bar: String? = null
var length: Int? = bar?.length
println(length)
</code></pre>
<h2 id="엘비스-연산자-"><a class="header" href="#엘비스-연산자-">엘비스 연산자 <code>?:</code></a></h2>
<p>Null인 경우에 처리를 명시</p>
<pre><code class="language-kotlin">val foo = &quot;hello&quot;

var length: Int = if(foo != null) {
    foo.length
} else {
    -1
}
</code></pre>
<h2 id="예외-발생-연산자-"><a class="header" href="#예외-발생-연산자-">예외 발생 연산자 <code>!!</code></a></h2>
<ul>
<li>Null인 경우 Exception을 발생시키기 위한 연산자</li>
<li>Java와 함께 사용할때</li>
</ul>
<h2 id="안전한-캐스팅-as"><a class="header" href="#안전한-캐스팅-as">안전한 캐스팅 <code>as?</code></a></h2>
<ul>
<li><code>as</code> 연산자 이용시 <code>ClassCastException</code> 발생</li>
<li><code>as?</code> 연산자는 null 리턴</li>
</ul>
<h1 id="예외처리"><a class="header" href="#예외처리">예외처리</a></h1>
<ul>
<li><code>try</code> - <code>catch</code> - <code>final</code> 구문으로 예외 처리</li>
<li><code>try</code> - <code>catch</code> 구문의 마지막 표현식은 반환 값으로 사용</li>
<li><code>throw</code>는 표현식</li>
<li>Java의 <code>throws</code> 예약어가 코틀린에선 없음
<ul>
<li>이게 꼭 필요한가?</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="클래스-확장"><a class="header" href="#클래스-확장">클래스 확장</a></h1>
<ul>
<li>일반적인 클래스 확장은 <strong>상속</strong>을 이용</li>
<li>클래스 내부에 선언된 함수와 프로퍼티 이외에 다른 프로퍼티나 함수를 추가</li>
<li>확장 함수는 기존 클래스 내에 정적으로 추가되지는 않음</li>
<li>OOP 다형성 불가</li>
<li>super 클래스의 함수 호출 불가ㅐ</li>
</ul>
<h1 id="프로퍼티-확장"><a class="header" href="#프로퍼티-확장">프로퍼티 확장</a></h1>
<ul>
<li>프로퍼티 확장 가능</li>
<li>getter에 의해 초기화해야 함</li>
</ul>
<h1 id="확장-구문의-위치에-따른-이용"><a class="header" href="#확장-구문의-위치에-따른-이용">확장 구문의 위치에 따른 이용</a></h1>
<ul>
<li>Top-level에 작성</li>
<li>확장 대상 클래스와 확장 프로퍼티or 함수를 따로 import해야 함</li>
<li>다른 클래스 내에서 작성
<ul>
<li>extension receiver: 확장 대상이 되는 클래스</li>
<li>dispatch receiver: 확장 구문이 작성된 클래스</li>
<li>dispatch receiver 클래스 안에서만 사용 가능</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="제네릭"><a class="header" href="#제네릭">제네릭</a></h1>
<ul>
<li>제네릭은 형식타입</li>
<li>타입을 예측할 수 없거나</li>
<li>하나의 타입으로 고정할 수 없거나</li>
<li>제네릭으로 형식 타입을 선언하고 실제 사용할 때 정확한 타입 부여</li>
<li>타입 유추에 의해 이용 가능</li>
</ul>
<h2 id="선언-및-이용"><a class="header" href="#선언-및-이용">선언 및 이용</a></h2>
<pre><code class="language-kotlin">class MyClass&lt;T&gt; {
    var foo: T? = null
}

fun &lt;T&gt; bar(arg: T): T? {
    ...
}
</code></pre>
<h2 id="타입-제약"><a class="header" href="#타입-제약">타입 제약</a></h2>
<ul>
<li>제네릭을 선언하면서 특정 타입만 대입되도록 제약</li>
</ul>
<pre><code class="language-kotlin">class MathUtil&lt;T: Number&gt; {
    fun plus(a: T, b: T): Double {
        return a.toDouble() + b.toDouble()
    }
}
</code></pre>
<p>여러 타입의 제약도 가능하다</p>
<pre><code class="language-kotlin">interface foo
interface bar

class MyClass1: Foo, Bar
class MyClass2: Foo

class MyClass&lt;T&gt; where T: Foo, T: Bar {
    // ...
}

fun main(args: Array&lt;String&gt;) {
    var obj = MyClass&lt;MyClass1&gt;() // OK
    var obj1 = MyClass&lt;MyClass2&gt;() // error
}
</code></pre>
<h2 id="null-불허-제약"><a class="header" href="#null-불허-제약">Null 불허 제약</a></h2>
<ul>
<li>제네릭의 형식타입은 기본적으로 Nullable
<ul>
<li>기본적으로 <code>&lt;T: Any?&gt;</code>로 선언한 것과 같음</li>
</ul>
</li>
</ul>
<h2 id="variance"><a class="header" href="#variance">Variance</a></h2>
<p>제네릭에서 variance(공변)는 상하위관계에서 타입 변형과 관련되어 있다.</p>
<ul>
<li>제네릭은 타입이지 클래스가 아니다: invariance</li>
<li>기본적으로 invariance(불공변)</li>
<li>공변을 지원하기 위해 <code>out</code>과 <code>in</code> 어노테이션 필요</li>
<li>out 어노테이션을 이ㅛㅇ하여 하위 타입으로 선언된 객체를 상위 타입에 대입</li>
</ul>
<pre><code class="language-kotlin">open class Super

class Sub: Super()

class Foo&lt;T&gt;

fun testVariance() {
    Super obj = Sub() // OK, variance
}

fun testInvariance() {
    val obj = Foo&lt;Sub&gt;()

    val obj2: Foo&lt;Super&gt; = obj // error, invariance
}
</code></pre>
<pre><code class="language-kotlin">open class Super

class Sub: Super()

class Foo&lt;out T&gt; // 하위타입으로 선언된 객체를 상위 타입에 대입

fun testVariance() {
    Super obj = Sub() // OK, variance
}

fun testInvariance() {
    val obj = Foo&lt;Sub&gt;()
    val obj1 = Foo&lt;Super&gt;()

    val obj2: Foo&lt;Super&gt; = obj // OK
    val obj3: Foo&lt;Sub&gt; = obj1 // error
}
</code></pre>
<h3 id="out-어노테이션을-사용하는-규칙"><a class="header" href="#out-어노테이션을-사용하는-규칙"><code>out</code> 어노테이션을 사용하는 규칙</a></h3>
<ul>
<li>하위 제네릭 타입이 상위 제네릭 타입에 대입 가능</li>
<li>상위 제네릭 타입이 하위 제네릭 타입에 대입 불가능</li>
<li>함수 리턴 타입으로 선언 가능</li>
<li>함수 매개변수 타입으로 선언 불가능</li>
<li><code>val</code> 프로퍼티에 선언 가능</li>
<li><code>var</code> 프로퍼티에 선언 불가능</li>
</ul>
<blockquote>
<p>Covariance</p>
</blockquote>
<h3 id="in-어노테이션"><a class="header" href="#in-어노테이션"><code>in</code> 어노테이션</a></h3>
<p>상위 제네릭 타입이 하위 제네릭 타입에 대입되어 사용</p>
<ul>
<li>하위 제네릭 타입이 상위 제네릭 타입에 대입 불가능</li>
<li>상위 제네릭 타입이 하위 제네릭 타입에 대입 가능</li>
<li>함수 리턴 타입으로 선언 불가</li>
<li>함수 매개변수 타입으로 선언 가능</li>
<li><code>val</code>, <code>var</code> 프로퍼티에 선언 불가</li>
</ul>
<table><thead><tr><th>특징</th><th>in</th><th>out</th></tr></thead><tbody>
<tr><td>하위-&gt;상위 대입</td><td>x</td><td>o</td></tr>
<tr><td>상위-&gt;하위 대입</td><td>o</td><td>x</td></tr>
<tr><td>함수 리턴타입</td><td>x</td><td>o</td></tr>
<tr><td>함수 매개변수 타입</td><td>o</td><td>x</td></tr>
<tr><td><code>val</code>프로퍼티 사용</td><td>x</td><td>o</td></tr>
<tr><td><code>var</code>프로퍼티 사용</td><td>x</td><td>x</td></tr>
</tbody></table>
<h3 id="이용측-variance"><a class="header" href="#이용측-variance">이용측 variance</a></h3>
<p>실제 제네릭을 사용하는 곳에서 in, out을 사용할 ㅅ ㅜ있다.</p>
<h2 id="스타-프로젝션"><a class="header" href="#스타-프로젝션">스타(*) 프로젝션</a></h2>
<ul>
<li>제네릭 타입을 <code>&lt;*&gt;</code>로 표현하는 것을 의미</li>
<li>선언위치에선 불가, 사용위치에서만 가능</li>
<li>제네릭 타입을 모른다는 의미</li>
<li><code>&lt;Any?&gt;</code>는 정확한 타입을 명시한 것이고, <code>&lt;*&gt;</code>은 타입을 모른다는 것</li>
</ul>
<h3 id="제네릭과-as-is"><a class="header" href="#제네릭과-as-is">제네릭과 <code>as</code>, <code>is</code></a></h3>
<ul>
<li>제네릭 정보는 컴파일러를 위한 정보</li>
<li>컴파일이 끝나면 제네릭 정보는 모두 사라짐</li>
<li>런타임 시에 타입 체크 or 타입 캐스팅이 유지되어야 하는 상황이라면?</li>
</ul>
<h4 id="인라인-함수와-reinfied-이용"><a class="header" href="#인라인-함수와-reinfied-이용">인라인 함수와 <code>reinfied</code> 이용</a></h4>
<ul>
<li>제네릭 타입을 런타임까지 유지</li>
</ul>
<h2 id="unit-타입"><a class="header" href="#unit-타입"><code>Unit</code> 타입</a></h2>
<ul>
<li>Java의 <code>void</code>와 유사하지만</li>
<li><code>void</code>는 예약어</li>
<li><code>Unit</code>은 객체 타입</li>
</ul>
<pre><code class="language-kotlin">fun foo() {
    return Unit // OK
}

val bar: Unit = Unit
</code></pre>
<h3 id="제네릭에서의-unit-이용"><a class="header" href="#제네릭에서의-unit-이용">제네릭에서의 <code>Unit</code> 이용</a></h3>
<ul>
<li>상위 타입의 구현 함수의 리턴타입을 사용하지 않고 싶으면? Unit을 사용</li>
</ul>
<pre><code class="language-kotlin">interface Foo&lt;T&gt; {
   fun some(): T 
}
</code></pre>
<h2 id="nothing-타입"><a class="header" href="#nothing-타입"><code>Nothing</code> 타입</a></h2>
<ul>
<li>Nothing 타입이 선언되면 null만 대입</li>
<li>값이 없다는 것을 명시적으로 표현
<ul>
<li>Null이나 Exception 리턴할 때</li>
</ul>
</li>
</ul>
<h3 id="제네릭에서의-nothing-이용"><a class="header" href="#제네릭에서의-nothing-이용">제네릭에서의 <code>Nothing</code> 이용</a></h3>
<ul>
<li>Nothing의 코틀린의 <strong>최하위 타입</strong>이다.</li>
<li>어떤 타입의 프로퍼티에도 대입 가능
<ul>
<li><code>in</code>(반공변)을 사용할 때 사용</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-reflection"><a class="header" href="#18-reflection">18 Reflection</a></h1>
<p>런타임시 프로그램의 구조를 분석해내는 기법</p>
<h2 id="클래스-타입과-레퍼런스"><a class="header" href="#클래스-타입과-레퍼런스">클래스 타입과 레퍼런스</a></h2>
<ul>
<li>런타임 시 동적인 클래스 분석</li>
<li>클래스에 대한 정보를 클래스 reference, 클래스 reference가 대입되는 곳은 클래스 타입</li>
<li>클래스 타입은 <code>KClass&lt;*&gt;</code>로 표현하며, 클래스 reference는 <code>클래스명::class</code>로 표현</li>
</ul>
<blockquote>
<p>코틀린 리플렉션 타입에 Java 클래스를 넘길땐 <code>클래스명::class.java</code>로 표현</p>
</blockquote>
<pre><code class="language-kotlin">val foo: KClass&lt;*&gt; = String::class

fun bar(arg: KClass&lt;*&gt;) {
    // ...
}
</code></pre>
<h3 id="클래스-정보-분석"><a class="header" href="#클래스-정보-분석">클래스 정보 분석</a></h3>
<ul>
<li><code>val isAbstract: Boolean</code>: 클래스 reference가 abstract로 선언되었는가?</li>
</ul>
<h3 id="클래스-생성자-정보-분석"><a class="header" href="#클래스-생성자-정보-분석">클래스 생성자 정보 분석</a></h3>
<h3 id="클래스-프로퍼티-분석"><a class="header" href="#클래스-프로퍼티-분석">클래스 프로퍼티 분석</a></h3>
<h3 id="클래스-함수-분석"><a class="header" href="#클래스-함수-분석">클래스 함수 분석</a></h3>
<h2 id="레퍼런스-분석"><a class="header" href="#레퍼런스-분석">레퍼런스 분석</a></h2>
<ul>
<li>함수 레퍼런스는 <code>::함수명</code>을 이용</li>
<li>함수는 <code>KFunction&lt;*&gt;</code>으로 사용</li>
</ul>
<h3 id="고차함수-호출시-이용"><a class="header" href="#고차함수-호출시-이용">고차함수 호출시 이용</a></h3>
<pre><code class="language-kotlin">fun isOdd(x: Int): Boolean = x%2 != 0
</code></pre>
<h2 id="프로퍼티-레퍼런스-분석"><a class="header" href="#프로퍼티-레퍼런스-분석">프로퍼티 레퍼런스 분석</a></h2>
<ul>
<li>타입은 <code>KProperty&lt;*&gt;</code>와 <code>KMutableProperty&lt;*&gt;</code></li>
</ul>
<h2 id="어노테이션"><a class="header" href="#어노테이션">어노테이션</a></h2>
<ul>
<li>몸통을 가질 수 없음</li>
<li>용도
<ul>
<li>컴파일러에게 코드 문법에러를 체크: <code>@override</code></li>
<li>개발 툴이나 빌더에게 코드 자동 추가: Lombok(<code>@getter</code>, ...)</li>
<li>실행시 특정 기능을 실행: <code>@Autowired</code></li>
</ul>
</li>
<li><code>annotation</code> 예약어로 만드렁진다</li>
<li>인스턴스 생성 불가</li>
<li>실행영역을 가질 수 없다</li>
</ul>
<h3 id="어노테이션-설정"><a class="header" href="#어노테이션-설정">어노테이션 설정</a></h3>
<h4 id="데이터-설정"><a class="header" href="#데이터-설정">데이터 설정</a></h4>
<ul>
<li>주 생성자를 이용해 데이터 설정</li>
<li>val만 허용</li>
<li>허용 타입
<ul>
<li>Primitive type</li>
<li>String</li>
<li>class 리플렉션 정보</li>
<li>enum, annotations, ... -&gt; 개발자가 생성한 클래스를 제외하고</li>
</ul>
</li>
</ul>
<h3 id="어노테이션-선언-옵션"><a class="header" href="#어노테이션-선언-옵션">어노테이션 선언 옵션</a></h3>
<ul>
<li><code>@Target</code>: 어노테이션 허용 위치 설정</li>
<li><code>@Retention</code>: 런타임에 접근할 수 있는지, </li>
<li><code>@Repeatable</code>: 한 곳에서 반복사용 가능여부</li>
<li><code>@MustBeDocumented</code>: api 문서에 포함시켜야 하는지</li>
</ul>
<h3 id="어노테이션-적용대상-지정"><a class="header" href="#어노테이션-적용대상-지정">어노테이션 적용대상 지정</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-다양한-기법"><a class="header" href="#19-다양한-기법">19 다양한 기법</a></h1>
<h2 id="delegation-위임-패턴"><a class="header" href="#delegation-위임-패턴">Delegation, 위임 패턴</a></h2>
<p>코틀린에선 위임을 <code>by</code> 예약어를 사용</p>
<ul>
<li>인터페이스가 있어야됨</li>
<li>인터페이스를 구현한 delegatee가 존재</li>
<li>delegator도 동일 인터페이스를 상속
<ul>
<li>구현은 하지 않고 <code>by</code>로 표현</li>
</ul>
</li>
</ul>
<h3 id="delegation-property"><a class="header" href="#delegation-property">Delegation property</a></h3>
<ul>
<li>프로퍼티 위임도 가능</li>
<li>위임을 위한 클래스는 <code>getValue()</code>와 <code>setvalue()</code>가 있어야 함</li>
<li>프로퍼티 <code>get()</code>에 의해 <code>getValue() 호출, </code>set()<code>에 의해 </code>setValue()` 호출</li>
</ul>
<h2 id="samsingle-abstract-method-전환"><a class="header" href="#samsingle-abstract-method-전환">SAM(Single Abstract Method) 전환</a></h2>
<ul>
<li>한개의 함수만 정의된 클래스를 구현해야 하는 경우, 람다표현식으로 짧게 작성 가능</li>
</ul>
<h2 id="type-alias"><a class="header" href="#type-alias">Type alias</a></h2>
<ul>
<li>inner 타입도 정의 가능</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-kotlin-from-java"><a class="header" href="#calling-kotlin-from-java">Calling Kotlin from Java</a></h1>
<p>어노테이션을 열심히 붙이자!</p>
<h2 id="property"><a class="header" href="#property">Property</a></h2>
<h2 id="top-level-function--property"><a class="header" href="#top-level-function--property">Top-level function / property</a></h2>
<p>파일명+Kt 클래스의 스태틱 멤버</p>
<h3 id="어노테이션을-이용해서-클래스명을-명명-가능"><a class="header" href="#어노테이션을-이용해서-클래스명을-명명-가능">어노테이션을 이용해서 클래스명을 명명 가능</a></h3>
<pre><code class="language-kotlin">@file:JvmName(&quot;KotlinClass&quot;)
</code></pre>
<p>동일 패키지 내의 여러 파일을 동일 이름으로 지정하려면 <code>multiclass</code> 어쩌고를 등록해야 한다.</p>
<h2 id="인스턴스-필드"><a class="header" href="#인스턴스-필드">인스턴스 필드</a></h2>
<p>코틀린 프로퍼티는 private 변수로 선언되지만 <code>@JvmField</code>를 붙이면 일반 필드로 선언된다,</p>
<h2 id="함수명-바꿔서-공개"><a class="header" href="#함수명-바꿔서-공개">함수명 바꿔서 공개</a></h2>
<p><code>@JvmName</code>으로 함수명을 바꿀수 있다. 코틀린에는 전혀 영향 없음</p>
<h2 id="overload-생성"><a class="header" href="#overload-생성">overload 생성</a></h2>
<p>코틀린에선 오버로드가 없다. default argument가 존재한다. 자바로 변환할땐 full signature로 공개한다. <code>@JvmOverloads</code>로 오버로드 가능</p>
<h2 id="checked-exception"><a class="header" href="#checked-exception">checked exception</a></h2>
<p>어노테이션 붙이자</p>
<h2 id="null-safety"><a class="header" href="#null-safety">Null Safety</a></h2>
<p>개발자 몫이다</p>
<h2 id="확장함수"><a class="header" href="#확장함수">확장함수</a></h2>
<p>이건 애매</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-java-with-kotlin"><a class="header" href="#calling-java-with-kotlin">Calling Java with Kotlin</a></h1>
<h2 id="java-api를-코틀린에서-사용-가능한가"><a class="header" href="#java-api를-코틀린에서-사용-가능한가">Java API를 코틀린에서 사용 가능한가?</a></h2>
<blockquote>
<p>얼마든지</p>
</blockquote>
<pre><code class="language-java">// Java
public class Foo {
    void bar() {
        /...
    }
}
</code></pre>
<pre><code class="language-kotlin">// Kotlin
val obj = Foo()
obj.bar
</code></pre>
<p>Object, Collections, primitive type 등은 코틀린에서 API 제공하기 때문에 Kotlin API 사용을 권장한다.</p>
<pre><code class="language-kotlin">// kotlin
val obj: java.lang.Object = Object()
</code></pre>
<h2 id="자바의-타입을-어떻게-매핑할까"><a class="header" href="#자바의-타입을-어떻게-매핑할까">자바의 타입을 어떻게 매핑할까</a></h2>
<ul>
<li>코틀린에서는 모든 것이 객체</li>
<li>코틀린의 타입은 nullable, non-nullable로 구분</li>
</ul>
<h3 id="primitive-type"><a class="header" href="#primitive-type">primitive type</a></h3>
<p>자바의 기초타입은 null을 대입할 수 없다. 그래서 모틀린에서는 non-nullable로 매핑된다.</p>
<table><thead><tr><th>Java</th><th>Kotlin</th></tr></thead><tbody>
<tr><td>int</td><td>kotlin.Int</td></tr>
</tbody></table>
<h4 id="boxed-primitive-type"><a class="header" href="#boxed-primitive-type">Boxed-primitive type</a></h4>
<p>Boxing된 primitive type은 객체이기 때문에 null 대입 가능, 그러므로 platform type으로 매핑한다.</p>
<table><thead><tr><th>Java</th><th>Kotlin</th></tr></thead><tbody>
<tr><td>java.lang.Integer</td><td>kotlin.Int!</td></tr>
</tbody></table>
<blockquote>
<h4 id="platform-type"><a class="header" href="#platform-type">Platform type?</a></h4>
<p>개발자가 명시적으로 선언할 수 있는 타입은 아니다.
nullablity 정보가 없는 타입을 지칭한다.
null 가능성에 대해 아무 정보가 없기 때문에 NPE 가능성이 높아진다.
개발자가 대응해야 한다.</p>
</blockquote>
<h3 id="non-primitive-type"><a class="header" href="#non-primitive-type">Non-primitive type</a></h3>
<table><thead><tr><th>Java</th><th>Kotlin</th></tr></thead><tbody>
<tr><td>java.lang.Object</td><td>kotlin.Any!</td></tr>
<tr><td>java.lang.String</td><td>kotlin.String!</td></tr>
</tbody></table>
<h3 id="collection-type"><a class="header" href="#collection-type">Collection type</a></h3>
<p>코틀린에선 mutable/imumutable 타입으로 구분한다.</p>
<ul>
<li>기본적으로 platform type으로 처리</li>
<li>기본적으로 mutable로 처리</li>
</ul>
<h3 id="array"><a class="header" href="#array">Array</a></h3>
<table><thead><tr><th>Java</th><th>Kotlin</th></tr></thead><tbody>
<tr><td>int[]</td><td>IntArray!</td></tr>
<tr><td>String[]</td><td>Array&lt;(out) STring&gt;!</td></tr>
</tbody></table>
<h2 id="null-safety-1"><a class="header" href="#null-safety-1">Null Safety</a></h2>
<h3 id="nullable-notnull-어노테이션이-추가된-경우"><a class="header" href="#nullable-notnull-어노테이션이-추가된-경우"><code>@Nullable</code>, <code>@NotNull</code> 어노테이션이 추가된 경우</a></h3>
<ul>
<li><code>@Nullable</code>이 있으면 Nullable로 유추</li>
<li><code>@NotNull</code>이 있으면 non-nullable로 유추</li>
</ul>
<h2 id="gettersetter"><a class="header" href="#gettersetter">Getter/Setter</a></h2>
<p>코틀린에서는 변수는 프로퍼티(not field)이다.
자바의 getter/setter도 프로퍼티로 이용 가능하다.</p>
<ul>
<li>프로퍼티 변환은 편의성 증대를 위해서,</li>
<li>게터 세터를 직접 호출할 수 있다.</li>
</ul>
<h2 id="return-void"><a class="header" href="#return-void">return <code>void</code></a></h2>
<p>Unit 타입으로 변환한다.</p>
<pre><code class="language-java">// java
class Foo {
    public void bar() {
        // ...
    }
}
</code></pre>
<pre><code class="language-kotlin">// kotlin
val obj = Foo()
val result: Unit = obj.bar()
</code></pre>
<h2 id="이스케이프"><a class="header" href="#이스케이프">이스케이프</a></h2>
<h2 id="java-배열-사용하기"><a class="header" href="#java-배열-사용하기">Java 배열 사용하기</a></h2>
<p>코틀린의 배열은 invariant하다. 즉 <code>Array&lt;Any&gt;</code>에 <code>Array&lt;String&gt;</code>을 할당할 수 없다.</p>
<p>자바의 <code>Integer[]</code>를 <code>Array&lt;Int&gt;</code>로 사용하는데 없다. variant 문제 발생하지 않음</p>
<p><code>int[]</code>를 <code>Array&lt;Int&gt;</code>로 표현 불가, primitive 타입.</p>
<h2 id="vararg"><a class="header" href="#vararg"><code>vararg</code></a></h2>
<p>문법적인 차이,</p>
<h2 id="operator"><a class="header" href="#operator">operator</a></h2>
<p>자바 메서드를 연산자 재정의해서 호출 가능하다.</p>
<h2 id="checked-exception-1"><a class="header" href="#checked-exception-1">checked exception</a></h2>
<p>코틀린에선 이 개념이 없다. </p>
<h2 id="object-메서드"><a class="header" href="#object-메서드"><code>Object</code> 메서드</a></h2>
<p><code>Any</code>는 JVM만을 위한 타입이 아니다. (JS, Native...)</p>
<h3 id="wait--notify"><a class="header" href="#wait--notify">wait() / notify()</a></h3>
<p>Object로 캐스팅해서 사용</p>
<h3 id="getclass"><a class="header" href="#getclass">getClass()</a></h3>
<p><code>::class.java</code>로 사용</p>
<h2 id="static-member"><a class="header" href="#static-member">static member</a></h2>
<h2 id="final-variable"><a class="header" href="#final-variable">final variable</a></h2>
<p>val로 적용</p>
<h2 id="초기화되지-않은-클래스-멤버-이용"><a class="header" href="#초기화되지-않은-클래스-멤버-이용">초기화되지 않은 클래스 멤버 이용</a></h2>
<p>런타임시 에러 발생 가능성 있음</p>
<h2 id="자바-클래스-확장"><a class="header" href="#자바-클래스-확장">자바 클래스 확장</a></h2>
<p>가능하다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="디자인-패턴"><a class="header" href="#디자인-패턴">디자인 패턴</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="제어-역전-ioc-inversion-of-control"><a class="header" href="#제어-역전-ioc-inversion-of-control">제어 역전 (IoC, Inversion of Control)</a></h1>
<p>제어 역전은 사용자가 작성한 프로그램이 다른 라이브러리 혹은 프레임워크의 제어를 받는 패턴을 의미한다. 일반적으로 작성한 프로그램이 외부 API나 라이브러리를 호출하지만, 제어 역전 패턴에선, 사용자가 작성한 프로그램이 다른 라이브러리 혹은 프레임워크의 제어를 받게 된다.</p>
<p>대표적으로 스프링 프레임워크가 있다. 제어 역전과 의존성 주입(Dependency Injection) 패턴을 이용하여 사용자가 작성한 프로그램을 인스턴스화하고 ApplicationContext에서 인스턴스들을 필요한 곳에 주입한다.</p>
<p>스프링 프레임워크는 개발자가 MVC 패턴 코드로 작성하게끔 강제하고, 작성한 프로그램은 인스턴스를 생성하지 않는다. 프레임워크가 생성하고 관리하기 때문이다.</p>
<p><code>Controller</code>, <code>Service</code>, <code>Repository</code> 등의 클래스를 <code>new</code> 키워드로 생성한 적이 있는지 생각해보자. 보통 <strong>어노테이션</strong>을 클래스 선언부 상단에 추가하고 <em>어노테이션 드리븐(annotation-driven)</em> 설정으로 모든 클래스를 인스턴스화 한다.</p>
<h2 id="목적"><a class="header" href="#목적">목적</a></h2>
<blockquote>
<h4 id="a-hrefhttpskowikipediaorgwikieca09cec96b4_ebb098eca084위키피디아a의-제어-역전-목적"><a class="header" href="#a-hrefhttpskowikipediaorgwikieca09cec96b4_ebb098eca084위키피디아a의-제어-역전-목적"><a href="https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4_%EB%B0%98%EC%A0%84">위키피디아</a>의 제어 역전 목적</a></h4>
<ul>
<li>작업을 구현하는 방식과 작업 수행 자체를 분리한다.</li>
<li>모듈을 제작할 때, 모듈과 외부 프로그램의 결합에 대해 고민할 필요 없이 모듈의 목적에 집중할 수 있다.</li>
<li>다른 시스템이 어떻게 동작할지에 대해 고민할 필요 없이, 미리 정해진 협약대로만 동작하게 하면 된다.</li>
<li>모듈을 바꾸어도 다른 시스템에 부작용을 일으키지 않는다.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mvc-패턴과-spring-프레임워크"><a class="header" href="#mvc-패턴과-spring-프레임워크">MVC 패턴과 Spring 프레임워크</a></h1>
<p>사실과 다른 내용이 있으면 피드백 부탁드립니다.</p>
<h2 id="mvc-패턴"><a class="header" href="#mvc-패턴">MVC 패턴</a></h2>
<ul>
<li><a href="https://opentutorials.org/course/697/3828">MVC 패턴</a>이 무엇인가?</li>
<li>왜 MVC 패턴을 써야하는가?
<ul>
<li>비즈니스가 복잡해지니까</li>
<li>모델/뷰/컨트롤러를 분리할 필요성 제기
<ul>
<li>하나의 복잡한 프로그램보단 단순한 여러개의 프로그램의 모음이 유지보수하기 용이하다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="mvc-패턴이-왜-나왔을까"><a class="header" href="#mvc-패턴이-왜-나왔을까">MVC 패턴이 왜 나왔을까?</a></h3>
<h4 id="정적-웹페이지"><a class="header" href="#정적-웹페이지">정적 웹페이지</a></h4>
<ul>
<li>말 그대로 <strong>정적</strong> 웹사이트
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EC%9B%94%EB%93%9C_%EC%99%80%EC%9D%B4%EB%93%9C_%EC%9B%B9#%EC%97%AD%EC%82%AC">월드와이드웹은 문서를 공유하기 위해 탄생한 공간</a></li>
<li><a href="https://www.crockford.com/blog.html">정적인 웹사이트 예: Douglas Crockford</a></li>
</ul>
</li>
<li>Q. 정적 웹페이지의 단점?</li>
</ul>
<h4 id="동적-웹페이지-mvc-1도-포함"><a class="header" href="#동적-웹페이지-mvc-1도-포함">동적 웹페이지 (MVC 1도 포함)</a></h4>
<ul>
<li>WWW은 문서 이상의 기능을 수행한다.
<ul>
<li>쇼핑몰, 게임, 비디오, ...</li>
</ul>
</li>
<li>이제 다이나믹 웹 페이지를 만들 수 있음</li>
<li>데이터 저장소도 따로 있음 (DBMS)</li>
<li>서블릿: <a href="https://pradnyanaik.files.wordpress.com/2009/08/javacode1.jpg?w=780">Java 소스코드 안에 HTML이</a></li>
<li>JSP: <a href="https://archive.cnx.org/resources/08f1337f66482fcca8068627d1eca6d5340137ac/Code-viewSessionData.jsp.png">HTML 안에 Java 코드가</a></li>
<li>프로그램이 커지면 코드 가독성이 떨어진다.</li>
<li>뷰(HTML) 코드와 서버(Java) 코드를 분리하고 싶다
<ul>
<li>1 source/20,000 lines vs 200 sources/100 lines</li>
</ul>
</li>
</ul>
<p>Q. MVC 패턴인 좋은건 알겠는데 어떻게 구현하지?</p>
<h2 id="spring-프레임워크"><a class="header" href="#spring-프레임워크">Spring 프레임워크</a></h2>
<p><img src="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/images/spring-overview.png" alt="Spring framework architecture" /></p>
<ul>
<li>IoC, Inversion of Control
<ul>
<li>Q1. 프레임워크와 라이브러리의 차이?</li>
<li>Q2. 인스턴스 생성 주체</li>
<li>스프링 IOC 컨테이너
<ul>
<li>인스턴스의 생명주기를 관리: 객체 생성은 누가?</li>
</ul>
</li>
<li><a href="https://gmlwjd9405.github.io/2018/11/10/spring-beans.html">스프링 Bean</a>
<ul>
<li>Lifecycle of Spring Beans  <img src="https://qph.fs.quoracdn.net/main-qimg-f77ca60f3c1a69580e3bd32408663a49" alt="빈 라이프사이클" /></li>
<li>Singleton, Stateless?</li>
</ul>
</li>
</ul>
</li>
<li>DI, Dependency Injection
<ul>
<li>@Autowired @Inject
<ul>
<li>Q. 주입받는 인스턴스가 생성되지 않는다면?</li>
</ul>
</li>
<li>인스턴스를 생성하는데 필요한 또다른 인스턴스들</li>
<li>Injection 방법들
<ul>
<li>Field Injection: Autowired</li>
<li>Constructor Injection: Contructor argument</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://ko.wikipedia.org/wiki/%EA%B4%80%EC%A0%90_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">AOP, Aspect Oriented Programming</a>
<ul>
<li>비즈니스와 별개의 동작: 로깅, 보안, ...</li>
<li>원하는 부분에 Point-cut을 추가</li>
<li>AOP를 Controller 레이어에서 구현 가능?: <code>@ControllerAdvice</code></li>
</ul>
</li>
<li>Spring MVC  <img src="https://terasolunaorg.github.io/guideline/1.0.1.RELEASE/en/_images/RequestLifecycle.png" alt="Spring MVC 구조" />
<ul>
<li><a href="https://mangkyu.tistory.com/18">Dispatcher Servlet</a>
<ul>
<li>Q. 이미지, html 같은 정적(static) 파일들의 처리는?</li>
</ul>
</li>
<li><a href="https://joont92.github.io/spring/HandlerMapping-HandlerAdapter-HandlerInterceptor/">Handler</a>
<ul>
<li>AnnotationMethodHandlerAdapter</li>
</ul>
</li>
<li>Controller
<ul>
<li><a href="https://cornswrold.tistory.com/56">filter, interceptor, controller advice 순서?</a></li>
</ul>
</li>
<li>Model (include business logic)</li>
<li>View Resolver
<ul>
<li>JSP, XML, JSON, Velocity, ...</li>
<li>Content Negotiation</li>
</ul>
</li>
</ul>
</li>
<li>어노테이션
<ul>
<li><a href="https://jeong-pro.tistory.com/151">어노테이션 종류</a>
<ul>
<li><code>@Controller</code></li>
<li><code>@Service</code></li>
<li><code>@Repository</code></li>
<li><code>@Component</code></li>
<li><code>@Bean</code></li>
<li><code>@Autowired</code></li>
<li><code>@Configuration</code></li>
<li><code>@SpringBootApplication</code></li>
</ul>
</li>
<li>Q. 컨트롤러 클래스에 @Controller 대신 @Service를 붙이면 어떻게 될까?</li>
<li>Q. <a href="https://jojoldu.tistory.com/27">Component와 Bean의 차이?</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-using-springbootapplication-annotation.html">어노테이션만 붙이면 다 알아서 되나?</a></li>
</ul>
</li>
<li>Spring Boot: https://start.spring.io/
<ul>
<li>Spring XML 설정</li>
<li>Default 설정
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/1.1.8.RELEASE/reference/html/howto-embedded-servlet-containers.html">Boot Default Servlet Container</a></li>
</ul>
<blockquote>
<p>...<br />
59.9 Use Jetty instead of Tomcat
The Spring Boot starters (spring-boot-starter-web in particular) <strong>use Tomcat as an embedded container by default</strong>. You need to exclude those dependencies and include the Jetty one instead. Spring Boot provides Tomcat and Jetty dependencies bundled together as separate starters to help make this process as easy as possible.<br />
...</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="참고자료"><a class="header" href="#참고자료">참고자료</a></h2>
<ul>
<li><a href="https://opentutorials.org/course/697/3828">생활코딩 - MVC 패턴</a></li>
<li><a href="https://m.blog.naver.com/PostView.nhn?blogId=goddlaek&amp;logNo=220901890910&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F">[JSP/Servlet] CGI 그리고 Servlet과 JSP와의 관계</a></li>
<li><a href="https://www.slipp.net/wiki/pages/viewpage.action?pageId=25527606">spring - 1주차 IoC와 DI</a></li>
<li><a href="https://youtu.be/srQR0Qb7Joo">백기선 - 더 나은 개발자로 성장하는 팁 &quot;어! 에러가 났네? 어떡하지?&quot;</a></li>
<li><a href="https://youtu.be/BfyegHhCh_g">백기선 - 더 나은 개발자로 성장하는 팁 &quot;개발자라면 디버거 사용법은 꼭 알아야죠&quot;</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLfI752FpVCS8_5t29DWnsrL9NudvKDAKY">백기선 - 예제로 배우는 스프링 입문</a></li>
<li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/index.html">Spring Docs</a></li>
<li>그 외 본문 내 링크들을 참고하세요.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="db"><a class="header" href="#db">DB</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oracle"><a class="header" href="#oracle">Oracle</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oracle-flashback"><a class="header" href="#oracle-flashback">Oracle Flashback</a></h1>
<p>Oracle Flashback 기술은 특정 과거 시점의 데이터 상태를 조회하거나 복원할 수 있는 기술을 제공한다.
하지만 너무 이전 시점의 데이터를 조회하면 <code>ORA-01555</code>같은 오류메시지를 받을 수 있다.</p>
<h2 id="타임스탬프를-이용한-데이터-복원"><a class="header" href="#타임스탬프를-이용한-데이터-복원">타임스탬프를 이용한 데이터 복원</a></h2>
<p>1. 정확한 시간을 설정하여 데이터 복원</p>
<pre><code class="language-sql">SELECT *
  FROM EMP
       AS OF TIMESTAMP SYSTIMESTAMP TO_TIMESTAMP('2018-12-27 10:00:00', 'yyyy-mm-dd hh24:mi:ss');
</code></pre>
<p>2. 현재로부터 특정 시간 전의 데이터 복원</p>
<pre><code class="language-sql">SELECT *
  FROM EMP
       AS OF TIMESTAMP SYSTIMESTAMP - INTERVAL '3' HOUR -- DAY, HOUR, MINUTE, SECOND, ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">Block</a></h1>
<p>DBMS의 I/O 단위이다. DBMS에 따라 페이지(page)라고 부르기도 한다.</p>
<h2 id="특징-4"><a class="header" href="#특징-4">특징</a></h2>
<ul>
<li>I/O의 단위이다.</li>
<li></li>
<li>컬럼 단위 I/O를 지원하는 DBMS도 있다.</li>
<li>오라클의 허용 블록 크기는 2k, 4k, 8k(default), 16k, 32k 이다.
<ul>
<li>테이블 스페이스별 블록 사이즈와 버퍼풀을 구성할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="oracle에서-테이블-스페이스의-블록-사이즈-조회"><a class="header" href="#oracle에서-테이블-스페이스의-블록-사이즈-조회">Oracle에서 테이블 스페이스의 블록 사이즈 조회</a></h2>
<pre><code class="language-sql">-- 오라클 블록의 사이즈 조회
SELECT tablespace_name, block_size/1024 as block_size_kb FROM dba_tablespaces;
</code></pre>
<h2 id="참고-2"><a class="header" href="#참고-2">참고</a></h2>
<ul>
<li><a href="http://wiki.gurubee.net/pages/viewpage.action?pageId=26744692">데이터베이스 IO 원리</a></li>
<li><a href="http://wiki.gurubee.net/pages/viewpage.action?pageId=26739100">블록 단위 IO - 구루비</a></li>
<li><a href="http://www.gurubee.net/lecture/2924">블록 사이즈별 성능 비교 - 구루비</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hwm-high-water-mark"><a class="header" href="#hwm-high-water-mark">HWM, High Water Mark</a></h1>
<p>테이블이 사용한 block과 사용하지 않은 block의 경계점을 나타낸다.</p>
<h2 id="block의-상태"><a class="header" href="#block의-상태">Block의 상태</a></h2>
<p>block을 사용하려면 먼저 할당과 포맷이 이루어져야 한다.</p>
<ul>
<li>Used: 사용 중, 포맷 됨</li>
<li>Unknown: 사용 된 적이 있으나 현재 사용 중인지는 모름, 포맷 됨</li>
<li>Never used(Unformatted): 사용된 적이 없음, 포맷되지 않음</li>
</ul>
<p>만약 로우 1000개를 삽입한 후, 500개를 삭제한다면, 삭제한 만큼의 블록이 <code>Unknown</code> 상태가 될 것이다.</p>
<p><svg version="1.1"
     baseProfile="full"
     width="410" height="180"
     xmlns="http://www.w3.org/2000/svg">
<rect x="0" y="10" width="50" height="100" stroke="black" fill="grey" stroke-width="1" />
<rect x="0" y="40" width="50" height="10" stroke="black" fill="white" stroke-width="1" />
<rect x="50" y="10" width="50" height="100" stroke="black" fill="grey" stroke-width="1" />
<rect x="50" y="30" width="50" height="40" stroke="black" fill="white" stroke-width="1" />
<text x="75" y="130" font-size="12" text-anchor="middle" fill="black">used</text>
<rect x="100" y="10" width="50" height="100" stroke="black" fill="grey" stroke-width="1" />
<rect x="100" y="15" width="50" height="5" stroke="black" fill="white" stroke-width="1" />
<rect x="150" y="10" width="50" height="100" stroke="black" fill="transparent" stroke-width="1" />
<text x="175" y="65" font-size="12" text-anchor="middle" fill="black">?</text>
<rect x="200" y="10" width="50" height="100" stroke="black" fill="transparent" stroke-width="1" />
<text x="225" y="65" font-size="12" text-anchor="middle" fill="black">?</text>
<text x="200" y="130" font-size="12" text-anchor="middle" fill="black">unknown</text>
<rect x="250" y="10" width="50" height="100" stroke="black" fill="transparent" stroke-width="1" />
<rect x="300" y="10" width="50" height="100" stroke="black" fill="transparent" stroke-width="1" />
<rect x="350" y="10" width="50" height="100" stroke="black" fill="transparent" stroke-width="1" />
<text x="300" y="130" font-size="12" text-anchor="middle" fill="black">never used</text>
<line x1="150" x2="150" y1="115" y2="150" stroke="black" stroke-width="1" />
<line x1="150" x2="155" y1="115" y2="125" stroke="black" stroke-width="1" />
<line x1="150" x2="145" y1="115" y2="125" stroke="black" stroke-width="1" />
<text x="150" y="160" font-size="12" text-anchor="middle" fill="black">Low HWM</text>
<line x1="250" x2="250" y1="115" y2="150" stroke="black" stroke-width="1" />
<line x1="250" x2="255" y1="115" y2="125" stroke="black" stroke-width="1" />
<line x1="250" x2="245" y1="115" y2="125" stroke="black" stroke-width="1" />
<text x="250" y="160" font-size="12" text-anchor="middle" fill="black">High HWM</text>
</svg></p>
<h2 id="low-hwm"><a class="header" href="#low-hwm">Low HWM</a></h2>
<p>Used 상태의 block 영역을 나타낸다.</p>
<h2 id="high-hwm"><a class="header" href="#high-hwm">High HWM</a></h2>
<p>Used + Unknown 영역, 즉 High HWM 이후의 block은 포맷되지 않음을 의미한다.</p>
<h2 id="hwm-재조정을-위한-쿼리"><a class="header" href="#hwm-재조정을-위한-쿼리">HWM 재조정을 위한 쿼리</a></h2>
<p>Oracle 10g 이후 ASSM 적용된 테이블 스페이스만 지원된다.</p>
<pre><code class="language-sql">ALTER TABLE 테이블_이름 ENABLE ROW MOVEMENT;
ALTER TABLE 테이블_이름 SHRINK SPACE;
ALTER TABLE 테이블_이름 DEALLOCATE UNUSED;
ALTER TABLE 테이블_이름 DISABLE ROW MOVEMENT;
</code></pre>
<h2 id="참고-3"><a class="header" href="#참고-3">참고</a></h2>
<ul>
<li><a href="http://wiki.gurubee.net/pages/viewpage.action?pageId=26741144">용어 - 구루비</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis-튜토리얼"><a class="header" href="#redis-튜토리얼">REDIS 튜토리얼</a></h1>
<p>레디스는 <code>key</code>:<code>value</code> 저장방식의 NoSQL 데이터베이스이다.</p>
<h2 id="환경-구성"><a class="header" href="#환경-구성">환경 구성</a></h2>
<h3 id="docker"><a class="header" href="#docker">docker</a></h3>
<pre><code class="language-bash">$ docker run -p 6379:6379 redis # 6379 포트로 redis 서버 구동
</code></pre>
<h3 id="redis-cli-by-npm"><a class="header" href="#redis-cli-by-npm">redis-cli (by npm)</a></h3>
<pre><code class="language-bash">$ npm i redis-cli
$ rdcli # 127.0.0.1:6379로 connection
</code></pre>
<h2 id="기본-저장조회-명령"><a class="header" href="#기본-저장조회-명령">기본 저장/조회 명령</a></h2>
<ul>
<li>set: 키 값에 데이터 저장, 값이 존재하면 덮어쓴다.</li>
<li>get: 값 조회, 없으면 nil 반환</li>
<li>del: 키 삭제</li>
<li>incr: 값 증가</li>
<li>expire: 키 유효효기간 설정(단위: 초)</li>
<li>ttl: 키 유효기간 확인</li>
</ul>
<pre><code class="language-redis">$ SET server:name &quot;fido&quot;
$ GET server:name
&quot;fido&quot;
$ DEL server:name
(integer) 1
</code></pre>
<p>foo 키의 값에 10을 넣고, incr 명령어로 값 1 증가시킨다.
데이터가 정수형인 경우에만 가능하다.</p>
<pre><code class="language-redis">$ set bar 10
$ incr bar =&gt; 11
$ get bar =&gt; 11
</code></pre>
<p>expire 명령어로 데이터의 유효기간을 설정할 수 있다.
아래는 특정 값을 추가한 뒤에 60초 후에 만료되는 키를 생성하는 코드이다.</p>
<pre><code class="language-redis">$ SET foo &quot;60초 후에 삭제된다.&quot;
$ expire foo 60
</code></pre>
<h2 id="다양한-데이터-타입"><a class="header" href="#다양한-데이터-타입">다양한 데이터 타입</a></h2>
<h3 id="리스트"><a class="header" href="#리스트">리스트</a></h3>
<h4 id="데이터-추가-lpush-rpush"><a class="header" href="#데이터-추가-lpush-rpush">데이터 추가: LPUSH, RPUSH</a></h4>
<p>LPUSH는 리스트의 맨 앞에, RPUSH는 리스트의 맨 끝에 추가한다. lpop, rpop 명령어로 리스트 양쪽의 값을 순차적으로 제거한다.</p>
<pre><code class="language-redis">$ lpush friends &quot;bob&quot;
$ lpush friends &quot;jane&quot;
$ lpush friends &quot;shawn&quot;
$ lrange friends 0 -1 =&gt;
1) shawn
2) jane
3) bob
$ llen friends =&gt; 3
</code></pre>
<h3 id="셋set"><a class="header" href="#셋set">셋(set)</a></h3>
<p>셋은 리스트와 유사하지만, <strong>비순차적</strong>이고 <strong>요소값이 유일</strong>하다.
sadd, srem으로 값 추가/삭제를 하고, </p>
<ul>
<li>sadd: 요소 추가</li>
<li>srem: 요소값 삭제</li>
<li>smembers: 요소값 조회</li>
<li>sismember: 값이 존재하는지 확인 </li>
<li>sunion: 데이터 병합(중복되는 데이터는 없다. 왜? set이니까)</li>
</ul>
<h3 id="sorted-set"><a class="header" href="#sorted-set">Sorted set</a></h3>
<p>set 자료형과 유사하지만, 순서가 존재한다.</p>
<ul>
<li>zadd: 요소 추가</li>
<li>zrange: 요소 조회</li>
</ul>
<h3 id="hash"><a class="header" href="#hash">Hash</a></h3>
<p>Hash는 필드:값으로 구성된 자료형이다.</p>
<ul>
<li><code>hset user name &quot;john&quot;</code>: user의 name 필드에 john이라는 값을 추가</li>
<li><code>hgetall user</code>: user의 모든 데이터 조회</li>
<li><code>hget user name</code>: user의 name 필드값 조회</li>
<li><code>hmset user name &quot;Mary&quot; age &quot;30&quot; password &quot;s3cret&quot;</code>: 복수필드 값 추가</li>
<li><code>hdel user age</code>: age 필드 삭제</li>
<li><code>hincrby user age 1</code>: age 필드 1만큼 증가</li>
</ul>
<h2 id="참고자료-1"><a class="header" href="#참고자료-1">참고자료</a></h2>
<ul>
<li>https://goodgid.github.io/Redis/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="구체-수학"><a class="header" href="#구체-수학">구체 수학</a></h1>
<h2 id="구체-수학이-뭘까"><a class="header" href="#구체-수학이-뭘까">구체 수학이 뭘까</a></h2>
<p>구체 수학의 'Concrete'는 연속수학(<strong>Con</strong>tinuos mathematics)와 이산수학(dis<strong>crete</strong> mathematics)를 섞은 것이다.
수학 공식들을 일단 문제 해결 기법들을 이용해서 통제된 방식으로 조작하는 것이다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-재귀적인-문제들"><a class="header" href="#1-재귀적인-문제들">1. 재귀적인 문제들</a></h1>
<h2 id="11-하노이의-탑"><a class="header" href="#11-하노이의-탑">1.1 하노이의 탑</a></h2>
<blockquote>
<p>하노이의 탑은 원반 여덟 개로 된 탑으로 시작한다. 원반들은 세 개의 기둥 중 하나에 큰 것부터 크기순으로 쌓여 있다. 목표는 원반을 하나씩 이동해서 탑 전체를 다른 기둥으로 옮기는 것이다. 단, 작은 원반 위에 큰 원반을 놓아서는 안된다.</p>
</blockquote>
<h3 id="문제를-해결하는-방법"><a class="header" href="#문제를-해결하는-방법">문제를 해결하는 방법</a></h3>
<p>1. 작은 사례들을 살펴본다.</p>
<ul>
<li>원반 이동 횟수
<ul>
<li>원반이 1개일 때, 1번</li>
<li>원반이 2개일 때, 3번</li>
<li>원반이 3개일 때, 7번</li>
</ul>
</li>
</ul>
<p>2. 적절한 표기법을 도입한다.(명명정복, name and conquer)</p>
<p>1개의 원반을 옮길 때의 총 이동횟수를 (( T ))라고 명명하자. 그러면 아래와 같이 표현할 수 있다.</p>
<p>\[ T_0 = 0 \]
\[ T_1 = 1 \]
\[ T_2 = 3 \]
\[ T_3 = 7 \]</p>
<p>3. 크게 생각해보자.</p>
<p><strong>n</strong>개의 원반이 있을 때, 모든 원반을 옮기는 최소 이동횟수는 아래와 같은 수식으로 표현할 수 있다.</p>
<p>\[ T_0 = 0 \]
\[ T_n = 2T_{n-1} + 1, n \geq 0 \]</p>
<h4 id="코드"><a class="header" href="#코드">코드</a></h4>
<pre><code class="language-js">function tower_of_hanoi_recursive(n) {
    if(n == 0) {
        return 0;
    }
    return 2 * tower_of_hanoi_recursive(n-1) + 1
}

console.time('하노이의탑-재귀:n=3');
console.log(tower_of_hanoi_recursive(3));
console.timeEnd('하노이의탑-재귀:n=3');
</code></pre>
<h3 id="점화식-recurrence-formula-or-recurrence-relation"><a class="header" href="#점화식-recurrence-formula-or-recurrence-relation">점화식 (recurrence formula or recurrence relation)</a></h3>
<ul>
<li>구성요소
<ul>
<li>경곗값 (boundary value)</li>
<li>등식: 일반항의 값을 이전 값들로 서술</li>
</ul>
</li>
<li>경곗값이 있어야 점화식이 완성된다.</li>
<li>점화식이 있으면 임의의 \( n \)에 대해 \( T_n \)을 계산할 수 있다.
<ul>
<li>\( n \)이 크면 점화식으로 값을 계산하는데 시간이 많이 걸린다.</li>
<li><strong>점화식의 해</strong>가 있다면 \( T_n \)을 빠르게 계산할 수 있다.</li>
<li><strong>닫힌 형식(clsoed form)</strong> 의 공식</li>
</ul>
</li>
</ul>
<h3 id="수학적-귀납법-mathematical-induction"><a class="header" href="#수학적-귀납법-mathematical-induction">수학적 귀납법 (mathematical induction)</a></h3>
<p>정수 \( n \) 에 관한 어떤 명제가 모든 \( n \geq n_0 \) 에 대해 참임을 증명하는 일반적인 방법</p>
<ul>
<li>기초(basic): 명제를 \( n \)의 가장 작은 값 \( n_0 \)에 대해 증명</li>
<li>귀납(induction): 명제가 \( n_0 \)에서 \( n-1 \)까지 증명되었다는 가정 하에 \( n \geq n_0 \)에 대해 명제를 증명</li>
</ul>
<p>계속해서 작은 사례를 살펴보자.</p>
<p>\[ T_4 = T_3 + 8 = 15 \]
\[ T_5 = T_4 + 16 = 31 \]
\[ ... \]
\[ T_n = 2^n - 1, n &gt; 0 \]</p>
<h4 id="코드-1"><a class="header" href="#코드-1">코드</a></h4>
<pre><code class="language-js">function tower_of_hanoi_closed(n) {
    return Math.pow(2, n) -1;
}

console.time('하노이의탑-닫힌 형식:n=3');
console.log(tower_of_hanoi_closed(3));
console.timeEnd('하노이의탑-닫힌 형식:n=3');
</code></pre>
<h2 id="12-평면의-선들"><a class="header" href="#12-평면의-선들">1.2. 평면의 선들</a></h2>
<blockquote>
<p>칼로 피자를 \( n \) 번 자른다고 할 때, 피자 조각이 최대 몇개나 나올까?</p>
</blockquote>
<p><svg version="1.1"
     baseProfile="full"
     width="200" height="150"
     xmlns="http://www.w3.org/2000/svg">
<rect width="100%" height="100%" fill="none" />
<line x1="95" x2="105" y1="130" y2="10" stroke="black" stroke-width="1" />
<text x="50" y="75" font-size="15" text-anchor="middle" fill="black">a</text>
<text x="150" y="75" font-size="15" text-anchor="middle" fill="black">b</text>
<text x="100" y="140" font-size="15" text-anchor="middle" fill="black">&lt;n=1&gt;</text>
</svg></p>
<p><svg version="1.1"
     baseProfile="full"
     width="200" height="150"
     xmlns="http://www.w3.org/2000/svg">
<rect width="100%" height="100%" fill="none" />
<line x1="95" x2="105" y1="130" y2="10" stroke="black" stroke-width="1" />
<line x1="10" x2="190" y1="60" y2="50" stroke="black" stroke-width="1" />
<text x="50" y="25" font-size="15" text-anchor="middle" fill="black">a</text>
<text x="150" y="25" font-size="15" text-anchor="middle" fill="black">b</text>
<text x="50" y="100" font-size="15" text-anchor="middle" fill="black">c</text>
<text x="150" y="100" font-size="15" text-anchor="middle" fill="black">d</text>
<text x="100" y="140" font-size="15" text-anchor="middle" fill="black">&lt;n=2&gt;</text>
</svg></p>
<h2 id="작은-사례-살펴보기"><a class="header" href="#작은-사례-살펴보기">작은 사례 살펴보기</a></h2>
<p>평면의 선의 개수 \( n \)으로 정의되는 영역을 \( L_n \)이라 할 때, \( L_0 = 1 \)이다.</p>
<p>\[ L_0 = 1 \]
\[ L_1 = 2 \]
\[ L_2 = 4 \]
\[ L_3 = 7 \]
\[ L_4 = 11 \]
\[ L_5 = 16 \]</p>
<h2 id="규모를-확장해보기"><a class="header" href="#규모를-확장해보기">규모를 확장해보기</a></h2>
<p>\( L_n = 2^n \)이라고 생각할 수 있지만, \( L_3 = 7 \)이므로 공식은 성립하지 않는다. 새로 놓일 직선이 기존에 놓인 다른 모든 직선을 가로질러 간다면, 아래와 같은 공식이 성립된다.</p>
<p>\[ L_0 = 1 \]
\[ L_n = L_{n-1} + n, n &gt; 0 \]</p>
<p>\( n \) 번째 선이 분할하는 기존 영역이 \( k \) 개이면, 영역의 수는 \( k \) 만큼 증가한다. \( n \) 번째 선은 최대 \( n-1 \) 개의 선과 최대 \( n-1 \) 개의 점에서 만난다.</p>
<p>이는 기존에 구한 1 ~ 3의 값과도 일치한다. 점화식을 풀어보면 1부터 n까지의 수를 더하는 것을 관찰할 수 있다. 그렇다면 아래와 같이 쓸 수 있다.</p>
<p>\[ L_5 = L_0 + ( 1 + 2 + 3 + 4 + 5 ) \]
\[ L_{10} = L_0 + ( 1 + 2 + 3 + ... + 9 + 10 ) \]</p>
<p>좀 더 일반적으료 표현하면, 아래와 같은 공식으로 풀 수 있다.</p>
<p>\[ L_n = L_0 + ( 1 + 2 + 3 + ... + (n-1) + n) \]
\[ L_n = L_0 + \frac{n (n + 1)}{2}  \]
\[ L_n = 1 + \frac{n (n + 1)}{2}  \]</p>
<h3 id="닫힌-형식"><a class="header" href="#닫힌-형식">닫힌 형식</a></h3>
<p>점화식이 아닌, 명시적인 표준연산방식으로 계산할 수 있는 형식</p>
<ul>
<li>닫힌 형식의 해는 유한하다.</li>
<li>닫힌 형식은 간단하다.</li>
<li>닫힌 형식의 해가 없는 점화식도 존재한다.</li>
</ul>
<h2 id="13-요세푸스-문제"><a class="header" href="#13-요세푸스-문제">1.3. 요세푸스 문제</a></h2>
<blockquote>
<p>1에서 \( n \)까지의 번호가 매겨진 \( n \)명의 사람이 원을 형성하며, 오직 한 사람이 남을 때까지 매 <strong>두 번째</strong> 사람이 죽는다.</p>
</blockquote>
<p><svg version="1.1"
     baseProfile="full"
     width="200" height="210"
     xmlns="http://www.w3.org/2000/svg">
<circle cx="100" cy="100" r="50" fill="transparent" stroke="black" stroke-width="1" />
<line x1="100" x2="100" y1="55" y2="85" stroke="black" stroke-width="1" />
<line x1="100" x2="90" y1="55" y2="65" stroke="black" stroke-width="1" />
<line x1="100" x2="110" y1="55" y2="65" stroke="black" stroke-width="1" />
<text x="100" y="40" font-size="12" text-anchor="middle" fill="black">1</text>
<text x="40" y="100" font-size="12" text-anchor="middle" fill="black">4</text>
<text x="160" y="100" font-size="12" text-anchor="middle" fill="black">2</text>
<text x="100" y="162" font-size="12" text-anchor="middle" fill="black">3</text>
<text x="100" y="200" font-size="12" text-anchor="middle" fill="black">&lt;n=4&gt;</text>
<text x="100" y="100" font-size="12" text-anchor="middle" fill="black">1부터 시작</text>
</svg></p>
<h3 id="작은-사례"><a class="header" href="#작은-사례">작은 사례</a></h3>
<p>1부터 \( n \)까지의 번호가 매겨진 사람들이 둘러앉아 1부터 시작할 때, 마지막까지 남은 사람의 번호를 \( J_n \)이라고 하자.</p>
<p>\[ J_1 = 1 \]
\[ J_2 = 1 \]
\[ J_3 = 3 \]
\[ J_4 = 1 \]
\[ J_5 = 3 \]</p>
<h2 id="확장해보기"><a class="header" href="#확장해보기">확장해보기</a></h2>
<p>작은 사례를 관찰하면 값에 어떤 규칙이 있음을 알 수 있다. 아래의 표를 보자.</p>
<table><thead><tr><th>\(n\)</th><th>\(n+1\)</th><th>\(n+2\)</th><th>...</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><em>1</em></td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>2</em></td><td>1</td><td>3</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>4</em></td><td>1</td><td>3</td><td>5</td><td>7</td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>8</em></td><td>1</td><td>3</td><td>5</td><td>7</td><td>9</td><td>11</td><td>13</td><td>15</td></tr>
</tbody></table>
<p>2의 지수를 기준으로 \(n\)이 증가할 때마다 2를 더한 값이 반복된다.</p>
<p>위 결과 값에 모두 1을 더해주면 아래와 같이 2의 배수임을 확인할 수 있다.</p>
<table><thead><tr><th>\(n\)</th><th>\(n+1\)</th><th>\(n+2\)</th><th>...</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><em>1</em></td><td>2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>2</em></td><td>2</td><td>4</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>4</em></td><td>2</td><td>4</td><td>6</td><td>8</td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>8</em></td><td>2</td><td>4</td><td>6</td><td>8</td><td>10</td><td>12</td><td>14</td><td>16</td></tr>
</tbody></table>
<p>그리고 2를 나누면 1씩 증가하는 순열이 된다.</p>
<table><thead><tr><th>\(n\)</th><th>\(n+1\)</th><th>\(n+2\)</th><th>...</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><em>1</em></td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>2</em></td><td>1</td><td>2</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>4</em></td><td>1</td><td>2</td><td>3</td><td>4</td><td></td><td></td><td></td><td></td></tr>
<tr><td><em>8</em></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr>
</tbody></table>
<p>이를 수식으로 표현하면 아래와 같이 나타날 수 있을 것이다.</p>
<p>\[ J_n = 2(n-m) + 1, m = n보다 작거나 같은 2의 지수 \]</p>
<p>\(m\)은 n의 구간마다 값이 달라지기 때문에 아래 코드와 같이 따로 함수를 만들었다.</p>
<pre><code class="language-js">function max_of_n(n) {
    var x = 0;
    while(n &gt;&gt; ++x) {
    }
    return Math.pow(2, --x);
}

function j(n) {
    return 2*(n-max_of_n(n)) + 1;
}

console.log(j(1));
console.log(j(2));
console.log(j(3));
console.log(j(4));
console.log(j(5));
console.log(j(6));
console.log(j(7));
console.log(j(8));
console.log(j(9));
console.log(j(16));
console.log(j(15));
</code></pre>
<p>패턴을 기반으로 점화식의 해를 찾았는데, 책에선 점화식을 정의하는 부분도 있었다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="오브젝트---조영호"><a class="header" href="#오브젝트---조영호">오브젝트 - 조영호</a></h1>
<ul>
<li>도서정보: <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=193681076">오브젝트 - 알라딘</a></li>
</ul>
<h2 id="패러다임"><a class="header" href="#패러다임">패러다임?</a></h2>
<ul>
<li>모델, 패턴, 예를 의미하는 그리스어 파라데이그마(paradeigma)에서 유래</li>
<li>과거엔 <em>표준적인 모델을 따르거나 모방하는 상황을 가리키는 제한적인 상황</em>에서 사용했음</li>
<li>현대엔 <em>한 시대의 사회 전체가 공유하는 이론이나 방법 등의 체계</em>를 의미함</li>
</ul>
<h2 id="패러다임-전환"><a class="header" href="#패러다임-전환">패러다임 전환?</a></h2>
<p>과거의 패러다임이 새로운 패러다임에 의해 대체됨으로써 방향과 성격이 변하는 것을 의미함.</p>
<ul>
<li>예시: 천동설 → 지동설</li>
</ul>
<h2 id="프로그래밍에서의-패러다임"><a class="header" href="#프로그래밍에서의-패러다임">프로그래밍에서의 패러다임</a></h2>
<ul>
<li><code>프로그래밍 패러다임</code>이란 용어를 처음 사용한건 <a href="https://ko.wikipedia.org/wiki/%EB%A1%9C%EB%B2%84%ED%8A%B8_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C">로버트 플로이드</a></li>
</ul>
<blockquote>
<p>특정 시대의 어느 성숙한 개발자 공동체에 의해 수용된 프로그래밍 방법과 문제 해결 방법,일프로그래밍 스타일</p>
</blockquote>
<ul>
<li>
<p>어떤 프로그래밍 패러다임을 사용하느냐에 따라 해결해야할 문제를 바라보는 방식과 프로그램 작성방법이 달라짐</p>
</li>
<li>
<p>개발자 공동체가 동일한 프로그램링 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지함</p>
</li>
<li>
<p>프로그래밍 패러다임을 교육시킴으로써 동일한 규칙과 방법을 공유하는 개발자로 성장할 수 있도록 준비시킴</p>
</li>
<li>
<p>프로그래밍 언어와 프로그래밍 패러다임은 분리할 수 없음</p>
<ul>
<li>C언어는 절차형 패러다임</li>
<li>Java는 객체지향 패러다임</li>
<li>LISP는 함수형 패러다임</li>
</ul>
</li>
</ul>
<h2 id="프로그래밍-패러다임과-쿤의-패러다임이-다른점"><a class="header" href="#프로그래밍-패러다임과-쿤의-패러다임이-다른점">프로그래밍 패러다임과 쿤의 패러다임이 다른점</a></h2>
<h3 id="프로그램-패러다임은-상이한-패러다임이-공존할-수-있다"><a class="header" href="#프로그램-패러다임은-상이한-패러다임이-공존할-수-있다">프로그램 패러다임은 상이한 패러다임이 공존할 수 있다.</a></h3>
<ul>
<li>절차형 패러다임과 객체지향 패러다임을 접목한 C++</li>
<li>함수형 패러다임과 객체지향 패러다임을 접목한 Scala</li>
</ul>
<p>→ 이러한 언어를 다중패러다임 언어라고 부름</p>
<h3 id="프로그래밍-패러다임은-비교-가능하다"><a class="header" href="#프로그래밍-패러다임은-비교-가능하다">프로그래밍 패러다임은 비교 가능하다.</a></h3>
<ul>
<li>프로그래밍 패러다임은 기존 개념의 단점을 보완해서 새로운 패러다임이 생겨난다.
<ul>
<li>절차형 패러다임을 보완한 객체지향 패러다임</li>
</ul>
</li>
<li>기존 패러다임을 폐기시키는 혁명적인 과정을 거치지 않는다. 오히려 <strong>발전적</strong>이다.</li>
<li>다른 프로그래밍 패러다임을 배우는 것은 도움이 된다.</li>
</ul>
<blockquote>
<p>No silver Bullet.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-_-객체-설계"><a class="header" href="#01-_-객체-설계">01 _ 객체, 설계</a></h1>
<blockquote>
<p>소프트웨어 모듈의 목적</p>
<ol>
<li>실행 중에 제대로 동작한다.</li>
<li>변경을 위해 존재한다.</li>
<li>코드를 읽는 사람과 의사소통 할 수 있어야 한다.
- 클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천방법 로버트 마틴</li>
</ol>
</blockquote>
<h2 id="03-설계-개선하기"><a class="header" href="#03-설계-개선하기">03 설계 개선하기</a></h2>
<ul>
<li>
<p>CQRS? 명령/질의 분리</p>
<ul>
<li><code>sellTo()</code></li>
</ul>
</li>
<li>
<p>코드 변경 용이</p>
</li>
</ul>
<p>결합도와 자율성의 트레이드오프: 이건 결정하기 나름</p>
<p>시그니쳐가 변경된다면/.... 그것은 지옥</p>
<ul>
<li>무생물도 살아있는 것처럼 대한다.</li>
</ul>
<p><code>Bag</code>, <code>TicketOffice</code>의 사례
미녀와 야수의 '주전자' 처럼</p>
<p>Encapsulation의 의미가 모호한 이유
감추면 다른 시그니쳐가 필요한데 사실 그렇게 코딩하는걸 못봄
모든게 getter &amp; setter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-객체지향-프로그래밍"><a class="header" href="#2-객체지향-프로그래밍">2. 객체지향 프로그래밍</a></h1>
<h2 id="21-영화예매-프로그래밍"><a class="header" href="#21-영화예매-프로그래밍">2.1. 영화예매 프로그래밍</a></h2>
<p>→ skip</p>
<h2 id="22-객체지향-프로그래밍을-향해"><a class="header" href="#22-객체지향-프로그래밍을-향해">2.2. 객체지향 프로그래밍을 향해</a></h2>
<h3 id="협력-객체-클래스"><a class="header" href="#협력-객체-클래스">협력, 객체, 클래스</a></h3>
<blockquote>
<p>객체지향 프로그램을 작성할 때 가장 먼저 고려하는 것은 무엇인가? C++， 자비 루비， C#과 같이 클래스 기반의 객체지향 언어에 익숙한 사람이리면 가장 먼저 어떤 클래스(class)가 필요한지 고민할 것이다. 대부분의 사람들은 클래스를 결정한 후에 클래스에 어 떤 속성과 메서드가 펼요한지 고민한다.
안타깝게도 이것은 객체지향의 본질과는 거리가 멀다. 객체지향은 말 그대로 객체를 지향하는 것이다. - p. 40</p>
</blockquote>
<p>→ 클래스와 객체의 차이점은 뭘까? 보통 둘을 동일한 의미로 사용하고 있지 않나?</p>
<p>→ <a href="https://docs.oracle.com/javase/tutorial/java/concepts/object.html">Class and Object definition in Java</a></p>
<ul>
<li><code>object</code>: An object stores its state in fields (variables in some programming languages) and exposes its behavior through methods (functions in some programming languages).</li>
<li><code>class</code>: A class is the blueprint from which individual objects are created.</li>
</ul>
<p>객체에 초점을 맞추라</p>
<ol>
<li>클래스보단 어떤 객체가 필요한지 고민하라.
<ul>
<li>클래스는 특정 상태와 행동을 공유하는 객체를 추상화 한 것</li>
<li>클래스를 정의하려면 특정 객체의 상태와 행동을 먼저 정의해야 함</li>
</ul>
</li>
<li>객체는 기능 구현을 위해 협력하는 공동체의 일원으로 봐야함
<ul>
<li>객체는 다른 객체와 상호작용하는 협력적인 존재임</li>
<li>공동체의 일원으로 바라보면 설계가 유연해지고 확장 가능해진다 ??</li>
<li>객체의 윤곽이 잡히면 클래스를 구현하라 ??</li>
</ul>
</li>
</ol>
<p>→ 클래스를 정의하는 것이 객체 정의와 다른 점이 뭘까?</p>
<h3 id="도메인의-구조를-따르는-프로그램-구조"><a class="header" href="#도메인의-구조를-따르는-프로그램-구조">도메인의 구조를 따르는 프로그램 구조</a></h3>
<blockquote>
<p>도메인: 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야(지식)</p>
</blockquote>
<ul>
<li>객체지향 패러다임은 프로그램의 전 라이프사이클에서 <strong>객체</strong> 라는 동일한 추상화 기법을 사용할 수 있다.</li>
<li>클래스의 이름은 도메인의 이름과 유사하게 명명해야 한다.
<ul>
<li>프로그램의 구조를 이해하고 예상하기 쉽다.</li>
</ul>
</li>
</ul>
<h3 id="클래스-구현하기"><a class="header" href="#클래스-구현하기">클래스 구현하기</a></h3>
<ul>
<li>인스턴스 가시성: 변수는 <code>private</code>으로, 메서드는 <code>public</code> 으로</li>
<li>클래스의 경계 구분짓기
<ul>
<li>객체의 자율성을 보장</li>
<li>프로그래머에게 구현의 자유를 제공: 인터페이스는 지키되 구현은 프로그래머의 판단 하에!</li>
</ul>
</li>
</ul>
<p><strong>자율적인 객체</strong></p>
<ol>
<li>객체는 <strong>상태(state)</strong> 와 <strong>행동(behavior)</strong> 을 가지는 복합적인 존재</li>
<li>객체가 스스로 판단하고 행동하는 <strong>자율적인 존재</strong></li>
</ol>
<ul>
<li>절차지향 패러다임에선 데이터와 기능을 엮어 프로그램을 구성
<ul>
<li>데이터와 기능은 하나의 단위로 묶이지 않는다.</li>
<li>객체와는 다르다. 데이터와 기능은 개별적인 존재</li>
</ul>
</li>
<li>객체지향은 데이터와 기능을 <strong>객체</strong> 라는 단위로 묶는다 → <strong>캡슐화</strong></li>
<li>객체지향 패러다임의 언어는 캡슐화에 더 나은 기능을 제공한다. (e.g. Java의 접근 수정자)</li>
<li>접근 통제의 이유: 객체를 자율적인 존재로 만들기 위해
<ul>
<li>객체 스스로 상태를 관리하기 위해 외부 간섭을 최소화(외부에서 임의로 상태변경 할 수 없게)</li>
</ul>
</li>
<li>캡슐화는 객체를 두 부분으로 나눈다.
<ul>
<li>Public Interface: 외부에서 접근 가능한 부분</li>
<li>Implementation: 내부에서만 접근 가능</li>
<li>인터페이스와 구현의 분리 (Seperation of Interface and Implementation)</li>
</ul>
</li>
</ul>
<p>→ Spring MVC 패턴에 따라 정의된 객체는 저자가 말한 객체라고 볼 수 있을까?</p>
<ul>
<li>상태가 없다. 있으면 안된다.</li>
</ul>
<p><strong>프로그래머의 자유</strong></p>
<ul>
<li>프로그래머의 역할을 둘로 나눔
<ul>
<li>클래스 작성자: 새로운 데이터 타입을 프로그램에 추가
<ul>
<li>클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 감춘다</li>
</ul>
</li>
<li>클라이언트 프로그래머: 클래스 작성자가 추가한 데이터를 사용
<ul>
<li>필요한 클래스들을 엮어 애플리케이션을 빠르게 구축</li>
</ul>
</li>
</ul>
</li>
<li>왜 숨길까?
<ul>
<li>클라이언트 프로그래머에 대한 영향도를 신경쓰지 않아도 된다. (영향이 없으니까)</li>
<li>숨겼으니 내부 구현을 마음대로 변경할 수 있다. (퍼블릭 인터페이스만 그대로 동작한다면!)</li>
<li>→ 구현의 은닉 (Implementation Hiding)</li>
</ul>
</li>
</ul>
<p>→ Java 프로그래머는 Logback의 내부 구현을 알지 못해도 사용할 수 있다. 스펙(인터페이스)대로 동작한다고 기대하고 필요한 인터페이스가 잘 동작하면 된다.</p>
<ul>
<li>설계는 변경을 관리하기 위해 필요하다.</li>
</ul>
<h3 id="협력하는-객체들의-공동체"><a class="header" href="#협력하는-객체들의-공동체">협력하는 객체들의 공동체</a></h3>
<ul>
<li>협력: 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용</li>
</ul>
<h3 id="협력에-관한-짧은-이야기"><a class="header" href="#협력에-관한-짧은-이야기">협력에 관한 짧은 이야기</a></h3>
<ul>
<li>객체는 다른 객체의 공개된 행동(public interface)을 수행하도록 <strong>요청</strong> 한다.
<ul>
<li>메시지를 전송 (send a message)</li>
</ul>
</li>
<li>요청받은 객체는 자율적으로 요청을 처리한 후 <strong>응답</strong> 한다.
<ul>
<li>메시지를 수신 (receive a message)</li>
</ul>
</li>
<li>메서드: 수신한 메시지를 처리하기 위한 객체 자신의 방법</li>
<li>메시지와 메서드를 구분하는 것은 중요하다. 왜??
<ul>
<li>메시지와 메서드의 구분에서 <strong>다형성</strong> 이 출발한다.</li>
<li>동적타입 언어에선 시그니쳐가 다른 메서드를 통해서 메시지에 응답할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="23-할인요금-구하기"><a class="header" href="#23-할인요금-구하기">2.3. 할인요금 구하기</a></h2>
<h3 id="할인요금-계산을-위한-협력-시작하기"><a class="header" href="#할인요금-계산을-위한-협력-시작하기">할인요금 계산을 위한 협력 시작하기</a></h3>
<ul>
<li><code>calculateMovieFee()</code> 의 이상한 점
<ul>
<li>할인 정책(<code>discountPolicy</code>)을 결정하는 코드가 없다.</li>
</ul>
</li>
<li>상속(Inheritance)과 다형성(Polymorphism), 그리고 추상화(Abstraction)</li>
</ul>
<h3 id="할인-정책과-할인-조건"><a class="header" href="#할인-정책과-할인-조건">할인 정책과 할인 조건</a></h3>
<ul>
<li>추상 클래스 <code>DiscountPolicy</code>는 할인 여부/요금 계산의 전체 프로세스를 정의하지만 요금 계산하는 부분은 추상 메서드인 <code>getDiscountAmount()</code>에게 위임 → <a href="https://github.com/harkony/design-pattern/tree/master/design-pattern/20200322/template-method">Template Method 패턴</a></li>
</ul>
<h3 id="할인-정책-구성하기"><a class="header" href="#할인-정책-구성하기">할인 정책 구성하기</a></h3>
<ul>
<li>클래스 생성자로 도메인의 제약을 구현
<ul>
<li>올바른 상태를 가진 객체 생성을 보장한다</li>
</ul>
</li>
</ul>
<p>→ Dependency Injection 얘기는 Out of Scope?</p>
<h2 id="24-상속과-다형성"><a class="header" href="#24-상속과-다형성">2.4. 상속과 다형성</a></h2>
<h3 id="컴파일-시간-의존성과-실행-시간-의존성"><a class="header" href="#컴파일-시간-의존성과-실행-시간-의존성">컴파일 시간 의존성과 실행 시간 의존성</a></h3>
<ul>
<li>
<p><code>Movie</code> 클래스는 <code>DiscountPolicy</code> 추상클래스에 의존하고 있다.</p>
</li>
<li>
<p>실제 필요한 클래스는 구현체</p>
</li>
<li>
<p>실행(runtime) 시에 구현체 인스턴스에 의존해야 함</p>
</li>
<li>
<p>런타임에 협력가능한 이유?</p>
</li>
<li>
<p>코드 의존성(compile time)과 실행시점 의존성(runtime)은 다를 수 있다. → 객체지향의 특성</p>
<ul>
<li>유연하고 쉽게 재사용 가능</li>
<li>코드를 이해하기 어려워진다.
<ul>
<li>→ 코드를 이해하기 위해 구현체를 헤맨적이 없는지?</li>
</ul>
</li>
</ul>
</li>
<li>
<p>설계의 trade off</p>
<ul>
<li>설계가 유연해지면 코드 디버깅이 어려워 진다.</li>
<li>유연성이 억제되면 재사용성과 확장성이 낮아진다.</li>
</ul>
</li>
</ul>
<h3 id="차이에-의한-프로그래밍"><a class="header" href="#차이에-의한-프로그래밍">차이에 의한 프로그래밍</a></h3>
<ul>
<li>상속: 코드를 재상용하기 위해 널리 사용되는 방법
<ul>
<li>관계 설정으로 부모 클래스의 속성과 행동을 포함시킬 수 있다.</li>
<li>부모 클래스의 구현은 공유하되 다른 행동을 정의할 수 있다. (overriding)</li>
</ul>
</li>
</ul>
<p>→ 차이에 의한 프로그래밍 (programming by difference)</p>
<h3 id="상속과-인터페이스"><a class="header" href="#상속과-인터페이스">상속과 인터페이스</a></h3>
<ul>
<li>상속의 장점: 부모의 모든 인터페이스를 물려받을 수 있다.
<ul>
<li>사람들은 메서드나 프로퍼티 재사용 때문이라는데?</li>
</ul>
</li>
<li>인터페이스는 객체가 이해할 수 있는 메시지의 목록</li>
<li>자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있다.
<ul>
<li>동일한 타입으로 간주할 수 있다!!!</li>
<li>생성자 인자가 추상 클래스임에도 런타임에서 구현체를 전달할 수 있는 이유 (Upcasting)</li>
</ul>
</li>
</ul>
<h3 id="다형성"><a class="header" href="#다형성">다형성</a></h3>
<ul>
<li>메시지와 메서드는 다르다</li>
<li>요청자는 <code>calculateDiscountAmount</code> 메시지를 보내지만 연결된 객체에 따라 실행하는 메서드는 달라진다.
<ul>
<li>추상클래스와 구현 클래스의 <code>calculateDiscountAmount</code> 메서드는 모두 다르다!</li>
</ul>
</li>
<li>다형성
<ul>
<li>동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.</li>
<li>컴파일 타임과 런타임의 의존성이 다르다는 것에 기반한다.</li>
<li>다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다. → 인터페이스가 동일하다</li>
<li>메시지와 메서드를 실행시점에 바인딩 → Lazy Binding, Dynamic Binding</li>
<li>클래스 상속이 다형성의 전부가 아니다.</li>
</ul>
</li>
<li>구현 상속과 인터페이스 상속
<ul>
<li>구현 상속: 코드 재사용을 위해</li>
<li>인터페이스 상속: 다형적인 협력을 위해</li>
<li>구현 상속은 변경에 취약한 코드를 생성한다. → 가격변경이력...</li>
</ul>
</li>
</ul>
<h3 id="인터페이스와-다형성"><a class="header" href="#인터페이스와-다형성">인터페이스와 다형성</a></h3>
<ul>
<li>순수하게 인터페이스만 공유하고 싶을 때? Java는 <code>interface</code>를 사용</li>
</ul>
<h2 id="25-추상화와-유연성"><a class="header" href="#25-추상화와-유연성">2.5. 추상화와 유연성</a></h2>
<h3 id="추상화의-힘"><a class="header" href="#추상화의-힘">추상화의 힘</a></h3>
<ul>
<li>인터페이스에 초점을 맞춘다</li>
<li>추상화 계층만 보면 요구사항을 높은 수준에서 서술할 수 있다.</li>
<li>설계가 유연해진다.</li>
</ul>
<h3 id="유연한-설계"><a class="header" href="#유연한-설계">유연한 설계</a></h3>
<ul>
<li>예외케이스를 최소화하고 일관성을 유지할 수 있는 방법을 고려하라</li>
<li>유연성이 필요한 곳에 추상화를사용하라.</li>
</ul>
<h3 id="추상-클래스와-인터페이스-트레이드오프"><a class="header" href="#추상-클래스와-인터페이스-트레이드오프">추상 클래스와 인터페이스 트레이드오프</a></h3>
<ul>
<li>설계의 트레이드 오프를 항상 염두해야 한다.</li>
</ul>
<h3 id="코드의-재사용"><a class="header" href="#코드의-재사용">코드의 재사용</a></h3>
<ul>
<li>상속과 합성</li>
</ul>
<h3 id="상속-1"><a class="header" href="#상속-1">상속</a></h3>
<ul>
<li>코드를 재사용할 수 있다.</li>
<li>캡슐화를 위반한다.</li>
<li>설계 유연성이 떨어진다. (변경이 어려워진다.)</li>
</ul>
<h3 id="합성"><a class="header" href="#합성">합성</a></h3>
<ul>
<li>인터페이스를 통해 약하게 결합된다.</li>
</ul>
<h1 id="질문거리"><a class="header" href="#질문거리">질문거리</a></h1>
<ul>
<li>클래스와 객체의 차이점은 뭘까? 보통 둘을 동일한 의미로 사용하고 있지 않나?</li>
<li>클래스를 정의하는 것이 객체 정의와 다른 점이 뭘까?</li>
<li>Spring MVC 패턴으로 정의된 인스턴스는 저자가 말한 객체라고 볼 수 있을까?
<ul>
<li>내부 상태가 없다. (있으면 안된다)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-역할-책임-협력"><a class="header" href="#3-역할-책임-협력">3. 역할, 책임, 협력</a></h1>
<ul>
<li>객체지향 패러다임의 핵심
<ul>
<li>역할(role)</li>
<li>책임(responsibility)</li>
<li>협력(collaboration)</li>
</ul>
</li>
<li>객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것</li>
<li><strong>협력</strong>을 구성하기 위해 적절한 객체를 찾고 적절한 <strong>책임</strong>을 할당</li>
<li>클래스와 상속은 구현 메커니즘일뿐</li>
<li>구현에 치우치면 변경이 어렵고 유연하지 못한 코드를 낳는다</li>
</ul>
<h2 id="31-협력"><a class="header" href="#31-협력">3.1. 협력</a></h2>
<h3 id="영화예매시스템-돌아보기"><a class="header" href="#영화예매시스템-돌아보기">영화예매시스템 돌아보기</a></h3>
<ul>
<li>객체지향 애플리케이션의 제어 흐름은 다양한 객체들에 분배되어 있음</li>
<li><strong>협력</strong>: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용</li>
<li><strong>책임</strong>: 객체가 협력에 참여하기 위해 수행하는 로직</li>
<li><strong>역할</strong>: 객체들이 협력 안에서 수행하는 책임들의 모음</li>
</ul>
<h3 id="협력"><a class="header" href="#협력">협력</a></h3>
<ul>
<li>객체는 사회적인 존재</li>
<li>협력은 한 객체가 다른 객체에게 도움을 요청할 때 시작된다</li>
<li><strong>메시지 전송</strong>(send a message)은 객체간의 유일한 커뮤니케이션 수단
<ul>
<li>객체는 다른 객체의 세부 구현에 직접 접근할 수 없다</li>
<li>메시지 수신 객체는 <strong>메서드</strong>를 실행해 요청에 응답 (스스로 메시지를 처리)</li>
</ul>
</li>
<li><strong>캡슐화</strong>: 객체를 자율적으로 만드는 기본적인 방법
<ul>
<li>내 상태는 내가 알아서 한다</li>
<li>변경하기 쉬워진다</li>
</ul>
</li>
</ul>
<h3 id="협력이-설계를-위한-문맥을-결정한다"><a class="header" href="#협력이-설계를-위한-문맥을-결정한다">협력이 설계를 위한 문맥을 결정한다</a></h3>
<ul>
<li>애플리케이션에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다. (SRP)
<ul>
<li>객체가 협력에 참여하고 있기 때문</li>
<li>협력에 필요한 적절한 행동(상태)를 보유했기 때문</li>
</ul>
</li>
<li>협력은 객체가 필요한 이유와 객체의 행동 동기를 제공</li>
<li>협력은 객체의 행동을 결정, 행동은 객체의 상태를 결정</li>
<li>자율적인 객체는 행동에 필요한 상태를 가지고 있어야 한다.</li>
</ul>
<p>→ 데이터 관점에서 설계하면 자율적인 객체를 설계하기 힘든 것 같다.</p>
<ul>
<li>협력은 객체 설계에 필요한 문맥(context)을 제공</li>
</ul>
<h2 id="32-책임"><a class="header" href="#32-책임">3.2. 책임</a></h2>
<h3 id="책임이란-무엇인가"><a class="header" href="#책임이란-무엇인가">책임이란 무엇인가</a></h3>
<ul>
<li>협력이 갖춰지면 협력에 필요한 행동을 수행할 객체를 찾아야 한다.</li>
<li>책임: 협력하는 객체의 행동
<ul>
<li>객체에 의해 정의되는 응집도 있는 행위의 집합</li>
<li>무엇을 알고있는가? 무엇을 할 수 있는가?</li>
</ul>
</li>
<li>doing
<ul>
<li>객체 생성, 계산 수행 (constructor, method)</li>
<li>다른 객체의 행동을 시작 (send a message?)</li>
<li>다른 객체의 활동을 제어, 조절</li>
</ul>
</li>
<li>knowing
<ul>
<li>사적인 정보에 대해 아는 것 (state?)</li>
<li>관련된 객체에 관해 아는 것 (dependency?)</li>
<li>자신이 유도하거나 계산할 수 있는 것에 관해 아는 것 (state?)</li>
</ul>
</li>
<li>영화시스템의 책임 예
<ul>
<li>Screening: 영화 예매 (doing), 상영할 영화를 기억 (knowing)</li>
<li>Movie: 요금 계산 (doing), 가격과 할인정책을 기억 (knowing)</li>
</ul>
</li>
<li>아는 것과 하는 것은 밀접하게 연관되어 있음</li>
<li>책임을 적절하게 할당하는 것은 객체지향 설계의 핵심!!</li>
</ul>
<p>→ CRC 카드의 첫 번째 C도 Class였으니 워드 커닝햄도 클래스 기반 설계에 초점을 맞춘게 아닐까? 적어도 처음엔</p>
<h3 id="책임-할당"><a class="header" href="#책임-할당">책임 할당</a></h3>
<ul>
<li>자율적인 객체를 만드려면 필요한 정보를 가장 잘 알고 있는 전문가에게 책임을 할당해야 한다. → 정보 전문가 패턴(Information Expert pattern)</li>
<li>책임을 할당하는 방법
<ol>
<li>시스템이 사용자에게 제공하는 기능을 하나의 책임으로 바라본다</li>
<li>시스템의 책임을 완료하는데 필요한 더 작은 책임을 찾는다. (책임 쪼개기)</li>
<li>객체에게 책임을 할당</li>
<li>2~3 반복</li>
</ol>
</li>
</ul>
<h3 id="책임-주도-설계"><a class="header" href="#책임-주도-설계">책임 주도 설계</a></h3>
<ul>
<li>책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법</li>
<li>구현이 아닌 책임에 집중할 수 있다</li>
</ul>
<h3 id="메시지가-객체를-결정한다"><a class="header" href="#메시지가-객체를-결정한다">메시지가 객체를 결정한다</a></h3>
<ul>
<li>메시지를 식별한 후에 메시지를 처리할 객체를 선택한다
<ul>
<li>객체가 메시지를 선택하지 않는다</li>
</ul>
</li>
<li>객체는 최소한의 인터페이스만 가질 수 있다.</li>
<li>추상적인 인터페이스를 가질 수 있다.</li>
</ul>
<p>→ 메시지 처리라는 필요에 의해 설계하게 되니 자연스럽게  SRP, ISP를 지킬수 있겠다.</p>
<p>→ 내가 경험했던 데이터 정의 &gt;&gt; 구현은 이렇게 생각하기가 어렵게 느껴진다.</p>
<h3 id="행동이-상태를-결정한다"><a class="header" href="#행동이-상태를-결정한다">행동이 상태를 결정한다</a></h3>
<ul>
<li>객체는 협력에 참여하기 위해 존재한다</li>
<li>객체는 다른 객체에게 제공하는 <strong>행동</strong>이 중요한다</li>
</ul>
<p>→ getter를 남발하지 말고 직접 처리하자</p>
<ul>
<li>데이터 주도 설계를 지양하자</li>
<li>협력이라는 문맥 안에서 객체를 생각해야 한다</li>
<li>협력에 초점을 맞춰야 응집도가 높고 결합도가 낮은 객체를 설계할 수 있다</li>
<li>상태는 행동에 필요한 재료일뿐</li>
<li>협력이 객체의 행동을 결정, 행동이 상태를 결정, 행동이 객체의 책임</li>
</ul>
<h2 id="23-역할"><a class="header" href="#23-역할">2.3. 역할</a></h2>
<h3 id="역할과-협력"><a class="header" href="#역할과-협력">역할과 협력</a></h3>
<ul>
<li>객체의 목적? 협력 안에서 객체가 맡게 되는 책임의 집합 → <strong>역할</strong>
<ul>
<li>객체의 목적이 곧 역할</li>
</ul>
</li>
</ul>
<ol>
<li>적절한 역할을 찾고</li>
<li>역할을 수행할 객체를 선택</li>
</ol>
<h3 id="유연하고-재사용-가능한-협력"><a class="header" href="#유연하고-재사용-가능한-협력">유연하고 재사용 가능한 협력</a></h3>
<ul>
<li>역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있다</li>
</ul>
<p>→ 역할은 인터페이스??</p>
<blockquote>
<p>역할은 다른 것으로 교체할 수 있는 책임의 집합이다.</p>
</blockquote>
<ul>
<li>역할은 구체적인 객체를 포괄하는 <strong>추상화</strong></li>
<li>역할을 이용하면 불필요한 중복 코드를 제거할 수 있다. (추상화의 이점)</li>
<li>새로운 할인정책을 위해 협력을 추가할 필요가 없어짐 (이미 추상화했기 때문에)</li>
</ul>
<h3 id="객체-대-역할"><a class="header" href="#객체-대-역할">객체 대 역할</a></h3>
<ul>
<li>역할은 객체가 참여할 수 있는 일종의 <strong>슬롯</strong></li>
<li>한 종류의 객체만 존재하는데 역할(추상클래스/인터페이스)이 필요할까?
<ul>
<li>그럴 필요없다</li>
</ul>
</li>
<li>어떤게 역할이고 객체인지 뚜렷하게 드러나지 않음</li>
<li>특히 설계 초반에는 더더욱</li>
<li>설계 초반에는 책임과 협력을 탐색하는 것이 중요한 목표</li>
<li>책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리하자</li>
</ul>
<h3 id="역할과-추상화"><a class="header" href="#역할과-추상화">역할과 추상화</a></h3>
<ul>
<li>역할은 객체의 추상화</li>
<li>세부 사항에 억눌리지 않고 상위 수준의 정책을 쉽고 간단하게 표현할 수 있다</li>
<li>설계를 유연하게 만든다
<ul>
<li>역할은 슬롯</li>
<li>프레임워크나 디자인 패턴의 핵심 요소가 역할!!</li>
</ul>
</li>
</ul>
<h3 id="배우와-배역"><a class="header" href="#배우와-배역">배우와 배역</a></h3>
<ul>
<li>배우(객체) - 배역(역할)</li>
<li>역할은 협력 안에서의 일시적인 개념</li>
<li>객체는 다양한 역할을 가질 수 있다</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기록"><a class="header" href="#기록">기록</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2019년-기록"><a class="header" href="#2019년-기록">2019년 기록</a></h1>
<h2 id="책"><a class="header" href="#책">책</a></h2>
<ul>
<li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=27943790">밤이 선생이다 | 황현산</a></li>
<li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=27943790">함께 자라기 - 애자일로 가는 길 | 김창준</a></li>
<li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=140702246">구체수학 | 도널드 커누스·로널드 그레이엄·오렌 파타슈닉</a></li>
</ul>
<h2 id="영화-드라마-그외"><a class="header" href="#영화-드라마-그외">영화, 드라마, 그외</a></h2>
<ul>
<li><a href="http://www.cine21.com/movie/info/?movie_id=52291">스파이더맨 - 뉴 유니버스</a>: 약간 정신없긴 하지만 이만큼 재밌을 수 있을까?</li>
<li><a href="https://www.netflix.com/kr/title/70175633">루터</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2019년-16주차-til"><a class="header" href="#2019년-16주차-til">2019년 16주차 TIL</a></h1>
<h2 id="20190415"><a class="header" href="#20190415">2019/04/15</a></h2>
<p>도커 볼륨과 세션에 대해 알아보았다.</p>
<h3 id="type-커맨드-프롬프트-명렁어"><a class="header" href="#type-커맨드-프롬프트-명렁어">TYPE: 커맨드 프롬프트 명렁어</a></h3>
<p>윈도우즈 커맨드 프롬프트의 type 명령어는 리눅스 cat 명령어와 유사한 동작을 수행한다.</p>
<pre><code class="language-bash">&gt; type some.txt
## 텍스트 파일 출력
</code></pre>
<h2 id="20190416"><a class="header" href="#20190416">2019/04/16</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aws-summit-seoul-2019"><a class="header" href="#aws-summit-seoul-2019">AWS Summit Seoul 2019</a></h1>
<h2 id="타-게임사의-경험으로-본-aws-핵심-모범-사례-한방에-배우기"><a class="header" href="#타-게임사의-경험으로-본-aws-핵심-모범-사례-한방에-배우기">타 게임사의 경험으로 본 AWS 핵심 모범 사례 한방에 배우기</a></h2>
<ul>
<li>Tips for Cost Optimization
<ul>
<li>RI 구매방법 및 고려사항
<ul>
<li>RI: 예약 인스턴스</li>
<li>AWS에서 RI 최적 플랜 제공</li>
<li>AWS 비용 탐색기를 활용 (Cost Explorer)</li>
</ul>
</li>
</ul>
</li>
<li>Tips for Support case
<ul>
<li>호주 현지국인 엔지니어 대응 호주 현지시간 9-5</li>
</ul>
</li>
<li>인스턴스 강제 재시작 사례
<ul>
<li>원인: 노후화 장비 정비 등의 이유</li>
<li>인스턴스 다중화 ?@??!! 이건 하나마나한 소리가 아닌지...?</li>
</ul>
</li>
</ul>
<h2 id="aws-system-manager-parameter-store를-사용한-aws-구성-데이터-관리-기법"><a class="header" href="#aws-system-manager-parameter-store를-사용한-aws-구성-데이터-관리-기법">AWS System Manager: Parameter Store를 사용한 AWS 구성 데이터 관리 기법</a></h2>
<ul>
<li>
<p>정창훈, 당근마켓</p>
</li>
<li>
<p>Parameter store?</p>
<ul>
<li>AWS System manager - parameter store</li>
<li>EC2 서비스에서도 바로 접근 가능</li>
</ul>
</li>
<li>
<p>System manager</p>
<ul>
<li>특징
<ul>
<li>Resource groups:</li>
<li>Insight</li>
<li>Actions</li>
<li>Shared REsources</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Parameter store</p>
<ul>
<li>비밀번호나 구성 데이터 관리</li>
<li>중앙 집중식 저장/관리</li>
<li>버전관리: <code>aws ssm put-parameter ~~ --overwrite</code></li>
<li>암복호화: <code>--decryption</code></li>
</ul>
</li>
</ul>
<h2 id="스폰서-발표-세션--e커머스-통합운영-자동화-사례-및-보안강화-방안-삼성sds"><a class="header" href="#스폰서-발표-세션--e커머스-통합운영-자동화-사례-및-보안강화-방안-삼성sds">스폰서 발표 세션 | e커머스 통합운영 자동화 사례 및 보안강화 방안, 삼성SDS</a></h2>
<ul>
<li>SRE?</li>
</ul>
<h2 id="서버리스-아키텍처-패턴-및-로그-처리를-위한-파이프라인-구축기"><a class="header" href="#서버리스-아키텍처-패턴-및-로그-처리를-위한-파이프라인-구축기">서버리스 아키텍처 패턴 및 로그 처리를 위한 파이프라인 구축기</a></h2>
<ul>
<li>패턴2: 오퍼레이션 자동화
<ul>
<li>람다 리눅스 API</li>
<li>다양한 런타임 환경 지원: 심지어 코볼도 지원함</li>
<li>다양한 AWS 서비스와 연계</li>
<li>코드: 코드커밋, ...</li>
<li>DB: Dynamo, ...</li>
<li>///////////////////////////</li>
</ul>
</li>
<li>패턴3: 데이터레이크
<ul>
<li>S3가 데이터레이크의 중앙저장소 역할을 함</li>
</ul>
</li>
<li>패턴4: IOT 데이터 처리 패턴</li>
</ul>
<h2 id="aws-클라우드-핵심-서비스로-클라우드-기반-아키텍처-빠르게-구성하기"><a class="header" href="#aws-클라우드-핵심-서비스로-클라우드-기반-아키텍처-빠르게-구성하기">AWS 클라우드 핵심 서비스로 클라우드 기반 아키텍처 빠르게 구성하기</a></h2>
<ul>
<li>EC2 인스턴스 선택
<ul>
<li>사용유형을 고려한 인스턴스 선택</li>
<li>프로세서 및 아키텍쳐 선택 가능</li>
</ul>
</li>
<li>ELB
<ul>
<li>ALB(HTTP/S), NLB(TCP), Classic(Deprecated)</li>
</ul>
</li>
<li>Storage
<ul>
<li>Instance Store: 휘발성</li>
<li>EBS: Network로 마운트 (비용발생)
<ul>
<li>동일 가용영역 내 인스턴스에 Attach/detach</li>
<li>하나의 EC2에만 attach 가능</li>
<li>암호화</li>
<li>증분백업 -&gt; S3</li>
</ul>
</li>
<li>Block/File/Object type
<ul>
<li>S3: REST 통신 사용
<ul>
<li>리소스 당 5TB 제한</li>
<li>버킷/리소스(파일)단위로 접근제어 설정 가능</li>
<li>Athenaa를 사용해서 대화형 쿼리 서비스 사용 가능 -&gt; 파일 업로드 후 데이터 분석!</li>
<li>비용절감도구: S3 Intelligent Tiering</li>
<li>라이프사이클 관리정책을 적용하면 알아서 리소스의 저장소 유형을 변경</li>
<li>SFTP 서비스 제공</li>
</ul>
</li>
<li>EFS: 매니지드 NAS 서비스
<ul>
<li>On-premise 서버에서도 사용 가능</li>
<li>사용량에 따라 과금 / 초기 용량 산정이 없음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>VPC: 클라우드 VPN 서비스
<ul>
<li>시큐리티 그룹 체이닝: 특정 시큐리티 그룹을 통과한 요청에 대해 접근권한 설정 가능 ELB~WEB~API~DB</li>
</ul>
</li>
<li>DB
<ul>
<li>RDS
<ul>
<li>Read Replica 구성 가능</li>
<li>백업관리 -&gt; S3</li>
</ul>
</li>
</ul>
</li>
<li>Cloud Front</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ie-10-이하-환경에서의-테스트-환경-구성"><a class="header" href="#ie-10-이하-환경에서의-테스트-환경-구성">IE 10 이하 환경에서의 테스트 환경 구성</a></h1>
<p>MicroSoft는 IE 10 이하의 환경을 제공하는 Virtual Machine 제공한다.
IE 11의 에뮬레이션 기능은 원래 버전의 렌더링과 차이가 날 수 있기때문에 꼭 각 버전별 브라우져에서 확인해야 한다.</p>
<p>https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="미분류"><a class="header" href="#미분류">미분류</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim-인코딩-변환"><a class="header" href="#vim-인코딩-변환">VIM 인코딩 변환</a></h1>
<h2 id="enc"><a class="header" href="#enc"><code>++enc</code></a></h2>
<p>VIM에서 명령모드 진입 후 <code>e ++enc={인코딩 타입}</code>을 입력</p>
<h3 id="utf-8-방식으로-리로딩하는-경우"><a class="header" href="#utf-8-방식으로-리로딩하는-경우"><code>utf-8</code> 방식으로 리로딩하는 경우</a></h3>
<pre><code class="language-sh">:e ++enc=utf-8
</code></pre>
<h3 id="euc-kr-방식으로-리로딩하는-경우"><a class="header" href="#euc-kr-방식으로-리로딩하는-경우"><code>euc-kr</code> 방식으로 리로딩하는 경우</a></h3>
<pre><code class="language-sh">:e ++enc=euckr
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mtu-maximum-transmission-unit-최대전송단위"><a class="header" href="#mtu-maximum-transmission-unit-최대전송단위">MTU, Maximum Transmission Unit, 최대전송단위</a></h1>
<p>네트워크에서 프로토콜이 최대로 전송할 수 있는 데이터 단위를 말한다. MTU가 높을수록 효율적으로 커뮤니케이션 할 수 있다. 헤더같은 프로토콜 오버헤드는 동일하지만 더 많은 데이터를 전송할 수 있기 때문이다. </p>
<h2 id="mtu-조절-명령어"><a class="header" href="#mtu-조절-명령어">mtu 조절 명령어</a></h2>
<h3 id="windows-계열"><a class="header" href="#windows-계열">Windows 계열</a></h3>
<pre><code class="language-cmd">&gt; netsh interface ipv4 show interfaces
&gt; netsh interface ipv4 set subinterface &quot;네트워크장비인덱스&quot; mtu=200 store=persistent
</code></pre>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<pre><code class="language-bash">&gt; ifconfig # 네트워크 인터페이스 탐색
&gt; ifconfig 장비명 mtu 200
</code></pre>
<h2 id="참고자료-2"><a class="header" href="#참고자료-2">참고자료</a></h2>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EC%B5%9C%EB%8C%80_%EC%A0%84%EC%86%A1_%EB%8B%A8%EC%9C%84">최대전송단위</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim-cheat-sheet"><a class="header" href="#vim-cheat-sheet">VIM Cheat Sheet</a></h1>
<h2 id="동작"><a class="header" href="#동작">동작</a></h2>
<h3 id="이동"><a class="header" href="#이동">이동</a></h3>
<ul>
<li>기본이동(←↑↓→): <code>h, j, k, l</code></li>
<li>문장
<ul>
<li>시작: <code>^,0</code></li>
<li>끝: <code>$, shift + 0</code></li>
</ul>
</li>
<li>단어
<ul>
<li>다음 단어: <code>w</code></li>
<li>다음 단어 끝: <code>e</code></li>
<li>이전 단어: <code>b</code></li>
</ul>
</li>
<li>페이지
<ul>
<li>다음 페이지: <code>ctrl + f</code></li>
<li>이전 페이지: <code>ctrl + b</code></li>
<li>다음 페이지(1/2): <code>ctrl + d</code></li>
<li>이전 페이지(1/2): <code>ctrl + u</code></li>
</ul>
</li>
</ul>
<h2 id="편집"><a class="header" href="#편집">편집</a></h2>
<h3 id="치환"><a class="header" href="#치환">치환</a></h3>
<p>561~562 라인의 <code>th</code><strong>로 시작하는 문자열</strong>을 <code>7h</code>로 시작하는 문자열로 치환한다.</p>
<ul>
<li>라인 내에서 치환: <code>s/old/new/g</code></li>
<li>범위 내의 일치하는 조건 모두 치환: <code>#,#s/old/new/g</code></li>
<li>전체 파일범위 치환: <code>%s/old/new/g</code> </li>
<li>전체 파일범위 치환여부 프롬프트 제공: <code>%s/old/new/gc</code> </li>
</ul>
<h4 id="예제-th-문자를-7h-문자로-변환"><a class="header" href="#예제-th-문자를-7h-문자로-변환">예제 th* 문자를 7h* 문자로 변환</a></h4>
<ul>
<li>명령어: <code>561,562s/\(th\(\w\+\)\)/7h\2/g</code></li>
<li>변경 전 문장</li>
</ul>
<pre><code class="language-vim">561  2. Type  :s/thee/the &lt;ENTER&gt; .  Note that this command only changes the
562     first occurrence of &quot;thee&quot; in the line.
</code></pre>
<ul>
<li>변경 후 문장</li>
</ul>
<pre><code class="language-vim">561   2. Type  :s/7hee/7he &lt;ENTER&gt; .  Note 7hat 7his command only changes 7he
562      first occurrence of &quot;7hee&quot; in 7he line.
</code></pre>
<h2 id="윈도우"><a class="header" href="#윈도우">윈도우</a></h2>
<ul>
<li>새로운 윈도우 생성: <code>split</code> (수평) / <code>vsplit</code> (수직)</li>
<li>윈도우 간 이동: <code>C-w</code> + <code>h, j, k, l</code> (기본이동)</li>
</ul>
<h2 id="버퍼"><a class="header" href="#버퍼">버퍼</a></h2>
<ul>
<li>파일 이동: <code>bnext</code>, <code>bprev</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="일렉트론-프로젝트를-electron-packager를-사용해서-패키징하기"><a class="header" href="#일렉트론-프로젝트를-electron-packager를-사용해서-패키징하기">일렉트론 프로젝트를 electron-packager를 사용해서 패키징하기</a></h1>
<p>아래 명령은 일렉트론 기반의 레디스 클라이언트인 메디스를 패키징하는 명령어이다.</p>
<pre><code class="language-console">$ electron-packager . medis --platform=darwin --overwrite --out dist2/ --icon resources/icns/MyIcon.icns
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="잡다한-macos-관련-내용"><a class="header" href="#잡다한-macos-관련-내용">잡다한 macos 관련 내용</a></h1>
<h2 id="시동음-살리기"><a class="header" href="#시동음-살리기">시동음 살리기</a></h2>
<pre><code class="language-console">$ sudo nvram StartupMute=%00 # 시동음 켜기
$ sudo nvram StartupMute=%01 # 시동음 끄기
</code></pre>
<h3 id="출처-트위터"><a class="header" href="#출처-트위터">출처: 트위터</a></h3>
<blockquote class="twitter-tweet"><p lang="ko" dir="ltr">2016년 이후에 출시된 맥에서 예전의 시동음을 되살리는 법:<br><br>1. 터미널을 열고 다음을 입력: sudo nvram StartupMute=%00<br>2. 재시동<br>3. 감격의 😭😭😭<br><br>다시 끌 때는 %00 대신 %01<a href="https://t.co/rKK6YLrjWn">https://t.co/rKK6YLrjWn</a></p>&mdash; 김정현 (@gluebyte) <a href="https://twitter.com/gluebyte/status/1232954729816195074?ref_src=twsrc%5Etfw">February 27, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
