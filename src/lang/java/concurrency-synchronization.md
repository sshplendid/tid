# 동기화 (Synchronization)

> [Java Tutorials - Concurrency](https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html)를 읽고 번역해본다.

쓰레드는 주로 관련된 필드와 객체 참조 필드에 대한 접근을 공유함으로써 커뮤니케이션을 한다. 이런 커뮤니케이션의 형태는 효율적이지만 두 종류의 오류가 발생할 가능성이 있다. *쓰레드 간섭*과 *메모리 일관성 오류*가 그것이다. 이런 오류를 예방하기 위한 도구가 *동기화*이다.

그러나 동기화는 *쓰레드 간의 논쟁*을 일으킬 수 있다. 이는 두개 이상의 쓰레드에서 한 리소스에 동시에 접근하려고 할 때 발생하고, Java 런타임이 하나 이상의 쓰레드를 더 느리게 실행하거나 심지어 실행을 정지할 수 도 있다. 쓰레드 논쟁의 형태는 Starvation과 livelock이다. 이는 Liveness 섹션에서 더 다룬다.

## 쓰레드 간섭 (Thread Interference)

아래 클래스를 보자.

```java
class Counter {
    private int c = 0;

    public void increment() {
        c++;
    }

    public void decrement() {
        c--;
    }

    public int value() {
        return c;
    }

}
```

`Counter` 클래스는 `increment` 메서드가 `c` 필드에 1을 더하도록, `decrement` 메서드가 `c` 필드의 값을 빼도록 설계되어 있다. 그러가 만약 이 객체가 여러 쓰레드에서 참조되고 있다면 쓰레드 간의 간섭은 이 객체의 설계가 의도한대로 동작하지 못하도록 막을 것이다.

간섭은 *interleave*, 동일 데이터에 대한 두 개의 동작이 다른 쓰레드에서 실행될 때 발생한다. 이는 두 동작이 여러 단계로 구성되고 각 단계의 순서가 중첩되는 것을 의미한다.

`Counter` 인스턴스가 인터리빙하는 동작은 두 동작 모두 `c`라는 하나의 단순한 명령문이기 때문에 불가능해 보인다. 그러나 단순한 명령문도 가상머신에 의해 여러단계의 명령으로 변환될 수 있다. (여기선 가상머신에 대해서 다루지 않는다. 아래와 같이 한 줄의 `c++` 표현식이 세 단계로 분해된다는 정도만 알면 된다.)

1. `c` 필드의 현재 값을 가져온다.
2. 가져온 값에 1을 증가시킨다.
3. 증가된 값을 다시 `c` 필드에 저장한다.

`c--` 표현식도 두 번째 단계에서 값이 감소되는 것을 제외하면 역시 동일한 방법으로 분해된다.

쓰레드 A가 `increment`를 적용하는 동시에 쓰레드 B가 `decrement`를 적용하는 상황을 가정해보자. 만약 `c`의 최초값이 0이라면, 인터리빙 액션은 다음의 단계를 따른다.

1. 쓰레드 A: `c`의 값을 가져온다.
2. 쓰레드 B: `c`의 값을 가져온다.
3. 쓰레드 A: 가져온 값을 증가시킨다. 결과는 1
4. 쓰레드 B: 가져온 값을 감소시킨다. 결과는 -1
5. 쓰레드 A: `c`에 결과를 저장한다. 이제 `c`는 1이다.
6. 쓰레드 B: `c`에 결과를 저장한다. 이제 `c`는 -1이다.

쓰레드 A의 결과는 잃게되고 쓰레드 B의 결과로 덮어쓰게 된다. 이런 특정 인터리빙은 오직 한 가능성만 있다. 다른 상황에서 쓰레드 B의 결과는 잃거나, 어떤 에러도 발생하지 않을 수 있다. 이는 예측 불가능하기 때문에, 쓰레드 간섭 버그는 발견하고 고치기 어렵다.

## 메모리 일관성 오류 (Memory Consistency Errors)

메모리 일관성 오류는 서로 다른 쓰레드가 동일한 값이어야 하는 데이터 접근에 대한 모순된 결과가 있을 때 발생한다.
이에 대한 원인은 복잡하고 이 튜토리얼의 범위를 넘어선다. 프로그래머는 이 원인에 대한 디테일한 이해를 할 필요가 없다. 중요한건 이를 피하는 전략이다.

메모리 일관성 오류를 피하는 키는 *happens-before* 관계를 이해하는 것이다. 이 관계는 단순히 어떤 명령이 메모리를 쓰면 다른 특정 명령에선 그 결과가 보이는 것을 보장하는 것이다. 아래와 같은 예제에서, `int` 필드는 초기화되어 있다.

```java
int counter = 0;
```

이 `counter` 필드는 두 쓰레드 A와 B 간에 공유되고 있다. 쓰레드 A가 counter 값을 증가시킨다고 가정하자.

```java
counter++;
```

그리고 곧 쓰레드 B가 값을 출력한다.

```java
System.out.println(counter);
```

만약 두 명령문이 동일 쓰레드에서 실행되었다면 당연하게도 출력된 값은 "1"이 될 것이다. 그러나 두 문장이 서로 다른 쓰레드에서 실행되었다면, 출력된 값은 "0"이 될 수도 있다. 쓰레드 A가 변경한 값이 쓰레드 B에 반영됨을 보장할 수 없기 때문이다. 프로그래머가 happens-before 관계를 설정했음에도 불구하고 말이다.

happens-before 관계를 만드는건 여러 방법이 있다. 그 중 하나가 동기화이다.

우린 이미 happens-before 관계를 만드는 두 가지 방법을 확인했다.

* 명령문이 `Thread.start`를 적용해서, 이 관계를 가진 모든 명령문을 새로운 쓰레드에서 실행한다. 새 쓰레드의 생성을 주도한(예를 들면 메인 쓰레드)의 효과는 새로운 쓰레드에서 적용된다.
* 쓰레드를 종료하거나 `Thread.join`으로 인해 다른 쓰레드에서 되돌아오는 경우, 종료된 쓰레드에서 실행된 명령문은 happens-before 관계를 가진다. 쓰레드 내 코드의 효과는 `join`을 수행한 쓰레드에 적용된다.

## 동기화 메서드 (Synchronizaed methods)

Java는 두 가지 동기화 방법을 제공한다. *synchronized methods*와 *synchronized statements*가 그 방법이다. 더 복잡한 *synchronized statements*는 다음 장에서 다룬다. 이 장에선 *synchronized methods*를 다룬다.

메서드를 동기화하기 위해선 간단히 `synchronized` 예약어를 선언부에 추가하면 된다.

```java
public class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }
}
```

만약 `count`가 `SynchronizedCountr`의 인스턴스라면, 동기화된 메서드는 두 가지 효과를 가진다.

* 동일 객체에 대한 두 동기화 메서드의 인터리빙이 불가능하다. 한 쓰레드가 동기화 메서드를 실행할 때, 다른 모든 쓰레드는 첫 번째 쓰레드의 작업이 끝날 때까지 객체의 접근이 블락(실행 정지)된다.
* 동기화 메서드의 실행이 끝날 때, 다른 동기화 메서드들에 자동적으로 happens-before 관계가 적용된다. 이는 모든 쓰레드들이 바라보는 객체의 상태가 변한 것을 보장한다.

> 생성자는 동기화 메서드를 사용할 수 없다. 이는 구문 오류이다. 생성자를 동기화 하는 것은 말이 되지 않는다. 오직 한 쓰레드가 객체를 생성할 수 있다.

> 쓰레드 간에 공유해야 하는 객체를 생성할 때 객체 참조가 새는 것을 조심해야 한다. 모든 클래스 인스턴스를 가지고 있는 **instaces**라는 이름의 List 객체를 가지고 있다고 가정하자. 생성자 부분에 다음과 같은 코드를 추가할 수 도 있다.  
> ```java
> instances.add(this);
> ```  
> 다른 쓰레드 역시 객체 생성이 완료되기 전에 **instances** 객체를 사용할 수 있기 때문에 주의해야 한다.

동기화 메서드는 쓰레드 간섭과 메모리 일관성 오류를 예방하는 전략이다. 만약 객체가 하나 이상의 쓰레드에서 참조되는 경우, 객체 필드에 대한 모든 읽기/쓰기 메서드는 `synchronized` 메서드여야 한다. `final` 필드에 대한 메서드는 제외이다. 이 전략은 효과적이지만 liveness와 관련된 문제가 발생한다.

## Intrinsic Locks and Synchronization

동기화는 *Instrinsic lock* 또는 *Monitoring lock*(API 스펙엔 단순하게 "monitor"라고 표시되있음)으로 알려진 내부 엔티티에 의해 구성된다. Intrinsic lock은 동기화의 두 관점, 객체 상태의 독접적인 접근 강요 및 happens-before 관계 설정에서 역할을 수행한다. 

모든 객체는 instrinsic lock을 가지고 있다. 컨벤션에 의해, 객체 필드에 대한 독점적이고 일관성 있는 접근을 원하는 쓰레드는 객체에 접근하기 전에 객체의 instrinsic lock을 획득해야 한다. 그리고 객체와 관련된 작업이 끝난 후엔 lock을 반환해야 한다. 쓰레드는 lock을 획득하고 반환하는 사이에 intrinsic lock을 가지고 있다고 알려야 한다. 쓰레드가 소유하는 만큼 다른 쓰레드는 lock을 획득할 수 없다. lock을 획득할 때까지 block 상태를 유지한다.

쓰레드가 intrinsic lock을 반환할 때 happens-before 관계가 성립된다.